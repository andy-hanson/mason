if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	if (typeof window !== 'undefined') window.global = window;else global.window = global;

	const pAdd = (object, key, value) => Object.defineProperty(object, key, {
		value,
		writable: false,
		enumerable: false,
		configurable: false
	});

	exports.pAdd = pAdd;
	// region Builtin Functions for use by the compiler
	const
	// This object contains functions called upon by compiled code.
	ms = {},
	      msDef = (name, fun) => pAdd(ms, name, fun),
	      msCall = function (name) {
		// TODO:ES6 Splat
		const args = Array.prototype.slice.call(arguments, 1);
		return ms[name](...args);
	};

	exports.ms = ms;
	exports.msDef = msDef;
	exports.msCall = msCall;
	pAdd(global, '_ms', ms);

	const indent = str => str.replace(/\n/g, '\n\t');

	const msDefs = {
		// TODO: use +! method
		add(bag, value) {
			bag.push(value);
		},

		addMany(bag, values) {
			for (let value of values) ms.add(bag, value);
		},

		assert(fun) {
			// TODO:ES6 Splat
			const args = Array.prototype.slice.call(arguments, 1);
			if (!Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.inspect).join('\n');
				throw new Error(`assert! ${ fun.name }\n\t${ indent(showArgs) }`);
			}
		},

		assertNot(fun) {
			// TODO:ES6 Splat
			const args = Array.prototype.slice.call(arguments, 1);
			if (Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.inspect).join('\n');
				throw new Error(`forbid! ${ fun.name }\n\t${ indent(showArgs) }`);
			}
		},

		lazyGetModule(module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get : ms.lazy(() => module);
		},

		getModule(module) {
			if (module == null) return null;
			//if (module === undefined)
			//	throw new Error('Module undefined.')
			return module._get instanceof ms.Lazy ? module._get.get() : module;
		},

		getDefaultExport(module) {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp(lazyObject, key) {
			if (!(lazyObject instanceof ms.Lazy)) throw new Error(`Expected a Lazy, got: ${ lazyObject }`);
			return ms.lazy(() => lazyObject.get()[key]);
		},

		get(object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error(`Module ${ object.name } does not have ${ key }`);
			return _;
		},

		error(err) {
			if (err instanceof Error) return err;else if (typeof err === 'string') return new Error(err);else if (err instanceof _ms.Lazy) return _ms.error(err.get());else throw new Error('Thrown value must be Error or String');
		},

		Lazy: function Lazy(get) {
			this.get = () => {
				this.get = () => {
					throw new Error(`Lazy value depends on itself. Thunk: ${ get }`);
				};
				const _ = get();
				this.get = () => _;
				return _;
			};
		},
		lazy: _ => new ms.Lazy(_),
		unlazy: _ => _ instanceof ms.Lazy ? _.get() : _,

		// Unlike Object.assign, does *not* invoke getters.
		set(value, propertiesObject, opName) {
			for (const key in propertiesObject) Object.defineProperty(value, key, Object.getOwnPropertyDescriptor(propertiesObject, key));
			if (!(value instanceof Function)) if (opName !== undefined) ms.setName(value, opName);
			return value;
		},
		setName(value, name) {
			value.name = name;
			return value;
		},
		setLazy(value, name, lazy) {
			Object.defineProperty(value, name, { get: lazy.get, enumerable: true });
		},

		symbol(value) {
			const symbol = value['impl-symbol'];
			return symbol === undefined ? value : symbol;
		},

		newProperty(object, name, value) {
			if (Object.prototype.hasOwnProperty.call(object, name)) throw new Error(`Property ${ name } already exists.`);
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: true,
				writable: false,
				value
			});
		},
		newMutableProperty(object, name, value) {
			if (Object.prototype.hasOwnProperty.call(object, name)) throw new Error(`Property ${ name } already exists.`);
			object[name] = value;
		}
	};
	for (const def in msDefs) msDef(def, msDefs[def]);

	const msDefTemp = (name, fun) => ms[name] = fun;

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = Symbol('contains?');
	exports.containsImplSymbol = containsImplSymbol;
	const implContains = (type, impl) => pAdd(type.prototype, containsImplSymbol, impl);

	exports.implContains = implContains;
	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', (_type, val) => val);

	// Since these are primitives, we can't use `instanceof`.
	for (const type of [Boolean, String, Symbol, Number]) {
		// Generated code is faster than using a closure.
		const src = 'return typeof _ === "' + type.name.toLowerCase() + '"';
		pAdd(type, containsImplSymbol, Function('_', src));
	}

	// Functions are Objects, so we do this one differently.
	// TODO: This treats Object.create(null) as an object. Do we want that?
	pAdd(Object, containsImplSymbol, function (_) {
		if (_ === null) return false;
		switch (typeof _) {
			case 'function':
			case 'object':
				return true;
			default:
				return false;
		}
	});

	implContains(Function, function (_) {
		return _ instanceof this;
	});
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaXZhdGUvYm9vdHN0cmFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEtBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUNoQyxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQSxLQUV0QixNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTs7QUFFaEIsT0FBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssS0FDdEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0FBQ2xDLE9BQUs7QUFDTCxVQUFRLEVBQUUsS0FBSztBQUNmLFlBQVUsRUFBRSxLQUFLO0FBQ2pCLGNBQVksRUFBRSxLQUFLO0VBQ25CLENBQUMsQ0FBQTs7OztBQUdJOztBQUVOLEdBQUUsR0FBRyxFQUFHO09BQ1IsS0FBSyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FDakIsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDO09BQ3BCLE1BQU0sR0FBRyxVQUFTLElBQUksRUFBRTs7QUFFdkIsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUNyRCxTQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFBO0VBQ3hCLENBQUE7Ozs7O0FBRUYsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUE7O0FBRXZCLE9BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTs7QUFFaEQsT0FBTSxNQUFNLEdBQUc7O0FBRWQsS0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUU7QUFDZixNQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0dBQ2Y7O0FBRUQsU0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDcEIsUUFBSyxJQUFJLEtBQUssSUFBSSxNQUFNLEVBQ3ZCLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0dBQ25COztBQUVELFFBQU0sQ0FBQyxHQUFHLEVBQUU7O0FBRVgsU0FBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUNyRCxPQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7QUFDcEQsVUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ2pELFVBQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxRQUFRLEdBQUUsR0FBRyxDQUFDLElBQUksRUFBQyxJQUFJLEdBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0lBQzdEO0dBQ0Q7O0FBRUQsV0FBUyxDQUFDLEdBQUcsRUFBRTs7QUFFZCxTQUFNLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBQ3JELE9BQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7QUFDbkQsVUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ2pELFVBQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxRQUFRLEdBQUUsR0FBRyxDQUFDLElBQUksRUFBQyxJQUFJLEdBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0lBQzdEO0dBQ0Q7O0FBRUQsZUFBYSxDQUFDLE1BQU0sRUFBRTtBQUNyQixPQUFJLE1BQU0sS0FBSyxTQUFTLEVBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtBQUNyQyxVQUFPLE1BQU0sQ0FBQyxJQUFJLFlBQVksRUFBRSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxNQUFNLENBQUMsQ0FBQTtHQUMzRTs7QUFFRCxXQUFTLENBQUMsTUFBTSxFQUFFO0FBQ2pCLE9BQUksTUFBTSxJQUFJLElBQUksRUFBRSxPQUFPLElBQUksQ0FBQTs7O0FBRy9CLFVBQU8sTUFBTSxDQUFDLElBQUksWUFBWSxFQUFFLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFBO0dBQ2xFOztBQUVELGtCQUFnQixDQUFDLE1BQU0sRUFBRTtBQUN4QixPQUFJLE1BQU0sS0FBSyxTQUFTLEVBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtBQUNyQyxTQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQ2hDLFVBQU8sR0FBRyxDQUFDLE9BQU8sS0FBSyxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUE7R0FDcEQ7O0FBRUQsVUFBUSxDQUFDLFVBQVUsRUFBRSxHQUFHLEVBQUU7QUFDekIsT0FBSSxFQUFFLFVBQVUsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFBLEFBQUMsRUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLHNCQUFzQixHQUFFLFVBQVUsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUN2RCxVQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtHQUMzQzs7QUFFRCxLQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUNoQixTQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDckIsT0FBSSxDQUFDLEtBQUssU0FBUyxFQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsT0FBTyxHQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUMsZUFBZSxHQUFFLEdBQUcsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUM5RCxVQUFPLENBQUMsQ0FBQTtHQUNSOztBQUVELE9BQUssQ0FBQyxHQUFHLEVBQUU7QUFDVixPQUFJLEdBQUcsWUFBWSxLQUFLLEVBQ3ZCLE9BQU8sR0FBRyxDQUFBLEtBQ04sSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQy9CLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUEsS0FDakIsSUFBSSxHQUFHLFlBQVksR0FBRyxDQUFDLElBQUksRUFDL0IsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFBLEtBRTNCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQTtHQUN4RDs7QUFFRCxNQUFJLEVBQUUsU0FBUyxJQUFJLENBQUMsR0FBRyxFQUFFO0FBQ3hCLE9BQUksQ0FBQyxHQUFHLEdBQUcsTUFBTTtBQUNoQixRQUFJLENBQUMsR0FBRyxHQUFHLE1BQU07QUFDaEIsV0FBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLHFDQUFxQyxHQUFFLEdBQUcsRUFBQyxDQUFDLENBQUMsQ0FBQTtLQUM5RCxDQUFBO0FBQ0QsVUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUE7QUFDZixRQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFBO0FBQ2xCLFdBQU8sQ0FBQyxDQUFBO0lBQ1IsQ0FBQTtHQUNEO0FBQ0QsTUFBSSxFQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLFFBQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7OztBQUcvQyxLQUFHLENBQUMsS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRTtBQUNwQyxRQUFLLE1BQU0sR0FBRyxJQUFJLGdCQUFnQixFQUNqQyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQy9CLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQ3pELE9BQUksRUFBRSxLQUFLLFlBQVksUUFBUSxDQUFBLEFBQUMsRUFDL0IsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUN2QixFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTtBQUMzQixVQUFPLEtBQUssQ0FBQTtHQUNaO0FBQ0QsU0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7QUFDcEIsUUFBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUE7QUFDakIsVUFBTyxLQUFLLENBQUE7R0FDWjtBQUNELFNBQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUMxQixTQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtHQUN2RTs7QUFFRCxRQUFNLENBQUMsS0FBSyxFQUFFO0FBQ2IsU0FBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBQ25DLFVBQU8sTUFBTSxLQUFLLFNBQVMsR0FBRyxLQUFLLEdBQUcsTUFBTSxDQUFBO0dBQzVDOztBQUVELGFBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTtBQUNoQyxPQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQ3JELE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxTQUFTLEdBQUUsSUFBSSxFQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQTtBQUNwRCxTQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDbkMsZ0JBQVksRUFBRSxJQUFJO0FBQ2xCLGNBQVUsRUFBRSxJQUFJO0FBQ2hCLFlBQVEsRUFBRSxLQUFLO0FBQ2YsU0FBSztJQUNMLENBQUMsQ0FBQTtHQUNGO0FBQ0Qsb0JBQWtCLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDdkMsT0FBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUNyRCxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsU0FBUyxHQUFFLElBQUksRUFBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUE7QUFDcEQsU0FBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQTtHQUNwQjtFQUNELENBQUE7QUFDRCxNQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sRUFDdkIsS0FBSyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTs7QUFFeEIsT0FBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUMzQixFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFBOzs7O0FBSVIsT0FBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7O0FBQzlDLE9BQU0sWUFBWSxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksS0FDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLENBQUE7Ozs7QUFHL0MsVUFBUyxDQUFDLGVBQWUsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUE7OztBQUcvQyxNQUFLLE1BQU0sSUFBSSxJQUFJLENBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFFLEVBQUU7O0FBRXZELFFBQU0sR0FBRyxHQUFHLHVCQUF1QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFBO0FBQ25FLE1BQUksQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0VBQ2xEOzs7O0FBSUQsS0FBSSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxVQUFTLENBQUMsRUFBRTtBQUM1QyxNQUFJLENBQUMsS0FBSyxJQUFJLEVBQ2IsT0FBTyxLQUFLLENBQUE7QUFDYixVQUFRLE9BQU8sQ0FBQztBQUNmLFFBQUssVUFBVSxDQUFDO0FBQ2hCLFFBQUssUUFBUTtBQUNaLFdBQU8sSUFBSSxDQUFBO0FBQUEsQUFDWjtBQUNDLFdBQU8sS0FBSyxDQUFBO0FBQUEsR0FDYjtFQUNELENBQUMsQ0FBQTs7QUFFRixhQUFZLENBQUMsUUFBUSxFQUFFLFVBQVMsQ0FBQyxFQUFFO0FBQUUsU0FBTyxDQUFDLFlBQVksSUFBSSxDQUFBO0VBQUUsQ0FBQyxDQUFBIiwiZmlsZSI6InByaXZhdGUvYm9vdHN0cmFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHR3aW5kb3cuZ2xvYmFsID0gd2luZG93XG5lbHNlXG5cdGdsb2JhbC53aW5kb3cgPSBnbG9iYWxcblxuZXhwb3J0IGNvbnN0IHBBZGQgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PlxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcblx0XHR2YWx1ZSxcblx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZVxuXHR9KVxuXG4vLyByZWdpb24gQnVpbHRpbiBGdW5jdGlvbnMgZm9yIHVzZSBieSB0aGUgY29tcGlsZXJcbmV4cG9ydCBjb25zdFxuXHQvLyBUaGlzIG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgY2FsbGVkIHVwb24gYnkgY29tcGlsZWQgY29kZS5cblx0bXMgPSB7IH0sXG5cdG1zRGVmID0gKG5hbWUsIGZ1bikgPT5cblx0XHRwQWRkKG1zLCBuYW1lLCBmdW4pLFxuXHRtc0NhbGwgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0Ly8gVE9ETzpFUzYgU3BsYXRcblx0XHRjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHRcdHJldHVybiBtc1tuYW1lXSguLi5hcmdzKVxuXHR9XG5cbnBBZGQoZ2xvYmFsLCAnX21zJywgbXMpXG5cbmNvbnN0IGluZGVudCA9IHN0ciA9PiBzdHIucmVwbGFjZSgvXFxuL2csICdcXG5cXHQnKVxuXG5jb25zdCBtc0RlZnMgPSB7XG5cdC8vIFRPRE86IHVzZSArISBtZXRob2Rcblx0YWRkKGJhZywgdmFsdWUpIHtcblx0XHRiYWcucHVzaCh2YWx1ZSlcblx0fSxcblxuXHRhZGRNYW55KGJhZywgdmFsdWVzKSB7XG5cdFx0Zm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKVxuXHRcdFx0bXMuYWRkKGJhZywgdmFsdWUpXG5cdH0sXG5cblx0YXNzZXJ0KGZ1bikge1xuXHRcdC8vIFRPRE86RVM2IFNwbGF0XG5cdFx0Y29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0XHRpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGZ1biwgbnVsbCwgYXJncykpIHtcblx0XHRcdGNvbnN0IHNob3dBcmdzID0gYXJncy5tYXAoX21zLmluc3BlY3QpLmpvaW4oJ1xcbicpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGFzc2VydCEgJHtmdW4ubmFtZX1cXG5cXHQke2luZGVudChzaG93QXJncyl9YClcblx0XHR9XG5cdH0sXG5cblx0YXNzZXJ0Tm90KGZ1bikge1xuXHRcdC8vIFRPRE86RVM2IFNwbGF0XG5cdFx0Y29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0XHRpZiAoRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZnVuLCBudWxsLCBhcmdzKSkge1xuXHRcdFx0Y29uc3Qgc2hvd0FyZ3MgPSBhcmdzLm1hcChfbXMuaW5zcGVjdCkuam9pbignXFxuJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZm9yYmlkISAke2Z1bi5uYW1lfVxcblxcdCR7aW5kZW50KHNob3dBcmdzKX1gKVxuXHRcdH1cblx0fSxcblxuXHRsYXp5R2V0TW9kdWxlKG1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdHJldHVybiBtb2R1bGUuX2dldCBpbnN0YW5jZW9mIG1zLkxhenkgPyBtb2R1bGUuX2dldCA6IG1zLmxhenkoKCkgPT4gbW9kdWxlKVxuXHR9LFxuXG5cdGdldE1vZHVsZShtb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlID09IG51bGwpIHJldHVybiBudWxsXG5cdFx0Ly9pZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0Ly9cdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdHJldHVybiBtb2R1bGUuX2dldCBpbnN0YW5jZW9mIG1zLkxhenkgPyBtb2R1bGUuX2dldC5nZXQoKSA6IG1vZHVsZVxuXHR9LFxuXG5cdGdldERlZmF1bHRFeHBvcnQobW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0Y29uc3QgbW9kID0gbXMuZ2V0TW9kdWxlKG1vZHVsZSlcblx0XHRyZXR1cm4gbW9kLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IG1vZCA6IG1vZC5kZWZhdWx0XG5cdH0sXG5cblx0bGF6eVByb3AobGF6eU9iamVjdCwga2V5KSB7XG5cdFx0aWYgKCEobGF6eU9iamVjdCBpbnN0YW5jZW9mIG1zLkxhenkpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIExhenksIGdvdDogJHtsYXp5T2JqZWN0fWApXG5cdFx0cmV0dXJuIG1zLmxhenkoKCkgPT4gbGF6eU9iamVjdC5nZXQoKVtrZXldKVxuXHR9LFxuXG5cdGdldChvYmplY3QsIGtleSkge1xuXHRcdGNvbnN0IF8gPSBvYmplY3Rba2V5XVxuXHRcdGlmIChfID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE1vZHVsZSAke29iamVjdC5uYW1lfSBkb2VzIG5vdCBoYXZlICR7a2V5fWApXG5cdFx0cmV0dXJuIF9cblx0fSxcblxuXHRlcnJvcihlcnIpIHtcblx0XHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRyZXR1cm4gZXJyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gbmV3IEVycm9yKGVycilcblx0XHRlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBfbXMuTGF6eSlcblx0XHRcdHJldHVybiBfbXMuZXJyb3IoZXJyLmdldCgpKVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhyb3duIHZhbHVlIG11c3QgYmUgRXJyb3Igb3IgU3RyaW5nJylcblx0fSxcblxuXHRMYXp5OiBmdW5jdGlvbiBMYXp5KGdldCkge1xuXHRcdHRoaXMuZ2V0ID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5nZXQgPSAoKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTGF6eSB2YWx1ZSBkZXBlbmRzIG9uIGl0c2VsZi4gVGh1bms6ICR7Z2V0fWApXG5cdFx0XHR9XG5cdFx0XHRjb25zdCBfID0gZ2V0KClcblx0XHRcdHRoaXMuZ2V0ID0gKCkgPT4gX1xuXHRcdFx0cmV0dXJuIF9cblx0XHR9XG5cdH0sXG5cdGxhenk6IF8gPT4gbmV3IG1zLkxhenkoXyksXG5cdHVubGF6eTogXyA9PiBfIGluc3RhbmNlb2YgbXMuTGF6eSA/IF8uZ2V0KCkgOiBfLFxuXG5cdC8vIFVubGlrZSBPYmplY3QuYXNzaWduLCBkb2VzICpub3QqIGludm9rZSBnZXR0ZXJzLlxuXHRzZXQodmFsdWUsIHByb3BlcnRpZXNPYmplY3QsIG9wTmFtZSkge1xuXHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXNPYmplY3QpXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIGtleSxcblx0XHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzT2JqZWN0LCBrZXkpKVxuXHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuXHRcdFx0aWYgKG9wTmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRtcy5zZXROYW1lKHZhbHVlLCBvcE5hbWUpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cdHNldE5hbWUodmFsdWUsIG5hbWUpIHtcblx0XHR2YWx1ZS5uYW1lID0gbmFtZVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXHRzZXRMYXp5KHZhbHVlLCBuYW1lLCBsYXp5KSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBuYW1lLCB7IGdldDogbGF6eS5nZXQsIGVudW1lcmFibGU6IHRydWUgfSlcblx0fSxcblxuXHRzeW1ib2wodmFsdWUpIHtcblx0XHRjb25zdCBzeW1ib2wgPSB2YWx1ZVsnaW1wbC1zeW1ib2wnXVxuXHRcdHJldHVybiBzeW1ib2wgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogc3ltYm9sXG5cdH0sXG5cblx0bmV3UHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtuYW1lfSBhbHJlYWR5IGV4aXN0cy5gKVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZVxuXHRcdH0pXG5cdH0sXG5cdG5ld011dGFibGVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAke25hbWV9IGFscmVhZHkgZXhpc3RzLmApXG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWVcblx0fVxufVxuZm9yIChjb25zdCBkZWYgaW4gbXNEZWZzKVxuXHRtc0RlZihkZWYsIG1zRGVmc1tkZWZdKVxuXG5jb25zdCBtc0RlZlRlbXAgPSAobmFtZSwgZnVuKSA9PlxuXHRtc1tuYW1lXSA9IGZ1blxuXG4vLyByZWdpb24gQ29udGFpbnNcbi8vIFNvbWUgVHlwZXMgd2FudCB0byBpbXBsZW1lbnQgY29udGFpbnM/IGJlZm9yZSBpdCBpcyBvZmZpY2lhbGx5IGRlZmluZWQuXG5leHBvcnQgY29uc3QgY29udGFpbnNJbXBsU3ltYm9sID0gU3ltYm9sKCdjb250YWlucz8nKVxuZXhwb3J0IGNvbnN0IGltcGxDb250YWlucyA9ICh0eXBlLCBpbXBsKSA9PlxuXHRwQWRkKHR5cGUucHJvdG90eXBlLCBjb250YWluc0ltcGxTeW1ib2wsIGltcGwpXG5cbi8vIE92ZXJ3cml0dGVuIGJ5IFR5cGUvaW5kZXgubXMgdG8gYWN0dWFsbHkgZG8gdHlwZSBjaGVja2luZy5cbm1zRGVmVGVtcCgnY2hlY2tDb250YWlucycsIChfdHlwZSwgdmFsKSA9PiB2YWwpXG5cbi8vIFNpbmNlIHRoZXNlIGFyZSBwcmltaXRpdmVzLCB3ZSBjYW4ndCB1c2UgYGluc3RhbmNlb2ZgLlxuZm9yIChjb25zdCB0eXBlIG9mIFsgQm9vbGVhbiwgU3RyaW5nLCBTeW1ib2wsIE51bWJlciBdKSB7XG5cdC8vIEdlbmVyYXRlZCBjb2RlIGlzIGZhc3RlciB0aGFuIHVzaW5nIGEgY2xvc3VyZS5cblx0Y29uc3Qgc3JjID0gJ3JldHVybiB0eXBlb2YgXyA9PT0gXCInICsgdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgKyAnXCInXG5cdHBBZGQodHlwZSwgY29udGFpbnNJbXBsU3ltYm9sLCBGdW5jdGlvbignXycsIHNyYykpXG59XG5cbi8vIEZ1bmN0aW9ucyBhcmUgT2JqZWN0cywgc28gd2UgZG8gdGhpcyBvbmUgZGlmZmVyZW50bHkuXG4vLyBUT0RPOiBUaGlzIHRyZWF0cyBPYmplY3QuY3JlYXRlKG51bGwpIGFzIGFuIG9iamVjdC4gRG8gd2Ugd2FudCB0aGF0P1xucEFkZChPYmplY3QsIGNvbnRhaW5zSW1wbFN5bWJvbCwgZnVuY3Rpb24oXykge1xuXHRpZiAoXyA9PT0gbnVsbClcblx0XHRyZXR1cm4gZmFsc2Vcblx0c3dpdGNoICh0eXBlb2YgXykge1xuXHRcdGNhc2UgJ2Z1bmN0aW9uJzpcblx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn0pXG5cbmltcGxDb250YWlucyhGdW5jdGlvbiwgZnVuY3Rpb24oXykgeyByZXR1cm4gXyBpbnN0YW5jZW9mIHRoaXMgfSlcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9