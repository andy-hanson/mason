if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const pAdd = (object, key, value) => Object.defineProperty(object, key, {
		value,
		writable: false,
		enumerable: false,
		configurable: false
	});

	exports.pAdd = pAdd;
	// region Builtin Functions for use by the compiler
	const
	// This object contains functions called upon by compiled code.
	ms = {},
	      msDef = (name, fun) => pAdd(ms, name, fun),
	      msCall = (name, ...args) => ms[name](...args);

	exports.ms = ms;
	exports.msDef = msDef;
	exports.msCall = msCall;
	pAdd(global, '_ms', ms);

	const indent = str => str.replace(/\n/g, '\n\t');

	const msDefs = {
		// TODO: use +! method
		add(bag, value) {
			bag.push(value);
		},

		addMany(bag, values) {
			for (let value of values) ms.add(bag, value);
		},

		assert(fun, ...args) {
			if (!Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.repr).join('\n');
				throw new Error(`assert! ${ _ms.show(fun) }\n\t${ indent(showArgs) }`);
			}
		},

		assertNot(fun, ...args) {
			if (Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.repr).join('\n');
				throw new Error(`forbid! ${ _ms.show(fun) }\n\t${ indent(showArgs) }`);
			}
		},

		// TODO: use assoc! method
		assoc(map, key, val) {
			map.set(key, val);
		},

		lazyGetModule(module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get : ms.lazy(() => module);
		},

		getModule(module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get.get() : module;
		},

		getDefaultExport: module => {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp(lazyObject, key) {
			if (!(lazyObject instanceof ms.Lazy)) throw new Error(`Expected a Lazy, got: ${ lazyObject }`);
			return ms.lazy(() => lazyObject.get()[key]);
		},

		get(object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error(`Module ${ object.name } does not have ${ key }`);
			return _;
		},

		bool(b) {
			if (typeof b !== 'boolean') {
				console.log(b);
				throw new Error(`Expected Boolean, got ${ b }`);
			}
			return b;
		},

		// Used for splat calls.
		// TODO:ES6 Shouldn't need. `fun(...arg)` should work for any iterable.
		arr(_) {
			if (_ instanceof Array) return _;
			const out = [];
			for (let em of _) out.push(em);
			return out;
		},

		error(err) {
			if (err instanceof Error) return err;else if (typeof err === 'string') return new Error(err);else if (err instanceof _ms.Lazy) return _ms.error(err.get());else throw new Error('Thrown value must be Error or String');
		},

		// For use by Obj-Type.ms generated code.
		checkNoExtras(_this, _, rtName) {
			// If there was some key in `_` that we didn't copy:
			if (Object.keys(_).length > Object.keys(_this).length) for (const name of Object.getOwnPropertyNames(_))
			// TODO:DISPLAYNAME
			if (name !== 'name') if (!Object.prototype.hasOwnProperty.call(_this, name)) throw new Error('Extra prop ' + name + ' for ' + rtName);
		},

		Lazy: function Lazy(get) {
			this.get = () => {
				this.get = () => {
					throw new Error(`Lazy value depends on itself. Thunk: ${ get }`);
				};
				const _ = get();
				this.get = () => _;
				return _;
			};
		},
		lazy: _ => new ms.Lazy(_),
		unlazy: _ => _ instanceof ms.Lazy ? _.get() : _,

		// Unlike Object.assign, does *not* invoke getters.
		set(value, propertiesObject, opName) {
			for (const key in propertiesObject) Object.defineProperty(value, key, Object.getOwnPropertyDescriptor(propertiesObject, key));
			if (!(value instanceof Function)) if (opName !== undefined) ms.setName(value, opName);
			return value;
		},
		setName(value, name) {
			value.name = name;
			return value;
		},
		setLazy(value, name, lazy) {
			Object.defineProperty(value, name, { get: lazy.get, enumerable: true });
		},

		symbol(value) {
			const symbol = value['impl-symbol'];
			return symbol === undefined ? value : symbol;
		},

		newProperty(object, name, value) {
			if (Object.prototype.hasOwnProperty.call(object, name)) throw new Error(`Property ${ name } already exists.`);
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: true,
				writable: false,
				value
			});
		},
		newMutableProperty(object, name, value) {
			if (Object.prototype.hasOwnProperty.call(object, name)) throw new Error(`Property ${ name } already exists.`);
			object.name = value;
		}
	};
	for (const def in msDefs) msDef(def, msDefs[def]);

	const msDefTemp = (name, fun) => ms[name] = fun;

	// Overridden by show.ms.
	msDefTemp('show', _ => {
		if (typeof _ !== 'string' && typeof _ !== 'number') throw new Error(`Only use Strings or Numbers here until this is overridden by show.ms. Got:\n${ _ }`);
		return _.toString();
	});

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = Symbol('contains?');
	exports.containsImplSymbol = containsImplSymbol;
	const implContains = (type, impl) => pAdd(type.prototype, containsImplSymbol, impl);

	exports.implContains = implContains;
	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', (_type, val) => val);

	// An object is a Function if its typeof is `function`.
	// This helps us catch any callabe Obj-Type.
	// TODO: Separate Function from Callable
	// Since these are primitives, we can't use `instanceof`.
	for (const type of [Function, Boolean, String, Symbol, Number]) {
		// Generated code is faster than using a closure.
		const src = 'return typeof _ === "' + type.name.toLowerCase() + '"';
		pAdd(type, containsImplSymbol, Function('_', src));
	}

	// Functions are Objects, so we do this one differently.
	// TODO: This treats Object.create(null) as an object. Do we want that?
	pAdd(Object, containsImplSymbol, function (_) {
		if (_ === null) return false;
		switch (typeof _) {
			case 'function':
			case 'object':
				return true;
			default:
				return false;
		}
	});

	implContains(Function, function (_) {
		return _ instanceof this;
	});
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaXZhdGUvYm9vdHN0cmFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLE9BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEtBQ3RDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUNsQyxPQUFLO0FBQ0wsVUFBUSxFQUFFLEtBQUs7QUFDZixZQUFVLEVBQUUsS0FBSztBQUNqQixjQUFZLEVBQUUsS0FBSztFQUNuQixDQUFDLENBQUE7O1NBTlUsSUFBSSxHQUFKLElBQUk7O0FBU1Y7O0FBRU4sR0FBRSxHQUFHLEVBQUc7T0FDUixLQUFLLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUNqQixJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUM7T0FDcEIsTUFBTSxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxLQUN0QixFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQTs7U0FKbEIsRUFBRSxHQUFGLEVBQUU7U0FDRixLQUFLLEdBQUwsS0FBSztTQUVMLE1BQU0sR0FBTixNQUFNO0FBR1AsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUE7O0FBRXZCLE9BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTs7QUFFaEQsT0FBTSxNQUFNLEdBQUc7O0FBRWQsS0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUU7QUFDZixNQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0dBQ2Y7O0FBRUQsU0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDcEIsUUFBSyxJQUFJLEtBQUssSUFBSSxNQUFNLEVBQ3ZCLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0dBQ25COztBQUVELFFBQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUU7QUFDcEIsT0FBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO0FBQ3BELFVBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM5QyxVQUFNLElBQUksS0FBSyxDQUFDLENBQUMsUUFBUSxHQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSxHQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtJQUNsRTtHQUNEOztBQUVELFdBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUU7QUFDdkIsT0FBSSxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRTtBQUNuRCxVQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDOUMsVUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLFFBQVEsR0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDLElBQUksR0FBRSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7SUFDbEU7R0FDRDs7O0FBR0QsT0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQ3BCLE1BQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0dBQ2pCOztBQUVELGVBQWEsQ0FBQyxNQUFNLEVBQUU7QUFDckIsT0FBSSxNQUFNLEtBQUssU0FBUyxFQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFt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SSxJQUFJLENBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBRSxFQUFFOztBQUVqRSxRQUFNLEdBQUcsR0FBRyx1QkFBdUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQTtBQUNuRSxNQUFJLENBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQTtFQUNsRDs7OztBQUlELEtBQUksQ0FBQyxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsVUFBUyxDQUFDLEVBQUU7QUFDNUMsTUFBSSxDQUFDLEtBQUssSUFBSSxFQUNiLE9BQU8sS0FBSyxDQUFBO0FBQ2IsVUFBUSxPQUFPLENBQUM7QUFDZixRQUFLLFVBQVUsQ0FBQztBQUNoQixRQUFLLFFBQVE7QUFDWixXQUFPLElBQUksQ0FBQTtBQUFBLEFBQ1o7QUFDQyxXQUFPLEtBQUssQ0FBQTtBQUFBLEdBQ2I7RUFDRCxDQUFDLENBQUE7O0FBRUYsYUFBWSxDQUFDLFFBQVEsRUFBRSxVQUFTLENBQUMsRUFBRTtBQUFFLFNBQU8sQ0FBQyxZQUFZLElBQUksQ0FBQTtFQUFFLENBQUMsQ0FBQSIsImZpbGUiOiJwcml2YXRlL2Jvb3RzdHJhcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBwQWRkID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG5cdFx0dmFsdWUsXG5cdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0fSlcblxuLy8gcmVnaW9uIEJ1aWx0aW4gRnVuY3Rpb25zIGZvciB1c2UgYnkgdGhlIGNvbXBpbGVyXG5leHBvcnQgY29uc3Rcblx0Ly8gVGhpcyBvYmplY3QgY29udGFpbnMgZnVuY3Rpb25zIGNhbGxlZCB1cG9uIGJ5IGNvbXBpbGVkIGNvZGUuXG5cdG1zID0geyB9LFxuXHRtc0RlZiA9IChuYW1lLCBmdW4pID0+XG5cdFx0cEFkZChtcywgbmFtZSwgZnVuKSxcblx0bXNDYWxsID0gKG5hbWUsIC4uLmFyZ3MpID0+XG5cdFx0bXNbbmFtZV0oLi4uYXJncylcblxucEFkZChnbG9iYWwsICdfbXMnLCBtcylcblxuY29uc3QgaW5kZW50ID0gc3RyID0+IHN0ci5yZXBsYWNlKC9cXG4vZywgJ1xcblxcdCcpXG5cbmNvbnN0IG1zRGVmcyA9IHtcblx0Ly8gVE9ETzogdXNlICshIG1ldGhvZFxuXHRhZGQoYmFnLCB2YWx1ZSkge1xuXHRcdGJhZy5wdXNoKHZhbHVlKVxuXHR9LFxuXG5cdGFkZE1hbnkoYmFnLCB2YWx1ZXMpIHtcblx0XHRmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpXG5cdFx0XHRtcy5hZGQoYmFnLCB2YWx1ZSlcblx0fSxcblxuXHRhc3NlcnQoZnVuLCAuLi5hcmdzKSB7XG5cdFx0aWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChmdW4sIG51bGwsIGFyZ3MpKSB7XG5cdFx0XHRjb25zdCBzaG93QXJncyA9IGFyZ3MubWFwKF9tcy5yZXByKS5qb2luKCdcXG4nKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBhc3NlcnQhICR7X21zLnNob3coZnVuKX1cXG5cXHQke2luZGVudChzaG93QXJncyl9YClcblx0XHR9XG5cdH0sXG5cblx0YXNzZXJ0Tm90KGZ1biwgLi4uYXJncykge1xuXHRcdGlmIChGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChmdW4sIG51bGwsIGFyZ3MpKSB7XG5cdFx0XHRjb25zdCBzaG93QXJncyA9IGFyZ3MubWFwKF9tcy5yZXByKS5qb2luKCdcXG4nKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBmb3JiaWQhICR7X21zLnNob3coZnVuKX1cXG5cXHQke2luZGVudChzaG93QXJncyl9YClcblx0XHR9XG5cdH0sXG5cblx0Ly8gVE9ETzogdXNlIGFzc29jISBtZXRob2Rcblx0YXNzb2MobWFwLCBrZXksIHZhbCkge1xuXHRcdG1hcC5zZXQoa2V5LCB2YWwpXG5cdH0sXG5cblx0bGF6eUdldE1vZHVsZShtb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB1bmRlZmluZWQuJylcblx0XHRyZXR1cm4gbW9kdWxlLl9nZXQgaW5zdGFuY2VvZiBtcy5MYXp5ID8gbW9kdWxlLl9nZXQgOiBtcy5sYXp5KCgpID0+IG1vZHVsZSlcblx0fSxcblxuXHRnZXRNb2R1bGUobW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0cmV0dXJuIG1vZHVsZS5fZ2V0IGluc3RhbmNlb2YgbXMuTGF6eSA/IG1vZHVsZS5fZ2V0LmdldCgpIDogbW9kdWxlXG5cdH0sXG5cblx0Z2V0RGVmYXVsdEV4cG9ydDogbW9kdWxlID0+IHtcblx0XHRpZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB1bmRlZmluZWQuJylcblx0XHRjb25zdCBtb2QgPSBtcy5nZXRNb2R1bGUobW9kdWxlKVxuXHRcdHJldHVybiBtb2QuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gbW9kIDogbW9kLmRlZmF1bHRcblx0fSxcblxuXHRsYXp5UHJvcChsYXp5T2JqZWN0LCBrZXkpIHtcblx0XHRpZiAoIShsYXp5T2JqZWN0IGluc3RhbmNlb2YgbXMuTGF6eSkpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgTGF6eSwgZ290OiAke2xhenlPYmplY3R9YClcblx0XHRyZXR1cm4gbXMubGF6eSgoKSA9PiBsYXp5T2JqZWN0LmdldCgpW2tleV0pXG5cdH0sXG5cblx0Z2V0KG9iamVjdCwga2V5KSB7XG5cdFx0Y29uc3QgXyA9IG9iamVjdFtrZXldXG5cdFx0aWYgKF8gPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTW9kdWxlICR7b2JqZWN0Lm5hbWV9IGRvZXMgbm90IGhhdmUgJHtrZXl9YClcblx0XHRyZXR1cm4gX1xuXHR9LFxuXG5cdGJvb2woYikge1xuXHRcdGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhiKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBCb29sZWFuLCBnb3QgJHtifWApXG5cdFx0fVxuXHRcdHJldHVybiBiXG5cdH0sXG5cblx0Ly8gVXNlZCBmb3Igc3BsYXQgY2FsbHMuXG5cdC8vIFRPRE86RVM2IFNob3VsZG4ndCBuZWVkLiBgZnVuKC4uLmFyZylgIHNob3VsZCB3b3JrIGZvciBhbnkgaXRlcmFibGUuXG5cdGFycihfKSB7XG5cdFx0aWYgKF8gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdHJldHVybiBfXG5cdFx0Y29uc3Qgb3V0ID0gWyBdXG5cdFx0Zm9yIChsZXQgZW0gb2YgXylcblx0XHRcdG91dC5wdXNoKGVtKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRlcnJvcihlcnIpIHtcblx0XHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRyZXR1cm4gZXJyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gbmV3IEVycm9yKGVycilcblx0XHRlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBfbXMuTGF6eSlcblx0XHRcdHJldHVybiBfbXMuZXJyb3IoZXJyLmdldCgpKVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhyb3duIHZhbHVlIG11c3QgYmUgRXJyb3Igb3IgU3RyaW5nJylcblx0fSxcblxuXHQvLyBGb3IgdXNlIGJ5IE9iai1UeXBlLm1zIGdlbmVyYXRlZCBjb2RlLlxuXHRjaGVja05vRXh0cmFzKF90aGlzLCBfLCBydE5hbWUpIHtcblx0XHQvLyBJZiB0aGVyZSB3YXMgc29tZSBrZXkgaW4gYF9gIHRoYXQgd2UgZGlkbid0IGNvcHk6XG5cdFx0aWYgKE9iamVjdC5rZXlzKF8pLmxlbmd0aCA+IE9iamVjdC5rZXlzKF90aGlzKS5sZW5ndGgpXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXykpXG5cdFx0XHRcdC8vIFRPRE86RElTUExBWU5BTUVcblx0XHRcdFx0aWYgKG5hbWUgIT09ICduYW1lJylcblx0XHRcdFx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpcywgbmFtZSkpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dHJhIHByb3AgJyArIG5hbWUgKyAnIGZvciAnICsgcnROYW1lKVxuXHR9LFxuXG5cdExhenk6IGZ1bmN0aW9uIExhenkoZ2V0KSB7XG5cdFx0dGhpcy5nZXQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLmdldCA9ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBMYXp5IHZhbHVlIGRlcGVuZHMgb24gaXRzZWxmLiBUaHVuazogJHtnZXR9YClcblx0XHRcdH1cblx0XHRcdGNvbnN0IF8gPSBnZXQoKVxuXHRcdFx0dGhpcy5nZXQgPSAoKSA9PiBfXG5cdFx0XHRyZXR1cm4gX1xuXHRcdH1cblx0fSxcblx0bGF6eTogXyA9PiBuZXcgbXMuTGF6eShfKSxcblx0dW5sYXp5OiBfID0+IF8gaW5zdGFuY2VvZiBtcy5MYXp5ID8gXy5nZXQoKSA6IF8sXG5cblx0Ly8gVW5saWtlIE9iamVjdC5hc3NpZ24sIGRvZXMgKm5vdCogaW52b2tlIGdldHRlcnMuXG5cdHNldCh2YWx1ZSwgcHJvcGVydGllc09iamVjdCwgb3BOYW1lKSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllc09iamVjdClcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwga2V5LFxuXHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXNPYmplY3QsIGtleSkpXG5cdFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG5cdFx0XHRpZiAob3BOYW1lICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdG1zLnNldE5hbWUodmFsdWUsIG9wTmFtZSlcblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblx0c2V0TmFtZSh2YWx1ZSwgbmFtZSkge1xuXHRcdHZhbHVlLm5hbWUgPSBuYW1lXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cdHNldExhenkodmFsdWUsIG5hbWUsIGxhenkpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIG5hbWUsIHsgZ2V0OiBsYXp5LmdldCwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuXHR9LFxuXG5cdHN5bWJvbCh2YWx1ZSkge1xuXHRcdGNvbnN0IHN5bWJvbCA9IHZhbHVlWydpbXBsLXN5bWJvbCddXG5cdFx0cmV0dXJuIHN5bWJvbCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBzeW1ib2xcblx0fSxcblxuXHRuZXdQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAke25hbWV9IGFscmVhZHkgZXhpc3RzLmApXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlXG5cdFx0fSlcblx0fSxcblx0bmV3TXV0YWJsZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7bmFtZX0gYWxyZWFkeSBleGlzdHMuYClcblx0XHRvYmplY3QubmFtZSA9IHZhbHVlXG5cdH1cbn1cbmZvciAoY29uc3QgZGVmIGluIG1zRGVmcylcblx0bXNEZWYoZGVmLCBtc0RlZnNbZGVmXSlcblxuY29uc3QgbXNEZWZUZW1wID0gKG5hbWUsIGZ1bikgPT5cblx0bXNbbmFtZV0gPSBmdW5cblxuLy8gT3ZlcnJpZGRlbiBieSBzaG93Lm1zLlxubXNEZWZUZW1wKCdzaG93JywgXyA9PiB7XG5cdGlmICh0eXBlb2YgXyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIF8gIT09ICdudW1iZXInKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBPbmx5IHVzZSBTdHJpbmdzIG9yIE51bWJlcnMgaGVyZSB1bnRpbCB0aGlzIGlzIG92ZXJyaWRkZW4gYnkgc2hvdy5tcy4gR290OlxcbiR7X31gKVxuXHRyZXR1cm4gXy50b1N0cmluZygpXG59KVxuXG4vLyByZWdpb24gQ29udGFpbnNcbi8vIFNvbWUgVHlwZXMgd2FudCB0byBpbXBsZW1lbnQgY29udGFpbnM/IGJlZm9yZSBpdCBpcyBvZmZpY2lhbGx5IGRlZmluZWQuXG5leHBvcnQgY29uc3QgY29udGFpbnNJbXBsU3ltYm9sID0gU3ltYm9sKCdjb250YWlucz8nKVxuZXhwb3J0IGNvbnN0IGltcGxDb250YWlucyA9ICh0eXBlLCBpbXBsKSA9PlxuXHRwQWRkKHR5cGUucHJvdG90eXBlLCBjb250YWluc0ltcGxTeW1ib2wsIGltcGwpXG5cbi8vIE92ZXJ3cml0dGVuIGJ5IFR5cGUvaW5kZXgubXMgdG8gYWN0dWFsbHkgZG8gdHlwZSBjaGVja2luZy5cbm1zRGVmVGVtcCgnY2hlY2tDb250YWlucycsIChfdHlwZSwgdmFsKSA9PiB2YWwpXG5cbi8vIEFuIG9iamVjdCBpcyBhIEZ1bmN0aW9uIGlmIGl0cyB0eXBlb2YgaXMgYGZ1bmN0aW9uYC5cbi8vIFRoaXMgaGVscHMgdXMgY2F0Y2ggYW55IGNhbGxhYmUgT2JqLVR5cGUuXG4vLyBUT0RPOiBTZXBhcmF0ZSBGdW5jdGlvbiBmcm9tIENhbGxhYmxlXG4vLyBTaW5jZSB0aGVzZSBhcmUgcHJpbWl0aXZlcywgd2UgY2FuJ3QgdXNlIGBpbnN0YW5jZW9mYC5cbmZvciAoY29uc3QgdHlwZSBvZiBbIEZ1bmN0aW9uLCBCb29sZWFuLCBTdHJpbmcsIFN5bWJvbCwgTnVtYmVyIF0pIHtcblx0Ly8gR2VuZXJhdGVkIGNvZGUgaXMgZmFzdGVyIHRoYW4gdXNpbmcgYSBjbG9zdXJlLlxuXHRjb25zdCBzcmMgPSAncmV0dXJuIHR5cGVvZiBfID09PSBcIicgKyB0eXBlLm5hbWUudG9Mb3dlckNhc2UoKSArICdcIidcblx0cEFkZCh0eXBlLCBjb250YWluc0ltcGxTeW1ib2wsIEZ1bmN0aW9uKCdfJywgc3JjKSlcbn1cblxuLy8gRnVuY3Rpb25zIGFyZSBPYmplY3RzLCBzbyB3ZSBkbyB0aGlzIG9uZSBkaWZmZXJlbnRseS5cbi8vIFRPRE86IFRoaXMgdHJlYXRzIE9iamVjdC5jcmVhdGUobnVsbCkgYXMgYW4gb2JqZWN0LiBEbyB3ZSB3YW50IHRoYXQ/XG5wQWRkKE9iamVjdCwgY29udGFpbnNJbXBsU3ltYm9sLCBmdW5jdGlvbihfKSB7XG5cdGlmIChfID09PSBudWxsKVxuXHRcdHJldHVybiBmYWxzZVxuXHRzd2l0Y2ggKHR5cGVvZiBfKSB7XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOlxuXHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufSlcblxuaW1wbENvbnRhaW5zKEZ1bmN0aW9uLCBmdW5jdGlvbihfKSB7IHJldHVybiBfIGluc3RhbmNlb2YgdGhpcyB9KVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=