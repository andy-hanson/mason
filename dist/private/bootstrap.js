if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const pAdd = (object, key, value) => Object.defineProperty(object, key, {
		value,
		writable: false,
		enumerable: false,
		configurable: false
	});

	exports.pAdd = pAdd;
	// region Builtin Functions for use by the compiler
	const
	// This object contains functions called upon by compiled code.
	ms = {},
	      msDef = (name, fun) => pAdd(ms, name, fun),
	      msCall = (name, ...args) => ms[name](...args);

	exports.ms = ms;
	exports.msDef = msDef;
	exports.msCall = msCall;
	pAdd(global, '_ms', ms);

	const indent = str => str.replace(/\n/g, '\n\t');

	const msDefs = {
		// TODO: use +! method
		add(bag, value) {
			bag.push(value);
		},

		addMany(bag, values) {
			for (let value of values) ms.add(bag, value);
		},

		assert(fun, ...args) {
			if (!Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.repr).join('\n');
				throw new Error(`assert! ${ _ms.show(fun) }\n\t${ indent(showArgs) }`);
			}
		},

		assertNot(fun, ...args) {
			if (Function.prototype.apply.call(fun, null, args)) {
				const showArgs = args.map(_ms.repr).join('\n');
				throw new Error(`forbid! ${ _ms.show(fun) }\n\t${ indent(showArgs) }`);
			}
		},

		// TODO: use assoc! method
		assoc(map, key, val) {
			map.set(key, val);
		},

		lazyGetModule(module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get : ms.lazy(() => module);
		},

		getModule(module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get.get() : module;
		},

		getDefaultExport: module => {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp(lazyObject, key) {
			if (!(lazyObject instanceof ms.Lazy)) throw new Error(`Expected a Lazy, got: ${ lazyObject }`);
			return ms.lazy(() => lazyObject.get()[key]);
		},

		get(object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error(`Module ${ object.name } does not have ${ key }`);
			return _;
		},

		bool(b) {
			if (typeof b !== 'boolean') {
				console.log(b);
				throw new Error(`Expected Boolean, got ${ b }`);
			}
			return b;
		},

		// Used for splat calls.
		// TODO:ES6 Shouldn't need. `fun(...arg)` should work for any iterable.
		arr(_) {
			if (_ instanceof Array) return _;
			const out = [];
			for (let em of _) out.push(em);
			return out;
		},

		error(err) {
			if (err instanceof Error) return err;else if (typeof err === 'string') return new Error(err);else if (err instanceof _ms.Lazy) return _ms.error(err.get());else throw new Error('Thrown value must be Error or String');
		},

		// For use by Obj-Type.ms generated code.
		checkNoExtras(_this, _, rtName) {
			// If there was some key in `_` that we didn't copy:
			if (Object.keys(_).length > Object.keys(_this).length) for (const name of Object.getOwnPropertyNames(_))
			// TODO:DISPLAYNAME
			if (name !== 'name') if (!Object.prototype.hasOwnProperty.call(_this, name)) throw new Error('Extra prop ' + name + ' for ' + rtName);
		},

		Lazy: function Lazy(get) {
			this.get = () => {
				this.get = () => {
					throw new Error(`Lazy value depends on itself. Thunk: ${ get }`);
				};
				const _ = get();
				this.get = () => _;
				return _;
			};
		},
		lazy: _ => new ms.Lazy(_),
		unlazy: _ => _ instanceof ms.Lazy ? _.get() : _,

		// Unlike Object.assign, does *not* invoke getters.
		set(value, propertiesObject, opName) {
			for (const key in propertiesObject) Object.defineProperty(value, key, Object.getOwnPropertyDescriptor(propertiesObject, key));
			if (!(value instanceof Function)) if (opName !== undefined) ms.setName(value, opName);
			return value;
		},
		setName(value, name) {
			value.name = name;
			return value;
		},
		setLazy(value, name, lazy) {
			Object.defineProperty(value, name, { get: lazy.get, enumerable: true });
		}
	};
	for (const def in msDefs) msDef(def, msDefs[def]);

	const msDefTemp = (name, fun) => ms[name] = fun;

	// Overridden by show.ms.
	msDefTemp('show', _ => {
		if (typeof _ !== 'string' && typeof _ !== 'number') throw new Error(`Only use Strings or Numbers here until this is overridden by show.ms. Got:\n${ _ }`);
		return _.toString();
	});

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = 'impl-contains?';
	exports.containsImplSymbol = containsImplSymbol;
	const implContains = (type, impl) => pAdd(type.prototype, containsImplSymbol, impl);

	exports.implContains = implContains;
	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', (_type, val) => val);

	// An object is a Function if its typeof is `function`.
	// This helps us catch any callabe Obj-Type.
	// TODO: Separate Function from Callable
	// Since these are primitives, we can't use `instanceof`.
	for (const type of [Function, Boolean, String, Symbol, Number]) {
		// Generated code is faster than using a closure.
		const src = 'return typeof _ === "' + type.name.toLowerCase() + '"';
		pAdd(type, containsImplSymbol, Function('_', src));
	}

	// Functions are Objects, so we do this one differently.
	// TODO: This treats Object.create(null) as an object. Do we want that?
	pAdd(Object, containsImplSymbol, function (_) {
		if (_ === null) return false;
		switch (typeof _) {
			case 'function':
			case 'object':
				return true;
			default:
				return false;
		}
	});

	implContains(Function, function (_) {
		return _ instanceof this;
	});
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaXZhdGUvYm9vdHN0cmFwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLE9BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEtBQ3RDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUNsQyxPQUFLO0FBQ0wsVUFBUSxFQUFFLEtBQUs7QUFDZixZQUFVLEVBQUUsS0FBSztBQUNqQixjQUFZLEVBQUUsS0FBSztFQUNuQixDQUFDLENBQUE7O1NBTlUsSUFBSSxHQUFKLElBQUk7O0FBU1Y7O0FBRU4sR0FBRSxHQUFHLEVBQUc7T0FDUixLQUFLLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUNqQixJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUM7T0FDcEIsTUFBTSxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxLQUN0QixFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQTs7U0FKbEIsRUFBRSxHQUFGLEVBQUU7U0FDRixLQUFLLEdBQUwsS0FBSztTQUVMLE1BQU0sR0FBTixNQUFNO0FBR1AsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUE7O0FBRXZCLE9BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTs7QUFFaEQsT0FBTSxNQUFNLEdBQUc7O0FBRWQsS0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUU7QUFDZixNQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0dBQ2Y7O0FBRUQsU0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDcEIsUUFBSyxJQUFJLEtBQUssSUFBSSxNQUFNLEVBQ3ZCLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0dBQ25COztBQUVELFFBQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUU7QUFDcEIsT0FBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO0FBQ3BELFVBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM5QyxVQUFNLElBQUksS0FBSyxDQUFDLENBQUMsUUFBUSxHQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSxHQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtJQUNsRTtHQUNEOztBQUVELFdBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUU7QUFDdkIsT0FBSSxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRTtBQUNuRCxVQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDOUMsVUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLFFBQVEsR0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDLElBQUksR0FBRSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7SUFDbEU7R0FDRDs7O0FBR0QsT0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQ3BCLE1BQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0dBQ2pCOztBQUVELGVBQWEsQ0FBQyxNQUFNLEVBQUU7QUFDckIsT0FBSSxNQUFNLEtBQUssU0FBUyxFQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFt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Q0FBQyxJQUFJLEVBQUUsSUFBSSxLQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsQ0FBQTs7U0FEbEMsWUFBWSxHQUFaLFlBQVk7O0FBSXpCLFVBQVMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBOzs7Ozs7QUFNL0MsTUFBSyxNQUFNLElBQUksSUFBSSxDQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUUsRUFBRTs7QUFFakUsUUFBTSxHQUFHLEdBQUcsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxHQUFHLENBQUE7QUFDbkUsTUFBSSxDQUFDLElBQUksRUFBRSxrQkFBa0IsRUFBRSxRQUFRLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUE7RUFDbEQ7Ozs7QUFJRCxLQUFJLENBQUMsTUFBTSxFQUFFLGtCQUFrQixFQUFFLFVBQVMsQ0FBQyxFQUFFO0FBQzVDLE1BQUksQ0FBQyxLQUFLLElBQUksRUFDYixPQUFPLEtBQUssQ0FBQTtBQUNiLFVBQVEsT0FBTyxDQUFDO0FBQ2YsUUFBSyxVQUFVLENBQUM7QUFDaEIsUUFBSyxRQUFRO0FBQ1osV0FBTyxJQUFJLENBQUE7QUFBQSxBQUNaO0FBQ0MsV0FBTyxLQUFLLENBQUE7QUFBQSxHQUNiO0VBQ0QsQ0FBQyxDQUFBOztBQUVGLGFBQVksQ0FBQyxRQUFRLEVBQUUsVUFBUyxDQUFDLEVBQUU7QUFBRSxTQUFPLENBQUMsWUFBWSxJQUFJLENBQUE7RUFBRSxDQUFDLENBQUEiLCJmaWxlIjoicHJpdmF0ZS9ib290c3RyYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcEFkZCA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHRcdHZhbHVlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdH0pXG5cbi8vIHJlZ2lvbiBCdWlsdGluIEZ1bmN0aW9ucyBmb3IgdXNlIGJ5IHRoZSBjb21waWxlclxuZXhwb3J0IGNvbnN0XG5cdC8vIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGZ1bmN0aW9ucyBjYWxsZWQgdXBvbiBieSBjb21waWxlZCBjb2RlLlxuXHRtcyA9IHsgfSxcblx0bXNEZWYgPSAobmFtZSwgZnVuKSA9PlxuXHRcdHBBZGQobXMsIG5hbWUsIGZ1biksXG5cdG1zQ2FsbCA9IChuYW1lLCAuLi5hcmdzKSA9PlxuXHRcdG1zW25hbWVdKC4uLmFyZ3MpXG5cbnBBZGQoZ2xvYmFsLCAnX21zJywgbXMpXG5cbmNvbnN0IGluZGVudCA9IHN0ciA9PiBzdHIucmVwbGFjZSgvXFxuL2csICdcXG5cXHQnKVxuXG5jb25zdCBtc0RlZnMgPSB7XG5cdC8vIFRPRE86IHVzZSArISBtZXRob2Rcblx0YWRkKGJhZywgdmFsdWUpIHtcblx0XHRiYWcucHVzaCh2YWx1ZSlcblx0fSxcblxuXHRhZGRNYW55KGJhZywgdmFsdWVzKSB7XG5cdFx0Zm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKVxuXHRcdFx0bXMuYWRkKGJhZywgdmFsdWUpXG5cdH0sXG5cblx0YXNzZXJ0KGZ1biwgLi4uYXJncykge1xuXHRcdGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZnVuLCBudWxsLCBhcmdzKSkge1xuXHRcdFx0Y29uc3Qgc2hvd0FyZ3MgPSBhcmdzLm1hcChfbXMucmVwcikuam9pbignXFxuJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgYXNzZXJ0ISAke19tcy5zaG93KGZ1bil9XFxuXFx0JHtpbmRlbnQoc2hvd0FyZ3MpfWApXG5cdFx0fVxuXHR9LFxuXG5cdGFzc2VydE5vdChmdW4sIC4uLmFyZ3MpIHtcblx0XHRpZiAoRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZnVuLCBudWxsLCBhcmdzKSkge1xuXHRcdFx0Y29uc3Qgc2hvd0FyZ3MgPSBhcmdzLm1hcChfbXMucmVwcikuam9pbignXFxuJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZm9yYmlkISAke19tcy5zaG93KGZ1bil9XFxuXFx0JHtpbmRlbnQoc2hvd0FyZ3MpfWApXG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRPRE86IHVzZSBhc3NvYyEgbWV0aG9kXG5cdGFzc29jKG1hcCwga2V5LCB2YWwpIHtcblx0XHRtYXAuc2V0KGtleSwgdmFsKVxuXHR9LFxuXG5cdGxhenlHZXRNb2R1bGUobW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0cmV0dXJuIG1vZHVsZS5fZ2V0IGluc3RhbmNlb2YgbXMuTGF6eSA/IG1vZHVsZS5fZ2V0IDogbXMubGF6eSgoKSA9PiBtb2R1bGUpXG5cdH0sXG5cblx0Z2V0TW9kdWxlKG1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdHJldHVybiBtb2R1bGUuX2dldCBpbnN0YW5jZW9mIG1zLkxhenkgPyBtb2R1bGUuX2dldC5nZXQoKSA6IG1vZHVsZVxuXHR9LFxuXG5cdGdldERlZmF1bHRFeHBvcnQ6IG1vZHVsZSA9PiB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0Y29uc3QgbW9kID0gbXMuZ2V0TW9kdWxlKG1vZHVsZSlcblx0XHRyZXR1cm4gbW9kLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IG1vZCA6IG1vZC5kZWZhdWx0XG5cdH0sXG5cblx0bGF6eVByb3AobGF6eU9iamVjdCwga2V5KSB7XG5cdFx0aWYgKCEobGF6eU9iamVjdCBpbnN0YW5jZW9mIG1zLkxhenkpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIExhenksIGdvdDogJHtsYXp5T2JqZWN0fWApXG5cdFx0cmV0dXJuIG1zLmxhenkoKCkgPT4gbGF6eU9iamVjdC5nZXQoKVtrZXldKVxuXHR9LFxuXG5cdGdldChvYmplY3QsIGtleSkge1xuXHRcdGNvbnN0IF8gPSBvYmplY3Rba2V5XVxuXHRcdGlmIChfID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE1vZHVsZSAke29iamVjdC5uYW1lfSBkb2VzIG5vdCBoYXZlICR7a2V5fWApXG5cdFx0cmV0dXJuIF9cblx0fSxcblxuXHRib29sKGIpIHtcblx0XHRpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJykge1xuXHRcdFx0Y29uc29sZS5sb2coYilcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgQm9vbGVhbiwgZ290ICR7Yn1gKVxuXHRcdH1cblx0XHRyZXR1cm4gYlxuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIHNwbGF0IGNhbGxzLlxuXHQvLyBUT0RPOkVTNiBTaG91bGRuJ3QgbmVlZC4gYGZ1biguLi5hcmcpYCBzaG91bGQgd29yayBmb3IgYW55IGl0ZXJhYmxlLlxuXHRhcnIoXykge1xuXHRcdGlmIChfIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdGNvbnN0IG91dCA9IFsgXVxuXHRcdGZvciAobGV0IGVtIG9mIF8pXG5cdFx0XHRvdXQucHVzaChlbSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0ZXJyb3IoZXJyKSB7XG5cdFx0aWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKVxuXHRcdFx0cmV0dXJuIGVyclxuXHRcdGVsc2UgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIG5ldyBFcnJvcihlcnIpXG5cdFx0ZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgX21zLkxhenkpXG5cdFx0XHRyZXR1cm4gX21zLmVycm9yKGVyci5nZXQoKSlcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Rocm93biB2YWx1ZSBtdXN0IGJlIEVycm9yIG9yIFN0cmluZycpXG5cdH0sXG5cblx0Ly8gRm9yIHVzZSBieSBPYmotVHlwZS5tcyBnZW5lcmF0ZWQgY29kZS5cblx0Y2hlY2tOb0V4dHJhcyhfdGhpcywgXywgcnROYW1lKSB7XG5cdFx0Ly8gSWYgdGhlcmUgd2FzIHNvbWUga2V5IGluIGBfYCB0aGF0IHdlIGRpZG4ndCBjb3B5OlxuXHRcdGlmIChPYmplY3Qua2V5cyhfKS5sZW5ndGggPiBPYmplY3Qua2V5cyhfdGhpcykubGVuZ3RoKVxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKF8pKVxuXHRcdFx0XHQvLyBUT0RPOkRJU1BMQVlOQU1FXG5cdFx0XHRcdGlmIChuYW1lICE9PSAnbmFtZScpXG5cdFx0XHRcdFx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3RoaXMsIG5hbWUpKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHRyYSBwcm9wICcgKyBuYW1lICsgJyBmb3IgJyArIHJ0TmFtZSlcblx0fSxcblxuXHRMYXp5OiBmdW5jdGlvbiBMYXp5KGdldCkge1xuXHRcdHRoaXMuZ2V0ID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5nZXQgPSAoKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTGF6eSB2YWx1ZSBkZXBlbmRzIG9uIGl0c2VsZi4gVGh1bms6ICR7Z2V0fWApXG5cdFx0XHR9XG5cdFx0XHRjb25zdCBfID0gZ2V0KClcblx0XHRcdHRoaXMuZ2V0ID0gKCkgPT4gX1xuXHRcdFx0cmV0dXJuIF9cblx0XHR9XG5cdH0sXG5cdGxhenk6IF8gPT4gbmV3IG1zLkxhenkoXyksXG5cdHVubGF6eTogXyA9PiBfIGluc3RhbmNlb2YgbXMuTGF6eSA/IF8uZ2V0KCkgOiBfLFxuXG5cdC8vIFVubGlrZSBPYmplY3QuYXNzaWduLCBkb2VzICpub3QqIGludm9rZSBnZXR0ZXJzLlxuXHRzZXQodmFsdWUsIHByb3BlcnRpZXNPYmplY3QsIG9wTmFtZSkge1xuXHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXNPYmplY3QpXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIGtleSxcblx0XHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzT2JqZWN0LCBrZXkpKVxuXHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuXHRcdFx0aWYgKG9wTmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRtcy5zZXROYW1lKHZhbHVlLCBvcE5hbWUpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cdHNldE5hbWUodmFsdWUsIG5hbWUpIHtcblx0XHR2YWx1ZS5uYW1lID0gbmFtZVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXHRzZXRMYXp5KHZhbHVlLCBuYW1lLCBsYXp5KSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBuYW1lLCB7IGdldDogbGF6eS5nZXQsIGVudW1lcmFibGU6IHRydWUgfSlcblx0fVxufVxuZm9yIChjb25zdCBkZWYgaW4gbXNEZWZzKVxuXHRtc0RlZihkZWYsIG1zRGVmc1tkZWZdKVxuXG5jb25zdCBtc0RlZlRlbXAgPSAobmFtZSwgZnVuKSA9PlxuXHRtc1tuYW1lXSA9IGZ1blxuXG4vLyBPdmVycmlkZGVuIGJ5IHNob3cubXMuXG5tc0RlZlRlbXAoJ3Nob3cnLCBfID0+IHtcblx0aWYgKHR5cGVvZiBfICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgXyAhPT0gJ251bWJlcicpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0YE9ubHkgdXNlIFN0cmluZ3Mgb3IgTnVtYmVycyBoZXJlIHVudGlsIHRoaXMgaXMgb3ZlcnJpZGRlbiBieSBzaG93Lm1zLiBHb3Q6XFxuJHtffWApXG5cdHJldHVybiBfLnRvU3RyaW5nKClcbn0pXG5cbi8vIHJlZ2lvbiBDb250YWluc1xuLy8gU29tZSBUeXBlcyB3YW50IHRvIGltcGxlbWVudCBjb250YWlucz8gYmVmb3JlIGl0IGlzIG9mZmljaWFsbHkgZGVmaW5lZC5cbmV4cG9ydCBjb25zdCBjb250YWluc0ltcGxTeW1ib2wgPSAnaW1wbC1jb250YWlucz8nXG5leHBvcnQgY29uc3QgaW1wbENvbnRhaW5zID0gKHR5cGUsIGltcGwpID0+XG5cdHBBZGQodHlwZS5wcm90b3R5cGUsIGNvbnRhaW5zSW1wbFN5bWJvbCwgaW1wbClcblxuLy8gT3ZlcndyaXR0ZW4gYnkgVHlwZS9pbmRleC5tcyB0byBhY3R1YWxseSBkbyB0eXBlIGNoZWNraW5nLlxubXNEZWZUZW1wKCdjaGVja0NvbnRhaW5zJywgKF90eXBlLCB2YWwpID0+IHZhbClcblxuLy8gQW4gb2JqZWN0IGlzIGEgRnVuY3Rpb24gaWYgaXRzIHR5cGVvZiBpcyBgZnVuY3Rpb25gLlxuLy8gVGhpcyBoZWxwcyB1cyBjYXRjaCBhbnkgY2FsbGFiZSBPYmotVHlwZS5cbi8vIFRPRE86IFNlcGFyYXRlIEZ1bmN0aW9uIGZyb20gQ2FsbGFibGVcbi8vIFNpbmNlIHRoZXNlIGFyZSBwcmltaXRpdmVzLCB3ZSBjYW4ndCB1c2UgYGluc3RhbmNlb2ZgLlxuZm9yIChjb25zdCB0eXBlIG9mIFsgRnVuY3Rpb24sIEJvb2xlYW4sIFN0cmluZywgU3ltYm9sLCBOdW1iZXIgXSkge1xuXHQvLyBHZW5lcmF0ZWQgY29kZSBpcyBmYXN0ZXIgdGhhbiB1c2luZyBhIGNsb3N1cmUuXG5cdGNvbnN0IHNyYyA9ICdyZXR1cm4gdHlwZW9mIF8gPT09IFwiJyArIHR5cGUubmFtZS50b0xvd2VyQ2FzZSgpICsgJ1wiJ1xuXHRwQWRkKHR5cGUsIGNvbnRhaW5zSW1wbFN5bWJvbCwgRnVuY3Rpb24oJ18nLCBzcmMpKVxufVxuXG4vLyBGdW5jdGlvbnMgYXJlIE9iamVjdHMsIHNvIHdlIGRvIHRoaXMgb25lIGRpZmZlcmVudGx5LlxuLy8gVE9ETzogVGhpcyB0cmVhdHMgT2JqZWN0LmNyZWF0ZShudWxsKSBhcyBhbiBvYmplY3QuIERvIHdlIHdhbnQgdGhhdD9cbnBBZGQoT2JqZWN0LCBjb250YWluc0ltcGxTeW1ib2wsIGZ1bmN0aW9uKF8pIHtcblx0aWYgKF8gPT09IG51bGwpXG5cdFx0cmV0dXJuIGZhbHNlXG5cdHN3aXRjaCAodHlwZW9mIF8pIHtcblx0XHRjYXNlICdmdW5jdGlvbic6XG5cdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmYWxzZVxuXHR9XG59KVxuXG5pbXBsQ29udGFpbnMoRnVuY3Rpb24sIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIF8gaW5zdGFuY2VvZiB0aGlzIH0pXG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==