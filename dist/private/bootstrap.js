if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	const pAdd = function (object, key, value) {
		return Object.defineProperty(object, key, {
			value: value,
			enumerable: true,
			// TODO:ES6 `writable` shouldn't need to be explicit
			writable: false
		});
	};

	// region Builtin Funs for use by the compiler
	// This object contains functions called upon by compiled code.
	const ms = exports.ms = {};
	pAdd(global, '_ms', ms);

	const msDef = exports.msDef = function (name, fun) {
		return pAdd(ms, name, fun);
	};
	const msDefTemp = function (name, fun) {
		return ms[name] = fun;
	};
	exports.msCall = function (name) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return ms[name].apply(ms, args);
	};

	const msDefs = {
		lazyGetModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof Lazy ? module._get : ms.lazy(function () {
				return module;
			});
		},

		getModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof Lazy ? module._get.get() : module;
		},

		getDefaultExport: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp: function (lazyObject, key) {
			if (!(lazyObject instanceof Lazy)) throw new Error('Expected a Lazy, got: ' + lazyObject);
			return ms.lazy(function () {
				return lazyObject.get()[key];
			});
		},

		get: function (object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error('Module ' + object.displayName + ' does not have ' + key);
			return _;
		},

		bool: function (b) {
			if (typeof b !== 'boolean') throw new Error('Expected Bool, got ' + b);
			return b;
		},

		// Used for splat calls.
		// TODO:ES6 Shouldn't need fun(...arg) should work for any iterable.
		arr: function (a) {
			if (a instanceof Array) return a;
			const out = [];
			for (let em of ms.iterator(a)) out.push(em);
			return out;
		},

		// For use by Obj-Type.ms generated code.
		checkNoExtras: function (_this, _, rtName) {
			// If there was some key in `_` that we didn't copy:
			if (Object.keys(_).length > Object.keys(_this).length) Object.getOwnPropertyNames(_).forEach(function (name) {
				if (name !== 'displayName') if (!Object.prototype.hasOwnProperty.call(_this, name)) throw new Error('Extra prop ' + name + ' for ' + rtName);
			});
		},

		lazy: function (_) {
			return new Lazy(_);
		},
		unlazy: function (_) {
			return _ instanceof Lazy ? _.get() : _;
		},

		set: function (_, k0, v0, k1, v1, k2, v2, k3) {
			_[k0] = v0;
			if (k1 === undefined) return _;
			_[k1] = v1;
			if (k2 === undefined) return _;
			_[k2] = v2;
			if (k3 === undefined) return _;
			for (let i = 7; i < arguments.length; i = i + 2) _[arguments[i]] = arguments[i + 1];
			return _;
		},

		lset: function (_, k0, v0, k1, v1, k2, v2, k3) {
			setOrLazy(_, k0, v0);
			if (k1 === undefined) return _;
			setOrLazy(_, k1, v1);
			if (k2 === undefined) return _;
			setOrLazy(_, k2, v2);
			if (k3 === undefined) return _;
			for (let i = 7; i < arguments.length; i = i + 2) setOrLazy(_, arguments[i], arguments[i + 1]);
			return _;
		}
	};
	Object.keys(msDefs).forEach(function (key) {
		return msDef(key, msDefs[key]);
	});

	const setOrLazy = function (_, k, v) {
		if (v instanceof Lazy) Object.setProperty(_, k, { get: function () {
				return ms.unlazy(v);
			} });else pAdd(_, k, v);
	};

	function Lazy(get) {
		var _this = this;

		this.get = function () {
			_this.get = function () {
				throw new Error('Lazy value depends on itself. Thunk: ' + get);
			};
			const _ = get();
			_this.get = function () {
				return _;
			};
			return _;
		};
	}

	msDefTemp('show', function (_) {
		if (typeof _ !== 'string' && typeof _ !== 'number') throw new Error('Should only use Strs or Nums here until this is overridden by show.ms. Got:\n' + _);
		return _.toString();
	});

	// region Funs used by bootstrapping code
	exports.Fun = Function;
	exports.Obj = Object;
	exports.Str = String;
	exports['p+!'] = pAdd;

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = exports['contains?-impl-symbol'] = 'impl-contains?';
	exports['impl-contains?!'] = function (type, impl) {
		Object.defineProperty(type.prototype, exports['contains?-impl-symbol'], {
			value: impl,
			enumerable: false
		});
	};

	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', function (type, val) {
		return val;
	});

	Object[containsImplSymbol] = function (ignore, _) {
		if (_ == null) return false;
		switch (typeof _) {
			case 'boolean':
			case 'undefined':
			case 'number':
			case 'string':
			case 'symbol':
				return false;
			default:
				return true;
		}
	};

	// An object is a Function if its typeof is `function`.
	// This helps us catch any callabe Obj-Type.
	// TODO: Separate Fun from Callable
	// Since these are primitives, we can't use `instanceof`.
	[Function, Boolean, String, Symbol, Number].forEach(function (type) {
		const typeOf = type.name.toLowerCase();
		type[containsImplSymbol] = function (ignore, _) {
			return typeof _ === typeOf;
		};
	});
});
//# sourceMappingURL=data:application/json;base64,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QUNaLFdBQU8sS0FBSyxDQUFBO0FBQUEsQUFDYjtBQUNDLFdBQU8sSUFBSSxDQUFBO0FBQUEsR0FDWjtFQUNELENBQUM7Ozs7OztBQU1GLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBRSxDQUFDLE9BQU8sQ0FBQyxVQUFTLElBQUksRUFBRTtBQUNwRSxRQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO0FBQ3RDLE1BQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLFVBQVMsTUFBTSxFQUFFLENBQUMsRUFBRTtBQUM5QyxVQUFPLE9BQU8sQ0FBQyxLQUFLLE1BQU0sQ0FBQTtHQUMxQixDQUFBO0VBQ0QsQ0FBQyxDQUFBIiwiZmlsZSI6InByaXZhdGUvYm9vdHN0cmFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcEFkZCA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHRcdHZhbHVlLFxuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Ly8gVE9ETzpFUzYgYHdyaXRhYmxlYCBzaG91bGRuJ3QgbmVlZCB0byBiZSBleHBsaWNpdFxuXHRcdHdyaXRhYmxlOiBmYWxzZVxuXHR9KVxuXG4vLyByZWdpb24gQnVpbHRpbiBGdW5zIGZvciB1c2UgYnkgdGhlIGNvbXBpbGVyXG4vLyBUaGlzIG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgY2FsbGVkIHVwb24gYnkgY29tcGlsZWQgY29kZS5cbmNvbnN0IG1zID0gZXhwb3J0cy5tcyA9IHt9XG5wQWRkKGdsb2JhbCwgJ19tcycsIG1zKVxuXG5jb25zdCBtc0RlZiA9IGV4cG9ydHMubXNEZWYgPSAobmFtZSwgZnVuKSA9PlxuXHRwQWRkKG1zLCBuYW1lLCBmdW4pXG5jb25zdCBtc0RlZlRlbXAgPSAobmFtZSwgZnVuKSA9PlxuXHRtc1tuYW1lXSA9IGZ1blxuZXhwb3J0cy5tc0NhbGwgPSAobmFtZSwgLi4uYXJncykgPT5cblx0bXNbbmFtZV0oLi4uYXJncylcblxuXG5jb25zdCBtc0RlZnMgPSB7XG5cdGxhenlHZXRNb2R1bGUobW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0cmV0dXJuIG1vZHVsZS5fZ2V0IGluc3RhbmNlb2YgTGF6eSA/IG1vZHVsZS5fZ2V0IDogbXMubGF6eSgoKSA9PiBtb2R1bGUpXG5cdH0sXG5cblx0Z2V0TW9kdWxlKG1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdHJldHVybiBtb2R1bGUuX2dldCBpbnN0YW5jZW9mIExhenkgPyBtb2R1bGUuX2dldC5nZXQoKSA6IG1vZHVsZVxuXHR9LFxuXG5cdGdldERlZmF1bHRFeHBvcnQ6IG1vZHVsZSA9PiB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0Y29uc3QgbW9kID0gbXMuZ2V0TW9kdWxlKG1vZHVsZSlcblx0XHRyZXR1cm4gbW9kLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IG1vZCA6IG1vZC5kZWZhdWx0XG5cdH0sXG5cblx0bGF6eVByb3AobGF6eU9iamVjdCwga2V5KSB7XG5cdFx0aWYgKCEobGF6eU9iamVjdCBpbnN0YW5jZW9mIExhenkpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIExhenksIGdvdDogJHtsYXp5T2JqZWN0fWApXG5cdFx0cmV0dXJuIG1zLmxhenkoKCkgPT4gbGF6eU9iamVjdC5nZXQoKVtrZXldKVxuXHR9LFxuXG5cdGdldChvYmplY3QsIGtleSkge1xuXHRcdGNvbnN0IF8gPSBvYmplY3Rba2V5XVxuXHRcdGlmIChfID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE1vZHVsZSAke29iamVjdC5kaXNwbGF5TmFtZX0gZG9lcyBub3QgaGF2ZSAke2tleX1gKVxuXHRcdHJldHVybiBfXG5cdH0sXG5cblx0Ym9vbChiKSB7XG5cdFx0aWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEJvb2wsIGdvdCAke2J9YClcblx0XHRyZXR1cm4gYlxuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIHNwbGF0IGNhbGxzLlxuXHQvLyBUT0RPOkVTNiBTaG91bGRuJ3QgbmVlZCBmdW4oLi4uYXJnKSBzaG91bGQgd29yayBmb3IgYW55IGl0ZXJhYmxlLlxuXHRhcnIoYSkge1xuXHRcdGlmIChhIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRyZXR1cm4gYVxuXHRcdGNvbnN0IG91dCA9IFtdXG5cdFx0Zm9yIChsZXQgZW0gb2YgbXMuaXRlcmF0b3IoYSkpXG5cdFx0XHRvdXQucHVzaChlbSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0Ly8gRm9yIHVzZSBieSBPYmotVHlwZS5tcyBnZW5lcmF0ZWQgY29kZS5cblx0Y2hlY2tOb0V4dHJhcyhfdGhpcywgXywgcnROYW1lKSB7XG5cdFx0Ly8gSWYgdGhlcmUgd2FzIHNvbWUga2V5IGluIGBfYCB0aGF0IHdlIGRpZG4ndCBjb3B5OlxuXHRcdGlmIChPYmplY3Qua2V5cyhfKS5sZW5ndGggPiBPYmplY3Qua2V5cyhfdGhpcykubGVuZ3RoKVxuXHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lICE9PSAnZGlzcGxheU5hbWUnKVxuXHRcdFx0XHRcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLCBuYW1lKSlcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0cmEgcHJvcCAnICsgbmFtZSArICcgZm9yICcgKyBydE5hbWUpXG5cdFx0XHR9KVxuXHR9LFxuXG5cdGxhenk6IF8gPT4gbmV3IExhenkoXyksXG5cdHVubGF6eTogXyA9PiBfIGluc3RhbmNlb2YgTGF6eSA/IF8uZ2V0KCkgOiBfLFxuXG5cdHNldChfLCBrMCwgdjAsIGsxLCB2MSwgazIsIHYyLCBrMykge1xuXHRcdF9bazBdID0gdjBcblx0XHRpZiAoazEgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBfXG5cdFx0X1trMV0gPSB2MVxuXHRcdGlmIChrMiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIF9cblx0XHRfW2syXSA9IHYyXG5cdFx0aWYgKGszID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdGZvciAobGV0IGkgPSA3OyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSA9IGkgKyAyKVxuXHRcdFx0X1thcmd1bWVudHNbaV1dID0gYXJndW1lbnRzW2kgKyAxXVxuXHRcdHJldHVybiBfXG5cdH0sXG5cblx0bHNldChfLCBrMCwgdjAsIGsxLCB2MSwgazIsIHYyLCBrMykge1xuXHRcdHNldE9yTGF6eShfLCBrMCwgdjApXG5cdFx0aWYgKGsxID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdHNldE9yTGF6eShfLCBrMSwgdjEpXG5cdFx0aWYgKGsyID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdHNldE9yTGF6eShfLCBrMiwgdjIpXG5cdFx0aWYgKGszID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdGZvciAobGV0IGkgPSA3OyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSA9IGkgKyAyKVxuXHRcdFx0c2V0T3JMYXp5KF8sIGFyZ3VtZW50c1tpXSwgYXJndW1lbnRzW2kgKyAxXSlcblx0XHRyZXR1cm4gX1xuXHR9XG59XG5PYmplY3Qua2V5cyhtc0RlZnMpLmZvckVhY2goa2V5ID0+IG1zRGVmKGtleSwgbXNEZWZzW2tleV0pKVxuXG5jb25zdCBzZXRPckxhenkgPSAoXywgaywgdikgPT4ge1xuXHRpZiAodiBpbnN0YW5jZW9mIExhenkpXG5cdFx0T2JqZWN0LnNldFByb3BlcnR5KF8sIGssIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1zLnVubGF6eSh2KSB9IH0pXG5cdGVsc2Vcblx0XHRwQWRkKF8sIGssIHYpXG59XG5cbmZ1bmN0aW9uIExhenkoZ2V0KSB7XG5cdHRoaXMuZ2V0ID0gKCkgPT4ge1xuXHRcdHRoaXMuZ2V0ID0gKCkgPT4ge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBMYXp5IHZhbHVlIGRlcGVuZHMgb24gaXRzZWxmLiBUaHVuazogJHtnZXR9YClcblx0XHR9XG5cdFx0Y29uc3QgXyA9IGdldCgpXG5cdFx0dGhpcy5nZXQgPSAoKSA9PiBfXG5cdFx0cmV0dXJuIF9cblx0fVxufVxuXG5tc0RlZlRlbXAoJ3Nob3cnLCBfID0+IHtcblx0aWYgKHR5cGVvZiBfICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgXyAhPT0gJ251bWJlcicpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0YFNob3VsZCBvbmx5IHVzZSBTdHJzIG9yIE51bXMgaGVyZSB1bnRpbCB0aGlzIGlzIG92ZXJyaWRkZW4gYnkgc2hvdy5tcy4gR290OlxcbiR7X31gKVxuXHRyZXR1cm4gXy50b1N0cmluZygpXG59KVxuXG4vLyByZWdpb24gRnVucyB1c2VkIGJ5IGJvb3RzdHJhcHBpbmcgY29kZVxuZXhwb3J0cy5GdW4gPSBGdW5jdGlvblxuZXhwb3J0cy5PYmogPSBPYmplY3RcbmV4cG9ydHMuU3RyID0gU3RyaW5nXG5leHBvcnRzWydwKyEnXSA9IHBBZGRcblxuLy8gcmVnaW9uIENvbnRhaW5zXG4vLyBTb21lIFR5cGVzIHdhbnQgdG8gaW1wbGVtZW50IGNvbnRhaW5zPyBiZWZvcmUgaXQgaXMgb2ZmaWNpYWxseSBkZWZpbmVkLlxuY29uc3QgY29udGFpbnNJbXBsU3ltYm9sID0gZXhwb3J0c1snY29udGFpbnM/LWltcGwtc3ltYm9sJ10gPSAnaW1wbC1jb250YWlucz8nXG5leHBvcnRzWydpbXBsLWNvbnRhaW5zPyEnXSA9IGZ1bmN0aW9uKHR5cGUsIGltcGwpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUucHJvdG90eXBlLCBleHBvcnRzWydjb250YWlucz8taW1wbC1zeW1ib2wnXSwge1xuXHRcdHZhbHVlOiBpbXBsLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pXG59XG5cbi8vIE92ZXJ3cml0dGVuIGJ5IFR5cGUvaW5kZXgubXMgdG8gYWN0dWFsbHkgZG8gdHlwZSBjaGVja2luZy5cbm1zRGVmVGVtcCgnY2hlY2tDb250YWlucycsICh0eXBlLCB2YWwpID0+IHZhbClcblxuT2JqZWN0W2NvbnRhaW5zSW1wbFN5bWJvbF0gPSBmdW5jdGlvbihpZ25vcmUsIF8pIHtcblx0aWYgKF8gPT0gbnVsbClcblx0XHRyZXR1cm4gZmFsc2Vcblx0c3dpdGNoICh0eXBlb2YgXykge1xuXHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdGNhc2UgJ3VuZGVmaW5lZCc6XG5cdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdGNhc2UgJ3N5bWJvbCc6XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHRydWVcblx0fVxufTtcblxuLy8gQW4gb2JqZWN0IGlzIGEgRnVuY3Rpb24gaWYgaXRzIHR5cGVvZiBpcyBgZnVuY3Rpb25gLlxuLy8gVGhpcyBoZWxwcyB1cyBjYXRjaCBhbnkgY2FsbGFiZSBPYmotVHlwZS5cbi8vIFRPRE86IFNlcGFyYXRlIEZ1biBmcm9tIENhbGxhYmxlXG4vLyBTaW5jZSB0aGVzZSBhcmUgcHJpbWl0aXZlcywgd2UgY2FuJ3QgdXNlIGBpbnN0YW5jZW9mYC5cblsgRnVuY3Rpb24sIEJvb2xlYW4sIFN0cmluZywgU3ltYm9sLCBOdW1iZXIgXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcblx0Y29uc3QgdHlwZU9mID0gdHlwZS5uYW1lLnRvTG93ZXJDYXNlKClcblx0dHlwZVtjb250YWluc0ltcGxTeW1ib2xdID0gZnVuY3Rpb24oaWdub3JlLCBfKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBfID09PSB0eXBlT2Zcblx0fVxufSlcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9