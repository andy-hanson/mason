if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const pAdd = function (object, key, value) {
		return Object.defineProperty(object, key, {
			value: value,
			writable: false,
			enumerable: false,
			configurable: false
		});
	};

	exports.pAdd = pAdd;
	// region Builtin Functions for use by the compiler
	const
	// This object contains functions called upon by compiled code.
	ms = {},
	      msDef = function (name, fun) {
		return pAdd(ms, name, fun);
	},
	      msCall = function (name) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return ms[name].apply(ms, args);
	};

	exports.ms = ms;
	exports.msDef = msDef;
	exports.msCall = msCall;
	pAdd(global, '_ms', ms);

	const msDefs = {
		lazyGetModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get : ms.lazy(function () {
				return module;
			});
		},

		getModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get.get() : module;
		},

		getDefaultExport: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp: function (lazyObject, key) {
			if (!(lazyObject instanceof ms.Lazy)) throw new Error('Expected a Lazy, got: ' + lazyObject);
			return ms.lazy(function () {
				return lazyObject.get()[key];
			});
		},

		get: function (object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error('Module ' + object.name + ' does not have ' + key);
			return _;
		},

		bool: function (b) {
			if (typeof b !== 'boolean') throw new Error('Expected Boolean, got ' + b);
			return b;
		},

		// Used for splat calls.
		// TODO:ES6 Shouldn't need. `fun(...arg)` should work for any iterable.
		arr: function (_) {
			if (_ instanceof Array) return _;
			const out = [];
			// TODO:ES6 Shouldn't need [Symbol.iterator]()
			for (let em of _[Symbol.iterator]()) out.push(em);
			return out;
		},

		// For use by Obj-Type.ms generated code.
		checkNoExtras: function (_this, _, rtName) {
			// If there was some key in `_` that we didn't copy:
			if (Object.keys(_).length > Object.keys(_this).length) Object.getOwnPropertyNames(_).forEach(function (name) {
				// TODO:DISPLAYNAME
				if (name !== 'name') if (!Object.prototype.hasOwnProperty.call(_this, name)) throw new Error('Extra prop ' + name + ' for ' + rtName);
			});
		},

		Lazy: function Lazy(get) {
			var _this2 = this;

			this.get = function () {
				_this2.get = function () {
					throw new Error('Lazy value depends on itself. Thunk: ' + get);
				};
				const _ = get();
				_this2.get = function () {
					return _;
				};
				return _;
			};
		},
		lazy: function (_) {
			return new ms.Lazy(_);
		},
		unlazy: function (_) {
			return _ instanceof ms.Lazy ? _.get() : _;
		},

		set: function (_, k0, v0, k1, v1, k2, v2, k3) {
			const doSet = function (k, v) {
				// TODO:DISPLAYNAME
				if (!(k === 'name' && _ instanceof Function)) _[k] = v;
			};

			doSet(k0, v0);
			if (k1 === undefined) return _;
			doSet(k1, v1);
			if (k2 === undefined) return _;
			doSet(k2, v2);
			if (k3 === undefined) return _;
			for (let i = 7; i < arguments.length; i = i + 2) doSet(arguments[i], arguments[i + 1]);
			return _;
		},

		lset: function (_, k0, v0, k1, v1, k2, v2, k3) {
			setOrLazy(_, k0, v0);
			if (k1 === undefined) return _;
			setOrLazy(_, k1, v1);
			if (k2 === undefined) return _;
			setOrLazy(_, k2, v2);
			if (k3 === undefined) return _;
			for (let i = 7; i < arguments.length; i = i + 2) setOrLazy(_, arguments[i], arguments[i + 1]);
			return _;
		},

		map: function () {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			const _ = new Map();
			for (let i = 0; i < args.length; i = i + 2) _.set(args[i], args[i + 1]);
			return _;
		}
	};
	Object.keys(msDefs).forEach(function (_) {
		return msDef(_, msDefs[_]);
	});

	const setOrLazy = function (obj, key, val) {
		if (val instanceof ms.Lazy) Object.setProperty(obj, key, { get: function () {
				return ms.unlazy(val);
			} });else pAdd(obj, key, val);
	};

	const msDefTemp = function (name, fun) {
		return ms[name] = fun;
	};

	// Overridden by show.ms.
	msDefTemp('show', function (_) {
		if (typeof _ !== 'string' && typeof _ !== 'number') throw new Error('Only use Strings or Numbers here until this is overridden by show.ms. Got:\n' + _);
		return _.toString();
	});

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = 'impl-contains?';
	exports.containsImplSymbol = containsImplSymbol;
	const implContains = function (type, impl) {
		return pAdd(type.prototype, containsImplSymbol, impl);
	};

	exports.implContains = implContains;
	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', function (_type, val) {
		return val;
	});[Function, Boolean, String, Symbol, Number].forEach(function (type) {
		// Generated code is faster than using a closure.
		const src = 'return typeof _ === "' + type.name.toLowerCase() + '"';
		pAdd(type, containsImplSymbol, Function('ignore', '_', src));
	});

	// Functions are Objects, so we do this one differently.
	// TODO: This treats Object.create(null) as an object. Do we want that?
	pAdd(Object, containsImplSymbol, function (_ignore, _) {
		if (_ === null) return false;
		switch (typeof _) {
			case 'function':
			case 'object':
				return true;
			default:
				return false;
		}
	});
});

// An object is a Function if its typeof is `function`.
// This helps us catch any callabe Obj-Type.
// TODO: Separate Function from Callable
// Since these are primitives, we can't use `instanceof`.
//# sourceMappingURL=data:application/json;base64,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a0JBQWtCLEVBQUUsSUFBSSxDQUFDO0VBQUEsQ0FBQTs7U0FEbEMsWUFBWSxHQUFaLFlBQVk7O0FBSXpCLFVBQVMsQ0FBQyxlQUFlLEVBQUUsVUFBQyxLQUFLLEVBQUUsR0FBRztTQUFLLEdBQUc7RUFBQSxDQUFDLENBTTlDLEFBQUMsQ0FBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFFLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxFQUFJOztBQUUvRCxRQUFNLEdBQUcsR0FBRyx1QkFBdUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQTtBQUNuRSxNQUFJLENBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUE7RUFDNUQsQ0FBQyxDQUFBOzs7O0FBSUYsS0FBSSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxVQUFTLE9BQU8sRUFBRSxDQUFDLEVBQUU7QUFDckQsTUFBSSxDQUFDLEtBQUssSUFBSSxFQUNiLE9BQU8sS0FBSyxDQUFBO0FBQ2IsVUFBUSxPQUFPLENBQUM7QUFDZixRQUFLLFVBQVUsQ0FBQztBQUNoQixRQUFLLFFBQVE7QUFDWixXQUFPLElBQUksQ0FBQTtBQUFBLEFBQ1o7QUFDQyxXQUFPLEtBQUssQ0FBQTtBQUFBLEdBQ2I7RUFDRCxDQUFDLENBQUEiLCJmaWxlIjoicHJpdmF0ZS9ib290c3RyYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcEFkZCA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHRcdHZhbHVlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdH0pXG5cbi8vIHJlZ2lvbiBCdWlsdGluIEZ1bmN0aW9ucyBmb3IgdXNlIGJ5IHRoZSBjb21waWxlclxuZXhwb3J0IGNvbnN0XG5cdC8vIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGZ1bmN0aW9ucyBjYWxsZWQgdXBvbiBieSBjb21waWxlZCBjb2RlLlxuXHRtcyA9IHsgfSxcblx0bXNEZWYgPSAobmFtZSwgZnVuKSA9PlxuXHRcdHBBZGQobXMsIG5hbWUsIGZ1biksXG5cdG1zQ2FsbCA9IChuYW1lLCAuLi5hcmdzKSA9PlxuXHRcdG1zW25hbWVdKC4uLmFyZ3MpXG5cbnBBZGQoZ2xvYmFsLCAnX21zJywgbXMpXG5cbmNvbnN0IG1zRGVmcyA9IHtcblx0bGF6eUdldE1vZHVsZShtb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB1bmRlZmluZWQuJylcblx0XHRyZXR1cm4gbW9kdWxlLl9nZXQgaW5zdGFuY2VvZiBtcy5MYXp5ID8gbW9kdWxlLl9nZXQgOiBtcy5sYXp5KCgpID0+IG1vZHVsZSlcblx0fSxcblxuXHRnZXRNb2R1bGUobW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgdW5kZWZpbmVkLicpXG5cdFx0cmV0dXJuIG1vZHVsZS5fZ2V0IGluc3RhbmNlb2YgbXMuTGF6eSA/IG1vZHVsZS5fZ2V0LmdldCgpIDogbW9kdWxlXG5cdH0sXG5cblx0Z2V0RGVmYXVsdEV4cG9ydDogbW9kdWxlID0+IHtcblx0XHRpZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB1bmRlZmluZWQuJylcblx0XHRjb25zdCBtb2QgPSBtcy5nZXRNb2R1bGUobW9kdWxlKVxuXHRcdHJldHVybiBtb2QuZGVmYXVsdCA9PT0gdW5kZWZpbmVkID8gbW9kIDogbW9kLmRlZmF1bHRcblx0fSxcblxuXHRsYXp5UHJvcChsYXp5T2JqZWN0LCBrZXkpIHtcblx0XHRpZiAoIShsYXp5T2JqZWN0IGluc3RhbmNlb2YgbXMuTGF6eSkpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgTGF6eSwgZ290OiAke2xhenlPYmplY3R9YClcblx0XHRyZXR1cm4gbXMubGF6eSgoKSA9PiBsYXp5T2JqZWN0LmdldCgpW2tleV0pXG5cdH0sXG5cblx0Z2V0KG9iamVjdCwga2V5KSB7XG5cdFx0Y29uc3QgXyA9IG9iamVjdFtrZXldXG5cdFx0aWYgKF8gPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTW9kdWxlICR7b2JqZWN0Lm5hbWV9IGRvZXMgbm90IGhhdmUgJHtrZXl9YClcblx0XHRyZXR1cm4gX1xuXHR9LFxuXG5cdGJvb2woYikge1xuXHRcdGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBCb29sZWFuLCBnb3QgJHtifWApXG5cdFx0cmV0dXJuIGJcblx0fSxcblxuXHQvLyBVc2VkIGZvciBzcGxhdCBjYWxscy5cblx0Ly8gVE9ETzpFUzYgU2hvdWxkbid0IG5lZWQuIGBmdW4oLi4uYXJnKWAgc2hvdWxkIHdvcmsgZm9yIGFueSBpdGVyYWJsZS5cblx0YXJyKF8pIHtcblx0XHRpZiAoXyBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0cmV0dXJuIF9cblx0XHRjb25zdCBvdXQgPSBbIF1cblx0XHQvLyBUT0RPOkVTNiBTaG91bGRuJ3QgbmVlZCBbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0Zm9yIChsZXQgZW0gb2YgX1tTeW1ib2wuaXRlcmF0b3JdKCkpXG5cdFx0XHRvdXQucHVzaChlbSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0Ly8gRm9yIHVzZSBieSBPYmotVHlwZS5tcyBnZW5lcmF0ZWQgY29kZS5cblx0Y2hlY2tOb0V4dHJhcyhfdGhpcywgXywgcnROYW1lKSB7XG5cdFx0Ly8gSWYgdGhlcmUgd2FzIHNvbWUga2V5IGluIGBfYCB0aGF0IHdlIGRpZG4ndCBjb3B5OlxuXHRcdGlmIChPYmplY3Qua2V5cyhfKS5sZW5ndGggPiBPYmplY3Qua2V5cyhfdGhpcykubGVuZ3RoKVxuXHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdC8vIFRPRE86RElTUExBWU5BTUVcblx0XHRcdFx0aWYgKG5hbWUgIT09ICduYW1lJylcblx0XHRcdFx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpcywgbmFtZSkpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dHJhIHByb3AgJyArIG5hbWUgKyAnIGZvciAnICsgcnROYW1lKVxuXHRcdFx0fSlcblx0fSxcblxuXHRMYXp5OiBmdW5jdGlvbiBMYXp5KGdldCkge1xuXHRcdHRoaXMuZ2V0ID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5nZXQgPSAoKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTGF6eSB2YWx1ZSBkZXBlbmRzIG9uIGl0c2VsZi4gVGh1bms6ICR7Z2V0fWApXG5cdFx0XHR9XG5cdFx0XHRjb25zdCBfID0gZ2V0KClcblx0XHRcdHRoaXMuZ2V0ID0gKCkgPT4gX1xuXHRcdFx0cmV0dXJuIF9cblx0XHR9XG5cdH0sXG5cdGxhenk6IF8gPT4gbmV3IG1zLkxhenkoXyksXG5cdHVubGF6eTogXyA9PiBfIGluc3RhbmNlb2YgbXMuTGF6eSA/IF8uZ2V0KCkgOiBfLFxuXG5cdHNldChfLCBrMCwgdjAsIGsxLCB2MSwgazIsIHYyLCBrMykge1xuXHRcdGNvbnN0IGRvU2V0ID0gKGssIHYpID0+IHtcblx0XHRcdC8vIFRPRE86RElTUExBWU5BTUVcblx0XHRcdGlmICghKGsgPT09ICduYW1lJyAmJiBfIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuXHRcdFx0XHRfW2tdID0gdlxuXHRcdH1cblxuXHRcdGRvU2V0KGswLCB2MClcblx0XHRpZiAoazEgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBfXG5cdFx0ZG9TZXQoazEsIHYxKVxuXHRcdGlmIChrMiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIF9cblx0XHRkb1NldChrMiwgdjIpXG5cdFx0aWYgKGszID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdGZvciAobGV0IGkgPSA3OyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSA9IGkgKyAyKVxuXHRcdFx0ZG9TZXQoYXJndW1lbnRzW2ldLCBhcmd1bWVudHNbaSArIDFdKVxuXHRcdHJldHVybiBfXG5cdH0sXG5cblxuXHRsc2V0KF8sIGswLCB2MCwgazEsIHYxLCBrMiwgdjIsIGszKSB7XG5cdFx0c2V0T3JMYXp5KF8sIGswLCB2MClcblx0XHRpZiAoazEgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBfXG5cdFx0c2V0T3JMYXp5KF8sIGsxLCB2MSlcblx0XHRpZiAoazIgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBfXG5cdFx0c2V0T3JMYXp5KF8sIGsyLCB2Milcblx0XHRpZiAoazMgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBfXG5cdFx0Zm9yIChsZXQgaSA9IDc7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpID0gaSArIDIpXG5cdFx0XHRzZXRPckxhenkoXywgYXJndW1lbnRzW2ldLCBhcmd1bWVudHNbaSArIDFdKVxuXHRcdHJldHVybiBfXG5cdH0sXG5cblx0bWFwKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBfID0gbmV3IE1hcCgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSA9IGkgKyAyKVxuXHRcdFx0Xy5zZXQoYXJnc1tpXSwgYXJnc1tpICsgMV0pXG5cdFx0cmV0dXJuIF9cblx0fVxufVxuT2JqZWN0LmtleXMobXNEZWZzKS5mb3JFYWNoKF8gPT4gbXNEZWYoXywgbXNEZWZzW19dKSlcblxuY29uc3Qgc2V0T3JMYXp5ID0gKG9iaiwga2V5LCB2YWwpID0+IHtcblx0aWYgKHZhbCBpbnN0YW5jZW9mIG1zLkxhenkpXG5cdFx0T2JqZWN0LnNldFByb3BlcnR5KG9iaiwga2V5LCB7IGdldCgpIHsgcmV0dXJuIG1zLnVubGF6eSh2YWwpIH0gfSlcblx0ZWxzZVxuXHRcdHBBZGQob2JqLCBrZXksIHZhbClcbn1cblxuY29uc3QgbXNEZWZUZW1wID0gKG5hbWUsIGZ1bikgPT5cblx0bXNbbmFtZV0gPSBmdW5cblxuLy8gT3ZlcnJpZGRlbiBieSBzaG93Lm1zLlxubXNEZWZUZW1wKCdzaG93JywgXyA9PiB7XG5cdGlmICh0eXBlb2YgXyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIF8gIT09ICdudW1iZXInKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBPbmx5IHVzZSBTdHJpbmdzIG9yIE51bWJlcnMgaGVyZSB1bnRpbCB0aGlzIGlzIG92ZXJyaWRkZW4gYnkgc2hvdy5tcy4gR290OlxcbiR7X31gKVxuXHRyZXR1cm4gXy50b1N0cmluZygpXG59KVxuXG4vLyByZWdpb24gQ29udGFpbnNcbi8vIFNvbWUgVHlwZXMgd2FudCB0byBpbXBsZW1lbnQgY29udGFpbnM/IGJlZm9yZSBpdCBpcyBvZmZpY2lhbGx5IGRlZmluZWQuXG5leHBvcnQgY29uc3QgY29udGFpbnNJbXBsU3ltYm9sID0gJ2ltcGwtY29udGFpbnM/J1xuZXhwb3J0IGNvbnN0IGltcGxDb250YWlucyA9ICh0eXBlLCBpbXBsKSA9PlxuXHRwQWRkKHR5cGUucHJvdG90eXBlLCBjb250YWluc0ltcGxTeW1ib2wsIGltcGwpXG5cbi8vIE92ZXJ3cml0dGVuIGJ5IFR5cGUvaW5kZXgubXMgdG8gYWN0dWFsbHkgZG8gdHlwZSBjaGVja2luZy5cbm1zRGVmVGVtcCgnY2hlY2tDb250YWlucycsIChfdHlwZSwgdmFsKSA9PiB2YWwpXG5cbi8vIEFuIG9iamVjdCBpcyBhIEZ1bmN0aW9uIGlmIGl0cyB0eXBlb2YgaXMgYGZ1bmN0aW9uYC5cbi8vIFRoaXMgaGVscHMgdXMgY2F0Y2ggYW55IGNhbGxhYmUgT2JqLVR5cGUuXG4vLyBUT0RPOiBTZXBhcmF0ZSBGdW5jdGlvbiBmcm9tIENhbGxhYmxlXG4vLyBTaW5jZSB0aGVzZSBhcmUgcHJpbWl0aXZlcywgd2UgY2FuJ3QgdXNlIGBpbnN0YW5jZW9mYC5cbjsgWyBGdW5jdGlvbiwgQm9vbGVhbiwgU3RyaW5nLCBTeW1ib2wsIE51bWJlciBdLmZvckVhY2godHlwZSA9PiB7XG5cdC8vIEdlbmVyYXRlZCBjb2RlIGlzIGZhc3RlciB0aGFuIHVzaW5nIGEgY2xvc3VyZS5cblx0Y29uc3Qgc3JjID0gJ3JldHVybiB0eXBlb2YgXyA9PT0gXCInICsgdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgKyAnXCInXG5cdHBBZGQodHlwZSwgY29udGFpbnNJbXBsU3ltYm9sLCBGdW5jdGlvbignaWdub3JlJywgJ18nLCBzcmMpKVxufSlcblxuLy8gRnVuY3Rpb25zIGFyZSBPYmplY3RzLCBzbyB3ZSBkbyB0aGlzIG9uZSBkaWZmZXJlbnRseS5cbi8vIFRPRE86IFRoaXMgdHJlYXRzIE9iamVjdC5jcmVhdGUobnVsbCkgYXMgYW4gb2JqZWN0LiBEbyB3ZSB3YW50IHRoYXQ/XG5wQWRkKE9iamVjdCwgY29udGFpbnNJbXBsU3ltYm9sLCBmdW5jdGlvbihfaWdub3JlLCBfKSB7XG5cdGlmIChfID09PSBudWxsKVxuXHRcdHJldHVybiBmYWxzZVxuXHRzd2l0Y2ggKHR5cGVvZiBfKSB7XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOlxuXHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufSlcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9