if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const pAdd = function (object, key, value) {
		return Object.defineProperty(object, key, {
			value: value,
			writable: false,
			enumerable: false,
			configurable: false
		});
	};

	exports.pAdd = pAdd;
	// region Builtin Functions for use by the compiler
	const
	// This object contains functions called upon by compiled code.
	ms = {},
	      msDef = function (name, fun) {
		return pAdd(ms, name, fun);
	},
	      msCall = function (name) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return ms[name].apply(ms, args);
	};

	exports.ms = ms;
	exports.msDef = msDef;
	exports.msCall = msCall;
	pAdd(global, '_ms', ms);

	const msDefs = {
		// TODO: use +! method
		add: function (bag, value) {
			bag.push(value);
		},

		addMany: function (bag, values) {
			// TODO:ES6 Shouldn't need [Symbol.iterator]()
			for (let value of values[Symbol.iterator]()) ms.add(bag, value);
		},

		// TODO: use assoc! method
		assoc: function (map, key, val) {
			map.set(key, val);
		},

		lazyGetModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get : ms.lazy(function () {
				return module;
			});
		},

		getModule: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			return module._get instanceof ms.Lazy ? module._get.get() : module;
		},

		getDefaultExport: function (module) {
			if (module === undefined) throw new Error('Module undefined.');
			const mod = ms.getModule(module);
			return mod.default === undefined ? mod : mod.default;
		},

		lazyProp: function (lazyObject, key) {
			if (!(lazyObject instanceof ms.Lazy)) throw new Error('Expected a Lazy, got: ' + lazyObject);
			return ms.lazy(function () {
				return lazyObject.get()[key];
			});
		},

		get: function (object, key) {
			const _ = object[key];
			if (_ === undefined) throw new Error('Module ' + object.name + ' does not have ' + key);
			return _;
		},

		bool: function (b) {
			if (typeof b !== 'boolean') throw new Error('Expected Boolean, got ' + b);
			return b;
		},

		// Used for splat calls.
		// TODO:ES6 Shouldn't need. `fun(...arg)` should work for any iterable.
		arr: function (_) {
			if (_ instanceof Array) return _;
			const out = [];
			// TODO:ES6 Shouldn't need [Symbol.iterator]()
			for (let em of _[Symbol.iterator]()) out.push(em);
			return out;
		},

		// For use by Obj-Type.ms generated code.
		checkNoExtras: function (_this, _, rtName) {
			// If there was some key in `_` that we didn't copy:
			if (Object.keys(_).length > Object.keys(_this).length) Object.getOwnPropertyNames(_).forEach(function (name) {
				// TODO:DISPLAYNAME
				if (name !== 'name') if (!Object.prototype.hasOwnProperty.call(_this, name)) throw new Error('Extra prop ' + name + ' for ' + rtName);
			});
		},

		Lazy: function Lazy(get) {
			var _this2 = this;

			this.get = function () {
				_this2.get = function () {
					throw new Error('Lazy value depends on itself. Thunk: ' + get);
				};
				const _ = get();
				_this2.get = function () {
					return _;
				};
				return _;
			};
		},
		lazy: function (_) {
			return new ms.Lazy(_);
		},
		unlazy: function (_) {
			return _ instanceof ms.Lazy ? _.get() : _;
		},

		// Unlike Object.assign, does *not* invoke getters.
		set: function (value, propertiesObject, opName) {
			Object.keys(propertiesObject).forEach(function (key) {
				return Object.defineProperty(value, key, Object.getOwnPropertyDescriptor(propertiesObject, key));
			});
			if (!(value instanceof Function)) if (opName !== undefined) ms.setName(value, opName);
			return value;
		},
		setName: function (value, name) {
			value.name = name;
			return value;
		},
		setLazy: function (value, name, lazy) {
			Object.defineProperty(value, name, { get: lazy.get, enumerable: true });
		}
	};
	Object.keys(msDefs).forEach(function (_) {
		return msDef(_, msDefs[_]);
	});

	const msDefTemp = function (name, fun) {
		return ms[name] = fun;
	};

	// Overridden by show.ms.
	msDefTemp('show', function (_) {
		if (typeof _ !== 'string' && typeof _ !== 'number') throw new Error('Only use Strings or Numbers here until this is overridden by show.ms. Got:\n' + _);
		return _.toString();
	});

	// region Contains
	// Some Types want to implement contains? before it is officially defined.
	const containsImplSymbol = 'impl-contains?';
	exports.containsImplSymbol = containsImplSymbol;
	const implContains = function (type, impl) {
		return pAdd(type.prototype, containsImplSymbol, impl);
	};

	exports.implContains = implContains;
	// Overwritten by Type/index.ms to actually do type checking.
	msDefTemp('checkContains', function (_type, val) {
		return val;
	});[Function, Boolean, String, Symbol, Number].forEach(function (type) {
		// Generated code is faster than using a closure.
		const src = 'return typeof _ === "' + type.name.toLowerCase() + '"';
		pAdd(type, containsImplSymbol, Function('ignore', '_', src));
	});

	// Functions are Objects, so we do this one differently.
	// TODO: This treats Object.create(null) as an object. Do we want that?
	pAdd(Object, containsImplSymbol, function (_ignore, _) {
		if (_ === null) return false;
		switch (typeof _) {
			case 'function':
			case 'object':
				return true;
			default:
				return false;
		}
	});
});

// An object is a Function if its typeof is `function`.
// This helps us catch any callabe Obj-Type.
// TODO: Separate Function from Callable
// Since these are primitives, we can't use `instanceof`.
//# sourceMappingURL=data:application/json;base64,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QUFFLGtCQUFrQixFQUFFLElBQUksQ0FBQztFQUFBLENBQUE7O1NBRGxDLFlBQVksR0FBWixZQUFZOztBQUl6QixVQUFTLENBQUMsZUFBZSxFQUFFLFVBQUMsS0FBSyxFQUFFLEdBQUc7U0FBSyxHQUFHO0VBQUEsQ0FBQyxDQU05QyxBQUFDLENBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBRSxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUksRUFBSTs7QUFFL0QsUUFBTSxHQUFHLEdBQUcsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxHQUFHLENBQUE7QUFDbkUsTUFBSSxDQUFDLElBQUksRUFBRSxrQkFBa0IsRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0VBQzVELENBQUMsQ0FBQTs7OztBQUlGLEtBQUksQ0FBQyxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsVUFBUyxPQUFPLEVBQUUsQ0FBQyxFQUFFO0FBQ3JELE1BQUksQ0FBQyxLQUFLLElBQUksRUFDYixPQUFPLEtBQUssQ0FBQTtBQUNiLFVBQVEsT0FBTyxDQUFDO0FBQ2YsUUFBSyxVQUFVLENBQUM7QUFDaEIsUUFBSyxRQUFRO0FBQ1osV0FBTyxJQUFJLENBQUE7QUFBQSxBQUNaO0FBQ0MsV0FBTyxLQUFLLENBQUE7QUFBQSxHQUNiO0VBQ0QsQ0FBQyxDQUFBIiwiZmlsZSI6InByaXZhdGUvYm9vdHN0cmFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHBBZGQgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PlxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcblx0XHR2YWx1ZSxcblx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZVxuXHR9KVxuXG4vLyByZWdpb24gQnVpbHRpbiBGdW5jdGlvbnMgZm9yIHVzZSBieSB0aGUgY29tcGlsZXJcbmV4cG9ydCBjb25zdFxuXHQvLyBUaGlzIG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgY2FsbGVkIHVwb24gYnkgY29tcGlsZWQgY29kZS5cblx0bXMgPSB7IH0sXG5cdG1zRGVmID0gKG5hbWUsIGZ1bikgPT5cblx0XHRwQWRkKG1zLCBuYW1lLCBmdW4pLFxuXHRtc0NhbGwgPSAobmFtZSwgLi4uYXJncykgPT5cblx0XHRtc1tuYW1lXSguLi5hcmdzKVxuXG5wQWRkKGdsb2JhbCwgJ19tcycsIG1zKVxuXG5jb25zdCBtc0RlZnMgPSB7XG5cdC8vIFRPRE86IHVzZSArISBtZXRob2Rcblx0YWRkKGJhZywgdmFsdWUpIHtcblx0XHRiYWcucHVzaCh2YWx1ZSlcblx0fSxcblxuXHRhZGRNYW55KGJhZywgdmFsdWVzKSB7XG5cdFx0Ly8gVE9ETzpFUzYgU2hvdWxkbid0IG5lZWQgW1N5bWJvbC5pdGVyYXRvcl0oKVxuXHRcdGZvciAobGV0IHZhbHVlIG9mIHZhbHVlc1tTeW1ib2wuaXRlcmF0b3JdKCkpXG5cdFx0XHRtcy5hZGQoYmFnLCB2YWx1ZSlcblx0fSxcblxuXHQvLyBUT0RPOiB1c2UgYXNzb2MhIG1ldGhvZFxuXHRhc3NvYyhtYXAsIGtleSwgdmFsKSB7XG5cdFx0bWFwLnNldChrZXksIHZhbClcblx0fSxcblxuXHRsYXp5R2V0TW9kdWxlKG1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdHJldHVybiBtb2R1bGUuX2dldCBpbnN0YW5jZW9mIG1zLkxhenkgPyBtb2R1bGUuX2dldCA6IG1zLmxhenkoKCkgPT4gbW9kdWxlKVxuXHR9LFxuXG5cdGdldE1vZHVsZShtb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB1bmRlZmluZWQuJylcblx0XHRyZXR1cm4gbW9kdWxlLl9nZXQgaW5zdGFuY2VvZiBtcy5MYXp5ID8gbW9kdWxlLl9nZXQuZ2V0KCkgOiBtb2R1bGVcblx0fSxcblxuXHRnZXREZWZhdWx0RXhwb3J0OiBtb2R1bGUgPT4ge1xuXHRcdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTW9kdWxlIHVuZGVmaW5lZC4nKVxuXHRcdGNvbnN0IG1vZCA9IG1zLmdldE1vZHVsZShtb2R1bGUpXG5cdFx0cmV0dXJuIG1vZC5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBtb2QgOiBtb2QuZGVmYXVsdFxuXHR9LFxuXG5cdGxhenlQcm9wKGxhenlPYmplY3QsIGtleSkge1xuXHRcdGlmICghKGxhenlPYmplY3QgaW5zdGFuY2VvZiBtcy5MYXp5KSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBMYXp5LCBnb3Q6ICR7bGF6eU9iamVjdH1gKVxuXHRcdHJldHVybiBtcy5sYXp5KCgpID0+IGxhenlPYmplY3QuZ2V0KClba2V5XSlcblx0fSxcblxuXHRnZXQob2JqZWN0LCBrZXkpIHtcblx0XHRjb25zdCBfID0gb2JqZWN0W2tleV1cblx0XHRpZiAoXyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBNb2R1bGUgJHtvYmplY3QubmFtZX0gZG9lcyBub3QgaGF2ZSAke2tleX1gKVxuXHRcdHJldHVybiBfXG5cdH0sXG5cblx0Ym9vbChiKSB7XG5cdFx0aWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEJvb2xlYW4sIGdvdCAke2J9YClcblx0XHRyZXR1cm4gYlxuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIHNwbGF0IGNhbGxzLlxuXHQvLyBUT0RPOkVTNiBTaG91bGRuJ3QgbmVlZC4gYGZ1biguLi5hcmcpYCBzaG91bGQgd29yayBmb3IgYW55IGl0ZXJhYmxlLlxuXHRhcnIoXykge1xuXHRcdGlmIChfIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRyZXR1cm4gX1xuXHRcdGNvbnN0IG91dCA9IFsgXVxuXHRcdC8vIFRPRE86RVM2IFNob3VsZG4ndCBuZWVkIFtTeW1ib2wuaXRlcmF0b3JdKClcblx0XHRmb3IgKGxldCBlbSBvZiBfW1N5bWJvbC5pdGVyYXRvcl0oKSlcblx0XHRcdG91dC5wdXNoKGVtKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHQvLyBGb3IgdXNlIGJ5IE9iai1UeXBlLm1zIGdlbmVyYXRlZCBjb2RlLlxuXHRjaGVja05vRXh0cmFzKF90aGlzLCBfLCBydE5hbWUpIHtcblx0XHQvLyBJZiB0aGVyZSB3YXMgc29tZSBrZXkgaW4gYF9gIHRoYXQgd2UgZGlkbid0IGNvcHk6XG5cdFx0aWYgKE9iamVjdC5rZXlzKF8pLmxlbmd0aCA+IE9iamVjdC5rZXlzKF90aGlzKS5sZW5ndGgpXG5cdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0Ly8gVE9ETzpESVNQTEFZTkFNRVxuXHRcdFx0XHRpZiAobmFtZSAhPT0gJ25hbWUnKVxuXHRcdFx0XHRcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLCBuYW1lKSlcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0cmEgcHJvcCAnICsgbmFtZSArICcgZm9yICcgKyBydE5hbWUpXG5cdFx0XHR9KVxuXHR9LFxuXG5cdExhenk6IGZ1bmN0aW9uIExhenkoZ2V0KSB7XG5cdFx0dGhpcy5nZXQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLmdldCA9ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBMYXp5IHZhbHVlIGRlcGVuZHMgb24gaXRzZWxmLiBUaHVuazogJHtnZXR9YClcblx0XHRcdH1cblx0XHRcdGNvbnN0IF8gPSBnZXQoKVxuXHRcdFx0dGhpcy5nZXQgPSAoKSA9PiBfXG5cdFx0XHRyZXR1cm4gX1xuXHRcdH1cblx0fSxcblx0bGF6eTogXyA9PiBuZXcgbXMuTGF6eShfKSxcblx0dW5sYXp5OiBfID0+IF8gaW5zdGFuY2VvZiBtcy5MYXp5ID8gXy5nZXQoKSA6IF8sXG5cblx0Ly8gVW5saWtlIE9iamVjdC5hc3NpZ24sIGRvZXMgKm5vdCogaW52b2tlIGdldHRlcnMuXG5cdHNldCh2YWx1ZSwgcHJvcGVydGllc09iamVjdCwgb3BOYW1lKSB7XG5cdFx0T2JqZWN0LmtleXMocHJvcGVydGllc09iamVjdCkuZm9yRWFjaChrZXkgPT5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwga2V5LFxuXHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXNPYmplY3QsIGtleSkpKVxuXHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuXHRcdFx0aWYgKG9wTmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRtcy5zZXROYW1lKHZhbHVlLCBvcE5hbWUpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cdHNldE5hbWUodmFsdWUsIG5hbWUpIHtcblx0XHR2YWx1ZS5uYW1lID0gbmFtZVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXHRzZXRMYXp5KHZhbHVlLCBuYW1lLCBsYXp5KSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBuYW1lLCB7IGdldDogbGF6eS5nZXQsIGVudW1lcmFibGU6IHRydWUgfSlcblx0fVxufVxuT2JqZWN0LmtleXMobXNEZWZzKS5mb3JFYWNoKF8gPT4gbXNEZWYoXywgbXNEZWZzW19dKSlcblxuY29uc3QgbXNEZWZUZW1wID0gKG5hbWUsIGZ1bikgPT5cblx0bXNbbmFtZV0gPSBmdW5cblxuLy8gT3ZlcnJpZGRlbiBieSBzaG93Lm1zLlxubXNEZWZUZW1wKCdzaG93JywgXyA9PiB7XG5cdGlmICh0eXBlb2YgXyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIF8gIT09ICdudW1iZXInKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBPbmx5IHVzZSBTdHJpbmdzIG9yIE51bWJlcnMgaGVyZSB1bnRpbCB0aGlzIGlzIG92ZXJyaWRkZW4gYnkgc2hvdy5tcy4gR290OlxcbiR7X31gKVxuXHRyZXR1cm4gXy50b1N0cmluZygpXG59KVxuXG4vLyByZWdpb24gQ29udGFpbnNcbi8vIFNvbWUgVHlwZXMgd2FudCB0byBpbXBsZW1lbnQgY29udGFpbnM/IGJlZm9yZSBpdCBpcyBvZmZpY2lhbGx5IGRlZmluZWQuXG5leHBvcnQgY29uc3QgY29udGFpbnNJbXBsU3ltYm9sID0gJ2ltcGwtY29udGFpbnM/J1xuZXhwb3J0IGNvbnN0IGltcGxDb250YWlucyA9ICh0eXBlLCBpbXBsKSA9PlxuXHRwQWRkKHR5cGUucHJvdG90eXBlLCBjb250YWluc0ltcGxTeW1ib2wsIGltcGwpXG5cbi8vIE92ZXJ3cml0dGVuIGJ5IFR5cGUvaW5kZXgubXMgdG8gYWN0dWFsbHkgZG8gdHlwZSBjaGVja2luZy5cbm1zRGVmVGVtcCgnY2hlY2tDb250YWlucycsIChfdHlwZSwgdmFsKSA9PiB2YWwpXG5cbi8vIEFuIG9iamVjdCBpcyBhIEZ1bmN0aW9uIGlmIGl0cyB0eXBlb2YgaXMgYGZ1bmN0aW9uYC5cbi8vIFRoaXMgaGVscHMgdXMgY2F0Y2ggYW55IGNhbGxhYmUgT2JqLVR5cGUuXG4vLyBUT0RPOiBTZXBhcmF0ZSBGdW5jdGlvbiBmcm9tIENhbGxhYmxlXG4vLyBTaW5jZSB0aGVzZSBhcmUgcHJpbWl0aXZlcywgd2UgY2FuJ3QgdXNlIGBpbnN0YW5jZW9mYC5cbjsgWyBGdW5jdGlvbiwgQm9vbGVhbiwgU3RyaW5nLCBTeW1ib2wsIE51bWJlciBdLmZvckVhY2godHlwZSA9PiB7XG5cdC8vIEdlbmVyYXRlZCBjb2RlIGlzIGZhc3RlciB0aGFuIHVzaW5nIGEgY2xvc3VyZS5cblx0Y29uc3Qgc3JjID0gJ3JldHVybiB0eXBlb2YgXyA9PT0gXCInICsgdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgKyAnXCInXG5cdHBBZGQodHlwZSwgY29udGFpbnNJbXBsU3ltYm9sLCBGdW5jdGlvbignaWdub3JlJywgJ18nLCBzcmMpKVxufSlcblxuLy8gRnVuY3Rpb25zIGFyZSBPYmplY3RzLCBzbyB3ZSBkbyB0aGlzIG9uZSBkaWZmZXJlbnRseS5cbi8vIFRPRE86IFRoaXMgdHJlYXRzIE9iamVjdC5jcmVhdGUobnVsbCkgYXMgYW4gb2JqZWN0LiBEbyB3ZSB3YW50IHRoYXQ/XG5wQWRkKE9iamVjdCwgY29udGFpbnNJbXBsU3ltYm9sLCBmdW5jdGlvbihfaWdub3JlLCBfKSB7XG5cdGlmIChfID09PSBudWxsKVxuXHRcdHJldHVybiBmYWxzZVxuXHRzd2l0Y2ggKHR5cGVvZiBfKSB7XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOlxuXHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufSlcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9