{"version":3,"sources":["meta/compile/node-only/list-modules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;kBAae,UAAC,OAAO,EAAE,IAAI;SAC5B,IAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAA,KAAK,EAAI;AAClC,SAAM,GAAG,GAAG,KAAK,CAAA;AACjB,SAAM,WAAW,GAAG,aARb,OAAO,CAQc,KAAK,EAAE,UAAA,CAAC,EAAI;AACvC,QAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EACnB,OAAO,EAAE,CAAA;AACV,QAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EACvC,OAAO,EAAE,CAAA;AACV,UAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAA;AAC/C,WAAO,QAAO,MApBR,QAAQ,CAoBS,OAAO,EAAE,KAAK,CAAC,CAAI,CAAA;IAC1C,CAAC,CAAC,IAAI,EAAE,CAAA;;AAET,SAAM,GAAG,GAAG,cAzBL,aAAa,eAAE,QAAQ,CAyBK,CAAA;AACnC,SAAM,GAAG,GAAG,YAvBc,UAAU,CAuBb,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,UAAA,CAAC;WAAI,YAvBjC,QAAQ,CAuBkC,GAAG,EAAE,CAAC,EAAE,MAAM,CAAC;IAAA,CAAC,CAAC,CAAA;AAC3E,SAAM,CAAC,GAAG,YAxB4B,MAAM,CAwB3B,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,YAxB3B,OAAO,CAwB4B,GAAG,EAAE,CAAE,YAxBH,mBAAmB,CAwBI,GAAG,EAAE,GAAG,CAAC,CAAE,CAAC,CAAC,CAAA;;AAElF,SAAM,EAAE,GAAG,QAAO,aAxBX,cAAc,CAwBY;AAChC,oBAAgB,EAAE,KAAK;AACvB,4BAAwB,EAAE,KAAK;IAC/B,CAAC,CAAC,CAAA;AACH,SAAM,GAAG,GAAG,WAAU,EAAE,EAAE,CAAC,EAAE,WAxBtB,OAAO,EAwBwB,CAAC,CAAA;AACvC,UAAO,QAAO,EAAE,EAAE,GAAG,CAAC,CAAA;GACtB,CAAC;EAAA","file":"meta/compile/node-only/list-modules.js","sourcesContent":["import { singleCharLoc, StartPos } from 'esast/dist/Loc'\nimport fs from 'q-io/fs'\nimport { relative } from 'path'\nimport { BlockDo, ELiteral, ListSimple, Module, ModuleDefaultExport } from '../Expression'\nimport Cx from '../private/Cx'\nimport { OptsFromObject } from '../private/Opts'\nimport transpile from '../private/transpile/transpile'\nimport render from '../private/render'\nimport { flatMap } from '../private/U/Bag'\nimport { emptyVr } from '../private/Vr'\n\n// Searches a directory and creates a module whose default export is\n// a list of the paths of every module in that directory, relative to it.\nexport default (dirPath, opts) =>\n\tfs.listTree(dirPath).then(files => {\n\t\tconst ext = '.js'\n\t\tconst moduleFiles = flatMap(files, f => {\n\t\t\tif (!f.endsWith(ext))\n\t\t\t\treturn []\n\t\t\tif (opts.exclude && opts.exclude.test(f))\n\t\t\t\treturn []\n\t\t\tconst noExt = f.slice(0, f.length - ext.length)\n\t\t\treturn [ `./${relative(dirPath, noExt)}` ]\n\t\t}).sort()\n\t\t// Dummy Loc. We will not use source maps.\n\t\tconst loc = singleCharLoc(StartPos)\n\t\tconst val = ListSimple(loc, moduleFiles.map(f => ELiteral(loc, f, String)))\n\t\tconst e = Module(loc, [], [], [], BlockDo(loc, [ ModuleDefaultExport(loc, val) ]))\n\n\t\tconst cx = new Cx(OptsFromObject({\n\t\t\tincludeSourceMap: false,\n\t\t\tincludeModuleDisplayName: false\n\t\t}))\n\t\tconst ast = transpile(cx, e, emptyVr())\n\t\treturn render(cx, ast)\n\t})\n"],"sourceRoot":"/src"}