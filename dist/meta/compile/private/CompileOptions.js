if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', './util'], function (exports, module, _util) {
	'use strict';

	/*
 Opts object
 mandatory:
 	inFile: String
 		path to input file.
 		Optional if not includeSourceMap.
 
 optional:
 	checks: Boolean
 		Whether to include assertions.
 		Call also be { use, type, inout, case } for specific types of assertions.
 	includeSourceMap: Boolean
 	useStrict: Boolean
 */

	class CompileOptions {
		constructor(opts) {
			// TODO:ES6 Optional arguments
			if (opts === undefined) opts = {};
			(0, _util.type)(opts, Object);

			const defaultTo = (name, _default) => {
				const _ = opts[name];
				if (_ === undefined) return _default;else {
					(0, _util.type)(_, _default.constructor);
					return _;
				}
			};

			const define = (name, _default) => {
				this[`_${ name }`] = defaultTo(name, _default);
			};

			const defaults = {
				includeAmdefine: true,
				includeSourceMap: true,
				includeModuleName: true,
				forceNonLazyModule: false,
				useStrict: true
			};

			for (const _ in defaults) define(_, defaults[_]);

			this._inFile = opts.inFile;
			if (this._inFile === undefined) {
				if (this._includeSourceMap) throw new Error('Either supply `inFile` option or make `includeSourceMap` false.');
				if (this._includeModuleName) throw new Error('Either supply `inFile` option or make `includeModuleName` false.');
			}

			let checks = opts.checks;
			if (checks === undefined) checks = true;
			const checkSubs = ['use', 'type', 'inout', 'case'];
			this._check = {};
			if (typeof checks === 'boolean') for (const _ of checkSubs) this._check[_] = checks;else {
				(0, _util.type)(checks, Object);
				for (const _ of checkSubs) {
					(0, _util.type)(checks[_], Boolean);
					this._check[_] = checks[_];
				}
			}
		}

		moduleName() {
			return noExt(basename(this._inFile));
		}
		jsBaseName() {
			return `${ this.moduleName() }.js`;
		}
		modulePath() {
			return this._inFile;
		}

		includeUseChecks() {
			return this._check.use;
		}
		includeTypeChecks() {
			return this._check.type;
		}
		includeInoutChecks() {
			return this._check.inout;
		}
		includeCaseChecks() {
			return this._check.case;
		}

		includeAmdefine() {
			return this._includeAmdefine;
		}
		includeSourceMap() {
			return this._includeSourceMap;
		}
		includeModuleName() {
			return this._includeModuleName;
		}
		includeUseStrict() {
			return this._useStrict;
		}

		lazyModule() {
			return !this._forceNonLazyModule;
		}
	}

	module.exports = CompileOptions;

	const basename = path => (0, _util.last)(path.split('/')),
	      extname = path => (0, _util.last)(path.split('.')),
	      noExt = path =>
	// - 1 for the '.'
	path.substring(0, path.length - 1 - extname(path).length);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL0NvbXBpbGVPcHRpb25zLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCZSxPQUFNLGNBQWMsQ0FBQztBQUNuQyxhQUFXLENBQUMsSUFBSSxFQUFFOztBQUVqQixPQUFJLElBQUksS0FBSyxTQUFTLEVBQUUsSUFBSSxHQUFHLEVBQUcsQ0FBQTtBQUNsQyxhQXBCYSxJQUFJLEVBb0JaLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQTs7QUFFbEIsU0FBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxLQUFLO0FBQ3JDLFVBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUNwQixRQUFJLENBQUMsS0FBSyxTQUFTLEVBQ2xCLE9BQU8sUUFBUSxDQUFBLEtBQ1g7QUFDSixlQTNCVyxJQUFJLEVBMkJWLENBQUMsRUFBRSxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUE7QUFDN0IsWUFBTyxDQUFDLENBQUE7S0FDUjtJQUNELENBQUE7O0FBRUQsU0FBTSxNQUFNLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxLQUFLO0FBQ2xDLFFBQUksQ0FBQyxDQUFDLENBQUMsR0FBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUM1QyxDQUFBOztBQUVELFNBQU0sUUFBUSxHQUFHO0FBQ2hCLG1CQUFlLEVBQUUsSUFBSTtBQUNyQixvQkFBZ0IsRUFBRSxJQUFJO0FBQ3RCLHFCQUFpQixFQUFFLElBQUk7QUFDdkIsc0JBQWtCLEVBQUUsS0FBSztBQUN6QixhQUFTLEVBQUUsSUFBSTtJQUNmLENBQUE7O0FBRUQsUUFBSyxNQUFNLENBQUMsSUFBSSxRQUFRLEVBQ3ZCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7O0FBRXZCLE9BQUksQ0FBQyxPQUFPLEdBQUcsSUFB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Q0FBQSIsImZpbGUiOiJtZXRhL2NvbXBpbGUvcHJpdmF0ZS9Db21waWxlT3B0aW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxhc3QsIHR5cGUgfSBmcm9tICcuL3V0aWwnXG5cbi8qXG5PcHRzIG9iamVjdFxubWFuZGF0b3J5OlxuXHRpbkZpbGU6IFN0cmluZ1xuXHRcdHBhdGggdG8gaW5wdXQgZmlsZS5cblx0XHRPcHRpb25hbCBpZiBub3QgaW5jbHVkZVNvdXJjZU1hcC5cblxub3B0aW9uYWw6XG5cdGNoZWNrczogQm9vbGVhblxuXHRcdFdoZXRoZXIgdG8gaW5jbHVkZSBhc3NlcnRpb25zLlxuXHRcdENhbGwgYWxzbyBiZSB7IHVzZSwgdHlwZSwgaW5vdXQsIGNhc2UgfSBmb3Igc3BlY2lmaWMgdHlwZXMgb2YgYXNzZXJ0aW9ucy5cblx0aW5jbHVkZVNvdXJjZU1hcDogQm9vbGVhblxuXHR1c2VTdHJpY3Q6IEJvb2xlYW5cbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlT3B0aW9ucyB7XG5cdGNvbnN0cnVjdG9yKG9wdHMpIHtcblx0XHQvLyBUT0RPOkVTNiBPcHRpb25hbCBhcmd1bWVudHNcblx0XHRpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSBvcHRzID0geyB9XG5cdFx0dHlwZShvcHRzLCBPYmplY3QpXG5cblx0XHRjb25zdCBkZWZhdWx0VG8gPSAobmFtZSwgX2RlZmF1bHQpID0+IHtcblx0XHRcdGNvbnN0IF8gPSBvcHRzW25hbWVdXG5cdFx0XHRpZiAoXyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gX2RlZmF1bHRcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0eXBlKF8sIF9kZWZhdWx0LmNvbnN0cnVjdG9yKVxuXHRcdFx0XHRyZXR1cm4gX1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGRlZmluZSA9IChuYW1lLCBfZGVmYXVsdCkgPT4ge1xuXHRcdFx0dGhpc1tgXyR7bmFtZX1gXSA9IGRlZmF1bHRUbyhuYW1lLCBfZGVmYXVsdClcblx0XHR9XG5cblx0XHRjb25zdCBkZWZhdWx0cyA9IHtcblx0XHRcdGluY2x1ZGVBbWRlZmluZTogdHJ1ZSxcblx0XHRcdGluY2x1ZGVTb3VyY2VNYXA6IHRydWUsXG5cdFx0XHRpbmNsdWRlTW9kdWxlTmFtZTogdHJ1ZSxcblx0XHRcdGZvcmNlTm9uTGF6eU1vZHVsZTogZmFsc2UsXG5cdFx0XHR1c2VTdHJpY3Q6IHRydWVcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IF8gaW4gZGVmYXVsdHMpXG5cdFx0XHRkZWZpbmUoXywgZGVmYXVsdHNbX10pXG5cblx0XHR0aGlzLl9pbkZpbGUgPSBvcHRzLmluRmlsZVxuXHRcdGlmICh0aGlzLl9pbkZpbGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKHRoaXMuX2luY2x1ZGVTb3VyY2VNYXApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWl0aGVyIHN1cHBseSBgaW5GaWxlYCBvcHRpb24gb3IgbWFrZSBgaW5jbHVkZVNvdXJjZU1hcGAgZmFsc2UuJylcblx0XHRcdGlmICh0aGlzLl9pbmNsdWRlTW9kdWxlTmFtZSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgc3VwcGx5IGBpbkZpbGVgIG9wdGlvbiBvciBtYWtlIGBpbmNsdWRlTW9kdWxlTmFtZWAgZmFsc2UuJylcblx0XHR9XG5cblx0XHRsZXQgY2hlY2tzID0gb3B0cy5jaGVja3Ncblx0XHRpZiAoY2hlY2tzID09PSB1bmRlZmluZWQpXG5cdFx0XHRjaGVja3MgPSB0cnVlXG5cdFx0Y29uc3QgY2hlY2tTdWJzID0gWyAndXNlJywgJ3R5cGUnLCAnaW5vdXQnLCAnY2FzZScgXVxuXHRcdHRoaXMuX2NoZWNrID0geyB9XG5cdFx0aWYgKHR5cGVvZiBjaGVja3MgPT09ICdib29sZWFuJylcblx0XHRcdGZvciAoY29uc3QgXyBvZiBjaGVja1N1YnMpXG5cdFx0XHRcdHRoaXMuX2NoZWNrW19dID0gY2hlY2tzXG5cdFx0ZWxzZSB7XG5cdFx0XHR0eXBlKGNoZWNrcywgT2JqZWN0KVxuXHRcdFx0Zm9yIChjb25zdCBfIG9mIGNoZWNrU3Vicykge1xuXHRcdFx0XHR0eXBlKGNoZWNrc1tfXSwgQm9vbGVhbilcblx0XHRcdFx0dGhpcy5fY2hlY2tbX10gPSBjaGVja3NbX11cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRtb2R1bGVOYW1lKCkgeyByZXR1cm4gbm9FeHQoYmFzZW5hbWUodGhpcy5faW5GaWxlKSkgfVxuXHRqc0Jhc2VOYW1lKCkgeyByZXR1cm4gYCR7dGhpcy5tb2R1bGVOYW1lKCl9LmpzYCB9XG5cdG1vZHVsZVBhdGgoKSB7IHJldHVybiB0aGlzLl9pbkZpbGUgfVxuXG5cdGluY2x1ZGVVc2VDaGVja3MoKSB7IHJldHVybiB0aGlzLl9jaGVjay51c2UgfVxuXHRpbmNsdWRlVHlwZUNoZWNrcygpIHsgcmV0dXJuIHRoaXMuX2NoZWNrLnR5cGUgfVxuXHRpbmNsdWRlSW5vdXRDaGVja3MoKSB7IHJldHVybiB0aGlzLl9jaGVjay5pbm91dCB9XG5cdGluY2x1ZGVDYXNlQ2hlY2tzKCkgeyByZXR1cm4gdGhpcy5fY2hlY2suY2FzZSB9XG5cblx0aW5jbHVkZUFtZGVmaW5lKCkgeyByZXR1cm4gdGhpcy5faW5jbHVkZUFtZGVmaW5lIH1cblx0aW5jbHVkZVNvdXJjZU1hcCgpIHsgcmV0dXJuIHRoaXMuX2luY2x1ZGVTb3VyY2VNYXAgfVxuXHRpbmNsdWRlTW9kdWxlTmFtZSgpIHsgcmV0dXJuIHRoaXMuX2luY2x1ZGVNb2R1bGVOYW1lIH1cblx0aW5jbHVkZVVzZVN0cmljdCgpIHsgcmV0dXJuIHRoaXMuX3VzZVN0cmljdCB9XG5cblx0bGF6eU1vZHVsZSgpIHsgcmV0dXJuICF0aGlzLl9mb3JjZU5vbkxhenlNb2R1bGUgfVxufVxuXG5jb25zdFxuXHRiYXNlbmFtZSA9IHBhdGggPT5cblx0XHRsYXN0KHBhdGguc3BsaXQoJy8nKSksXG5cdGV4dG5hbWUgPSBwYXRoID0+XG5cdFx0bGFzdChwYXRoLnNwbGl0KCcuJykpLFxuXHRub0V4dCA9IHBhdGggPT5cblx0XHQvLyAtIDEgZm9yIHRoZSAnLidcblx0XHRwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEgLSBleHRuYW1lKHBhdGgpLmxlbmd0aClcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9