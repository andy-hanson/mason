if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', 'esast/dist/mangle-identifier', 'esast/dist/specialize', '../util', './ms-call', './transpile'], function (exports, _esastDistAst, _esastDistUtil, _esastDistMangleIdentifier, _esastDistSpecialize, _util, _msCall, _transpile) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mangleIdentifier = _interopRequireDefault(_esastDistMangleIdentifier);

	var _specialize = _interopRequireDefault(_esastDistSpecialize);

	// Define this here to avoid circular dependency with ast-constants.
	const _IdError = (0, _esastDistAst.Identifier)('Error');

	exports._IdError = _IdError;
	const accessLocalDeclare = localDeclare => localDeclare.isLazy() ? (0, _msCall.msUnlazy)(idForDeclareCached(localDeclare)) : (0, _esastDistAst.Identifier)(idForDeclareCached(localDeclare).name),
	      declare = (localDeclare, val) => (0, _esastDistSpecialize.variableDeclarationConst)([(0, _esastDistAst.VariableDeclarator)(idForDeclareCached(localDeclare), val)]),
	      forStatementInfinite = (0, _specialize.default)(_esastDistAst.ForStatement, ['body', _esastDistAst.Statement], { init: null, test: null, update: null }),
	      idForDeclareCached = localDeclare => {
		let _ = declareToId.get(localDeclare);
		if (_ === undefined) {
			_ = (0, _esastDistAst.Identifier)((0, _mangleIdentifier.default)(localDeclare.name));
			declareToId.set(localDeclare, _);
		}
		return _;
	},
	      opTypeCheckForLocalDeclare = localDeclare =>
	// TODO: Way to typecheck lazies
	(0, _util.opIf)(!localDeclare.isLazy(), () => (0, _util.opMap)(localDeclare.opType, type => (0, _esastDistAst.ExpressionStatement)((0, _msCall.msCheckContains)((0, _transpile.t0)(type), accessLocalDeclare(localDeclare), (0, _esastDistAst.Literal)(localDeclare.name))))),
	      throwErrorFromString = msg => (0, _esastDistAst.ThrowStatement)((0, _esastDistAst.NewExpression)(_IdError, [(0, _esastDistAst.Literal)(msg)])),
	      templateElementForString = str => (0, _esastDistAst.TemplateElement)(false, { cooked: str, raw: (0, _esastDistUtil.escapeStringForTemplate)(str) });

	exports.accessLocalDeclare = accessLocalDeclare;
	exports.declare = declare;
	exports.forStatementInfinite = forStatementInfinite;
	exports.idForDeclareCached = idForDeclareCached;
	exports.opTypeCheckForLocalDeclare = opTypeCheckForLocalDeclare;
	exports.throwErrorFromString = throwErrorFromString;
	exports.templateElementForString = templateElementForString;
	const declareToId = new WeakMap();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBVU8sT0FBTSxRQUFRLEdBQUcsa0JBVm9CLFVBQVUsRUFVbkIsT0FBTyxDQUFDLENBQUE7O1NBQTlCLFFBQVEsR0FBUixRQUFRO0FBRWQsT0FDTixrQkFBa0IsR0FBRyxZQUFZLElBQ2hDLFlBQVksQ0FBQyxNQUFNLEVBQUUsR0FDcEIsWUFUdUIsUUFBUSxFQVN0QixrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUMxQyxrQkFoQnlDLFVBQVUsRUFnQnhDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQztPQUVuRCxPQUFPLEdBQUcsQ0FBQyxZQUFZLEVBQUUsR0FBRyxLQUMzQix5QkFmbUIsd0JBQXdCLEVBZWxCLENBQUUsa0JBbEJLLGtCQUFrQixFQWtCSixrQkFBa0IsQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBRSxDQUFDO09BRXhGLG9CQUFvQixHQUFHLHVDQXJCTSxZQUFZLEVBc0J4QyxDQUFFLE1BQU0sZ0JBdEJzRSxTQUFTLENBc0JsRSxFQUNyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7T0FFMUMsa0JBQWtCLEdBQUcsWUFBWSxJQUFJO0FBQ3BDLE1BQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUE7QUFDckMsTUFBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ3BCLElBQUMsR0FBRyxrQkE1QnFDLFVBQVUsRUE0QnBDLCtCQUFpQixZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQUNuRCxjQUFXLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQTtHQUNoQztBQUNELFNBQU8sQ0FBQyxDQUFBO0VBQ1I7T0FFRCwwQkFBMEIsR0FBRyxZQUFZOztBQUV4QyxXQS9CTyxJQUFJLEVBK0JOLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQzVCLFVBaENZLEtBQUssRUFnQ1gsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLElBQzlCLGtCQXRDSyxtQkFBbUIsRUFzQ0osWUFoQ2YsZUFBZSxFQWlDbkIsZUFoQ0ksRUFBRSxFQWdDSCxJQUFJLENBQUMsRUFDUixrQkFBa0IsQ0FBQyxZQUFZLENBQUMsRUFDaEMsa0JBekNtRCxPQUFPLEVBeUNsRCxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FFbEMsb0JBQW9CLEdBQUcsR0FBRyxJQUN6QixrQkEzQ2dCLGNBQWMsRUEyQ2Ysa0JBNUNnRCxhQUFhLEVBNEMvQyxRQUFRLEVBQUUsQ0FBRSxrQkE1Q2EsT0FBTyxFQTRDWixHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7T0FFMUQsd0JBQXdCLEdBQUcsR0FBRyxJQUM3QixrQkE5Q0QsZUFBZSxFQThDRSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxtQkE3Q3BDLHVCQUF1QixFQTZDcUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFBOztTQWxDM0Usa0JBQWtCLEdBQWxCLGtCQUFrQjtTQUtsQixPQUFPLEdBQVAsT0FBTztTQUdQLG9CQUFvQixHQUFwQixvQkFBb0I7U0FJcEIsa0JBQWtCLEdBQWxCLGtCQUFrQjtTQVNsQiwwQkFBMEIsR0FBMUIsMEJBQTBCO1NBUzFCLG9CQUFvQixHQUFwQixvQkFBb0I7U0FHcEIsd0JBQXdCLEdBQXhCLHdCQUF3QjtBQUd6QixPQUNDLFdBQVcsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFBIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXhwcmVzc2lvblN0YXRlbWVudCwgRm9yU3RhdGVtZW50LCBJZGVudGlmaWVyLCBMaXRlcmFsLCBOZXdFeHByZXNzaW9uLCBTdGF0ZW1lbnQsXG5cdFRlbXBsYXRlRWxlbWVudCwgVGhyb3dTdGF0ZW1lbnQsIFZhcmlhYmxlRGVjbGFyYXRvciB9IGZyb20gJ2VzYXN0L2Rpc3QvYXN0J1xuaW1wb3J0IHsgZXNjYXBlU3RyaW5nRm9yVGVtcGxhdGUgfSBmcm9tICdlc2FzdC9kaXN0L3V0aWwnXG5pbXBvcnQgbWFuZ2xlSWRlbnRpZmllciBmcm9tICdlc2FzdC9kaXN0L21hbmdsZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHNwZWNpYWxpemUsIHsgdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0IH0gZnJvbSAnZXNhc3QvZGlzdC9zcGVjaWFsaXplJ1xuaW1wb3J0IHsgb3BJZiwgb3BNYXAgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHsgbXNDaGVja0NvbnRhaW5zLCBtc1VubGF6eSB9IGZyb20gJy4vbXMtY2FsbCdcbmltcG9ydCB7IHQwIH0gZnJvbSAnLi90cmFuc3BpbGUnXG5cbi8vIERlZmluZSB0aGlzIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIGFzdC1jb25zdGFudHMuXG5leHBvcnQgY29uc3QgX0lkRXJyb3IgPSBJZGVudGlmaWVyKCdFcnJvcicpXG5cbmV4cG9ydCBjb25zdFxuXHRhY2Nlc3NMb2NhbERlY2xhcmUgPSBsb2NhbERlY2xhcmUgPT5cblx0XHRsb2NhbERlY2xhcmUuaXNMYXp5KCkgP1xuXHRcdFx0bXNVbmxhenkoaWRGb3JEZWNsYXJlQ2FjaGVkKGxvY2FsRGVjbGFyZSkpIDpcblx0XHRcdElkZW50aWZpZXIoaWRGb3JEZWNsYXJlQ2FjaGVkKGxvY2FsRGVjbGFyZSkubmFtZSksXG5cblx0ZGVjbGFyZSA9IChsb2NhbERlY2xhcmUsIHZhbCkgPT5cblx0XHR2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QoWyBWYXJpYWJsZURlY2xhcmF0b3IoaWRGb3JEZWNsYXJlQ2FjaGVkKGxvY2FsRGVjbGFyZSksIHZhbCkgXSksXG5cblx0Zm9yU3RhdGVtZW50SW5maW5pdGUgPSBzcGVjaWFsaXplKEZvclN0YXRlbWVudCxcblx0XHRbICdib2R5JywgU3RhdGVtZW50IF0sXG5cdFx0eyBpbml0OiBudWxsLCB0ZXN0OiBudWxsLCB1cGRhdGU6IG51bGwgfSksXG5cblx0aWRGb3JEZWNsYXJlQ2FjaGVkID0gbG9jYWxEZWNsYXJlID0+IHtcblx0XHRsZXQgXyA9IGRlY2xhcmVUb0lkLmdldChsb2NhbERlY2xhcmUpXG5cdFx0aWYgKF8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XyA9IElkZW50aWZpZXIobWFuZ2xlSWRlbnRpZmllcihsb2NhbERlY2xhcmUubmFtZSkpXG5cdFx0XHRkZWNsYXJlVG9JZC5zZXQobG9jYWxEZWNsYXJlLCBfKVxuXHRcdH1cblx0XHRyZXR1cm4gX1xuXHR9LFxuXG5cdG9wVHlwZUNoZWNrRm9yTG9jYWxEZWNsYXJlID0gbG9jYWxEZWNsYXJlID0+XG5cdFx0Ly8gVE9ETzogV2F5IHRvIHR5cGVjaGVjayBsYXppZXNcblx0XHRvcElmKCFsb2NhbERlY2xhcmUuaXNMYXp5KCksICgpID0+XG5cdFx0XHRvcE1hcChsb2NhbERlY2xhcmUub3BUeXBlLCB0eXBlID0+XG5cdFx0XHRcdEV4cHJlc3Npb25TdGF0ZW1lbnQobXNDaGVja0NvbnRhaW5zKFxuXHRcdFx0XHRcdHQwKHR5cGUpLFxuXHRcdFx0XHRcdGFjY2Vzc0xvY2FsRGVjbGFyZShsb2NhbERlY2xhcmUpLFxuXHRcdFx0XHRcdExpdGVyYWwobG9jYWxEZWNsYXJlLm5hbWUpKSkpKSxcblxuXHR0aHJvd0Vycm9yRnJvbVN0cmluZyA9IG1zZyA9PlxuXHRcdFRocm93U3RhdGVtZW50KE5ld0V4cHJlc3Npb24oX0lkRXJyb3IsIFsgTGl0ZXJhbChtc2cpIF0pKSxcblxuXHR0ZW1wbGF0ZUVsZW1lbnRGb3JTdHJpbmcgPSBzdHIgPT5cblx0XHRUZW1wbGF0ZUVsZW1lbnQoZmFsc2UsIHsgY29va2VkOiBzdHIsIHJhdzogZXNjYXBlU3RyaW5nRm9yVGVtcGxhdGUoc3RyKSB9KVxuXG5jb25zdFxuXHRkZWNsYXJlVG9JZCA9IG5ldyBXZWFrTWFwKClcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9