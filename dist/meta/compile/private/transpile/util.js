if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', '../U/Bag', '../U/Op', '../U/util', './transpile', './esast-util'], function (exports, _esastDistAst, _esastDistUtil, _UBag, _UOp, _UUtil, _transpile, _esastUtil) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const LitEmptyArray = _esastDistAst.ArrayExpression([]),
	      LitEmptyString = _esastDistAst.Literal(''),
	      LitNull = _esastDistAst.Literal(null),
	      LitStrDisplayName = _esastDistAst.Literal('displayName'),
	      Break = _esastDistAst.BreakStatement(),
	      ReturnRes = _esastDistAst.ReturnStatement(_esastDistAst.Identifier('res')),
	      IdDefine = _esastDistAst.Identifier('define'),
	      IdDisplayName = _esastDistAst.Identifier('displayName'),
	      IdExports = _esastDistAst.Identifier('exports'),
	      IdArguments = _esastDistAst.Identifier('arguments'),
	      IdArraySliceCall = _esastDistUtil.member(_esastDistUtil.member(LitEmptyArray, 'slice'), 'call'),
	      IdFunctionApplyCall = _esastDistUtil.member(_esastDistUtil.member(_esastDistAst.Identifier('Function'), 'apply'), 'call'),
	      IdModule = _esastDistAst.Identifier('module'),
	      IdMs = _esastDistAst.Identifier('_ms');

	exports.LitEmptyArray = LitEmptyArray;
	exports.LitEmptyString = LitEmptyString;
	exports.LitNull = LitNull;
	exports.LitStrDisplayName = LitStrDisplayName;
	exports.Break = Break;
	exports.ReturnRes = ReturnRes;
	exports.IdDefine = IdDefine;
	exports.IdDisplayName = IdDisplayName;
	exports.IdExports = IdExports;
	exports.IdArguments = IdArguments;
	exports.IdArraySliceCall = IdArraySliceCall;
	exports.IdFunctionApplyCall = IdFunctionApplyCall;
	exports.IdModule = IdModule;
	exports.IdMs = IdMs;
	const ms = function (name) {
		const m = _esastDistUtil.member(IdMs, name);
		return function (args) {
			return _esastDistAst.CallExpression(m, args);
		};
	};
	const msGetDefaultExport = ms('getDefaultExport'),
	      msGet = ms('get'),
	      msGetModule = ms('getModule'),
	      msLazyGetModule = ms('lazyGetModule'),
	      msArr = ms('arr'),
	      msBool = ms('bool'),
	      msLset = ms('lset'),
	      msSet = ms('set'),
	      msMap = ms('map'),
	      msShow = ms('show'),
	      msCheckContains = ms('checkContains'),
	      msUnlazy = ms('unlazy'),
	      msLazy = ms('lazy'),
	      msLazyGet = ms('lazyProp');

	exports.msGetDefaultExport = msGetDefaultExport;
	exports.msGet = msGet;
	exports.msGetModule = msGetModule;
	exports.msLazyGetModule = msLazyGetModule;
	exports.msArr = msArr;
	exports.msBool = msBool;
	exports.msLset = msLset;
	exports.msSet = msSet;
	exports.msMap = msMap;
	exports.msShow = msShow;
	exports.msCheckContains = msCheckContains;
	exports.msUnlazy = msUnlazy;
	exports.msLazy = msLazy;
	exports.msLazyGet = msLazyGet;
	const makeDestructureDeclarators = function (cx, loc, assignees, isLazy, value, k, isModule) {
		const destructuredName = '_$' + loc.start.line;
		const idDestructured = _esastDistAst.Identifier(destructuredName);
		const declarators = assignees.map(function (assignee) {
			// TODO: Don't compile it if it's never accessed
			const get = getMember(cx, idDestructured, assignee.name, isLazy, isModule);
			return makeDeclarator(cx, assignee.loc, assignee, k, get, isLazy);
		});
		// Getting lazy module is done by ms.lazyGetModule.
		const val = isLazy && !isModule ? lazyWrap(value) : value;
		return _UBag.unshift(_esastDistAst.VariableDeclarator(idDestructured, val), declarators);
	},
	      makeDeclarator = function (cx, loc, assignee, k, value, valueIsAlreadyLazy) {
		// TODO: assert(isEmpty(assignee.opType))
		// or TODO: Allow type check on lazy value?
		value = assignee.isLazy ? value : maybeWrapInCheckContains(cx, value, assignee.opType, assignee.name);
		switch (k) {
			case '=':case '. ':case '<~':case '<~~':
				{
					const val = assignee.isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value;
					_UUtil.assert(assignee.isLazy || !valueIsAlreadyLazy);
					return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), val);
				}
			case 'export':
				{
					// TODO:ES6
					_UUtil.assert(!assignee.isLazy);
					return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), _esastDistAst.AssignmentExpression('=', _esastDistUtil.member(IdExports, assignee.name), value));
				}
			default:
				throw new Error(k);
		}
	},
	      accessLocal = function (localAccess, vr) {
		return accessLocalDeclare(vr.accessToLocal.get(localAccess));
	},
	      accessLocalDeclare = function (localDeclare) {
		return localDeclare.isLazy ? msUnlazy([_esastUtil.idForDeclareCached(localDeclare)]) : _esastUtil.idForDeclareNew(localDeclare);
	},
	      maybeWrapInCheckContains = function (cx, ast, opType, name) {
		return cx.opts.includeTypeChecks() ? _UOp.ifElse(opType, function (typ) {
			return msCheckContains([_transpile.t0(typ), ast, _esastDistAst.Literal(name)]);
		}, function () {
			return ast;
		}) : ast;
	},
	      opLocalCheck = function (cx, local, isLazy) {
		// TODO: Way to typecheck lazies
		if (!cx.opts.includeTypeChecks() || isLazy) return _UOp.None;else return local.opType.map(function (typ) {
			return _esastDistAst.ExpressionStatement(msCheckContains([_transpile.t0(typ), accessLocalDeclare(local), _esastDistAst.Literal(local.name)]));
		});
	},
	      lazyWrap = function (value) {
		return msLazy([_esastDistUtil.thunk(value)]);
	};

	exports.makeDestructureDeclarators = makeDestructureDeclarators;
	exports.makeDeclarator = makeDeclarator;
	exports.accessLocal = accessLocal;
	exports.accessLocalDeclare = accessLocalDeclare;
	exports.maybeWrapInCheckContains = maybeWrapInCheckContains;
	exports.opLocalCheck = opLocalCheck;
	exports.lazyWrap = lazyWrap;
	const getMember = function (cx, astObject, gotName, isLazy, isModule) {
		if (isLazy) return msLazyGet([astObject, _esastDistAst.Literal(gotName)]);else if (isModule && cx.opts.includeUseChecks()) return msGet([astObject, _esastDistAst.Literal(gotName)]);else return _esastDistUtil.member(astObject, gotName);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVNPLE9BQ04sYUFBYSxHQUFHLGNBVlIsZUFBZSxDQVVTLEVBQUUsQ0FBQztPQUNuQyxjQUFjLEdBQUcsY0FWTCxPQUFPLENBVU0sRUFBRSxDQUFDO09BQzVCLE9BQU8sR0FBRyxjQVhFLE9BQU8sQ0FXRCxJQUFJLENBQUM7T0FDdkIsaUJBQWlCLEdBQUcsY0FaUixPQUFPLENBWVMsYUFBYSxDQUFDO09BQzFDLEtBQUssR0FBRyxjQWR1QyxjQUFjLEVBY3JDO09BQ3hCLFNBQVMsR0FBRyxjQWRTLGVBQWUsQ0FjUixjQWQ1QixVQUFVLENBYzZCLEtBQUssQ0FBQyxDQUFDO09BQzlDLFFBQVEsR0FBRyxjQWZYLFVBQVUsQ0FlWSxRQUFRLENBQUM7T0FDL0IsYUFBYSxHQUFHLGNBaEJoQixVQUFVLENBZ0JpQixhQUFhLENBQUM7T0FDekMsU0FBUyxHQUFHLGNBakJaLFVBQVUsQ0FpQmEsU0FBUyxDQUFDO09BQ2pDLFdBQVcsR0FBRyxjQWxCZCxVQUFVLENBa0JlLFdBQVcsQ0FBQztPQUNyQyxnQkFBZ0IsR0FBRyxlQWxCWCxNQUFNLENBa0JZLGVBbEJsQixNQUFNLENBa0JtQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDO09BQ2pFLG1CQUFtQixHQUFHLGVBbkJkLE1BQU0sQ0FtQmUsZUFuQnJCLE1BQU0sQ0FtQnNCLGNBcEJwQyxVQUFVLENBb0JxQyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUM7T0FDN0UsUUFBUSxHQUFHLGNBckJYLFVBQVUsQ0FxQlksUUFBUSxDQUFDO09BQy9CLElBQUksR0FBRyxjQXRCUCxVQUFVLENBc0JRLEtBQUssQ0FBQyxDQUFBOztTQWJ4QixhQUFhLEdBQWIsYUFBYTtTQUNiLGNBQWMsR0FBZCxjQUFjO1NBQ2QsT0FBTyxHQUFQLE9BQU87U0FDUCxpQkFBaUIs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QUksQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUFBLENBQUMsQ0FBQTtFQUN6QjtPQUVELFFBQVEsR0FBRyxVQUFBLEtBQUs7U0FBSSxNQUFNLENBQUMsQ0FBRSxlQXpHYixLQUFLLENBeUdjLEtBQUssQ0FBQyxDQUFFLENBQUM7RUFBQSxDQUFBOztTQTdENUMsMEJBQTBCLEdBQTFCLDBCQUEwQjtTQWExQixjQUFjLEdBQWQsY0FBYztTQXNCZCxXQUFXLEdBQVgsV0FBVztTQUdYLGtCQUFrQixHQUFsQixrQkFBa0I7U0FLbEIsd0JBQXdCLEdBQXhCLHdCQUF3QjtTQU94QixZQUFZLEdBQVosWUFBWTtTQVdaLFFBQVEsR0FBUixRQUFRO0FBRVQsT0FBTSxTQUFTLEdBQUcsVUFBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFLO0FBQy9ELE1BQUksTUFBTSxFQUNULE9BQU8sU0FBUyxDQUFDLENBQUUsU0FBUyxFQUFFLGNBOUduQixPQUFPLENBOEdvQixPQUFPLENBQUMsQ0FBRSxDQUFDLENBQUEsS0FDN0MsSUFBSSxRQUFRLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUM5QyxPQUFPLEtBQUssQ0FBQyxDQUFFLFNBQVMsRUFBRSxjQWhIZixPQUFPLENBZ0hnQixPQUFPLENBQUMsQ0FBRSxDQUFDLENBQUEsS0FFN0MsT0FBTyxlQWpIQSxNQUFNLENBaUhDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtFQUNsQyxDQUFBIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJyYXlFeHByZXNzaW9uLCBBc3NpZ25tZW50RXhwcmVzc2lvbiwgQnJlYWtTdGF0ZW1lbnQsIENhbGxFeHByZXNzaW9uLCBFeHByZXNzaW9uU3RhdGVtZW50LFxuXHRJZGVudGlmaWVyLCBMaXRlcmFsLCBSZXR1cm5TdGF0ZW1lbnQsIFZhcmlhYmxlRGVjbGFyYXRvciB9IGZyb20gJ2VzYXN0L2Rpc3QvYXN0J1xuaW1wb3J0IHsgbWVtYmVyLCB0aHVuayB9IGZyb20gJ2VzYXN0L2Rpc3QvdXRpbCdcbmltcG9ydCB7IHVuc2hpZnQgfSBmcm9tICcuLi9VL0JhZydcbmltcG9ydCB7IGlmRWxzZSwgTm9uZSB9IGZyb20gJy4uL1UvT3AnXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9VL3V0aWwnXG5pbXBvcnQgeyB0MCB9IGZyb20gJy4vdHJhbnNwaWxlJ1xuaW1wb3J0IHsgaWRGb3JEZWNsYXJlQ2FjaGVkLCBpZEZvckRlY2xhcmVOZXcgfSBmcm9tICcuL2VzYXN0LXV0aWwnXG5cbmV4cG9ydCBjb25zdFxuXHRMaXRFbXB0eUFycmF5ID0gQXJyYXlFeHByZXNzaW9uKFtdKSxcblx0TGl0RW1wdHlTdHJpbmcgPSBMaXRlcmFsKCcnKSxcblx0TGl0TnVsbCA9IExpdGVyYWwobnVsbCksXG5cdExpdFN0ckRpc3BsYXlOYW1lID0gTGl0ZXJhbCgnZGlzcGxheU5hbWUnKSxcblx0QnJlYWsgPSBCcmVha1N0YXRlbWVudCgpLFxuXHRSZXR1cm5SZXMgPSBSZXR1cm5TdGF0ZW1lbnQoSWRlbnRpZmllcigncmVzJykpLFxuXHRJZERlZmluZSA9IElkZW50aWZpZXIoJ2RlZmluZScpLFxuXHRJZERpc3BsYXlOYW1lID0gSWRlbnRpZmllcignZGlzcGxheU5hbWUnKSxcblx0SWRFeHBvcnRzID0gSWRlbnRpZmllcignZXhwb3J0cycpLFxuXHRJZEFyZ3VtZW50cyA9IElkZW50aWZpZXIoJ2FyZ3VtZW50cycpLFxuXHRJZEFycmF5U2xpY2VDYWxsID0gbWVtYmVyKG1lbWJlcihMaXRFbXB0eUFycmF5LCAnc2xpY2UnKSwgJ2NhbGwnKSxcblx0SWRGdW5jdGlvbkFwcGx5Q2FsbCA9IG1lbWJlcihtZW1iZXIoSWRlbnRpZmllcignRnVuY3Rpb24nKSwgJ2FwcGx5JyksICdjYWxsJyksXG5cdElkTW9kdWxlID0gSWRlbnRpZmllcignbW9kdWxlJyksXG5cdElkTXMgPSBJZGVudGlmaWVyKCdfbXMnKVxuXG5jb25zdCBtcyA9IG5hbWUgPT4ge1xuXHRjb25zdCBtID0gbWVtYmVyKElkTXMsIG5hbWUpXG5cdHJldHVybiBhcmdzID0+IENhbGxFeHByZXNzaW9uKG0sIGFyZ3MpXG59XG5leHBvcnQgY29uc3Rcblx0bXNHZXREZWZhdWx0RXhwb3J0ID0gbXMoJ2dldERlZmF1bHRFeHBvcnQnKSxcblx0bXNHZXQgPSBtcygnZ2V0JyksXG5cdG1zR2V0TW9kdWxlID0gbXMoJ2dldE1vZHVsZScpLFxuXHRtc0xhenlHZXRNb2R1bGUgPSBtcygnbGF6eUdldE1vZHVsZScpLFxuXHRtc0FyciA9IG1zKCdhcnInKSxcblx0bXNCb29sID0gbXMoJ2Jvb2wnKSxcblx0bXNMc2V0ID0gbXMoJ2xzZXQnKSxcblx0bXNTZXQgPSBtcygnc2V0JyksXG5cdG1zTWFwID0gbXMoJ21hcCcpLFxuXHRtc1Nob3cgPSBtcygnc2hvdycpLFxuXHRtc0NoZWNrQ29udGFpbnMgPSBtcygnY2hlY2tDb250YWlucycpLFxuXHRtc1VubGF6eSA9IG1zKCd1bmxhenknKSxcblx0bXNMYXp5ID0gbXMoJ2xhenknKSxcblx0bXNMYXp5R2V0ID0gbXMoJ2xhenlQcm9wJylcblxuZXhwb3J0IGNvbnN0XG5cdG1ha2VEZXN0cnVjdHVyZURlY2xhcmF0b3JzID0gKGN4LCBsb2MsIGFzc2lnbmVlcywgaXNMYXp5LCB2YWx1ZSwgaywgaXNNb2R1bGUpID0+IHtcblx0XHRjb25zdCBkZXN0cnVjdHVyZWROYW1lID0gYF8kJHtsb2Muc3RhcnQubGluZX1gXG5cdFx0Y29uc3QgaWREZXN0cnVjdHVyZWQgPSBJZGVudGlmaWVyKGRlc3RydWN0dXJlZE5hbWUpXG5cdFx0Y29uc3QgZGVjbGFyYXRvcnMgPSBhc3NpZ25lZXMubWFwKGFzc2lnbmVlID0+IHtcblx0XHRcdC8vIFRPRE86IERvbid0IGNvbXBpbGUgaXQgaWYgaXQncyBuZXZlciBhY2Nlc3NlZFxuXHRcdFx0Y29uc3QgZ2V0ID0gZ2V0TWVtYmVyKGN4LCBpZERlc3RydWN0dXJlZCwgYXNzaWduZWUubmFtZSwgaXNMYXp5LCBpc01vZHVsZSlcblx0XHRcdHJldHVybiBtYWtlRGVjbGFyYXRvcihjeCwgYXNzaWduZWUubG9jLCBhc3NpZ25lZSwgaywgZ2V0LCBpc0xhenkpXG5cdFx0fSlcblx0XHQvLyBHZXR0aW5nIGxhenkgbW9kdWxlIGlzIGRvbmUgYnkgbXMubGF6eUdldE1vZHVsZS5cblx0XHRjb25zdCB2YWwgPSAoaXNMYXp5ICYmICFpc01vZHVsZSkgPyBsYXp5V3JhcCh2YWx1ZSkgOiB2YWx1ZVxuXHRcdHJldHVybiB1bnNoaWZ0KFZhcmlhYmxlRGVjbGFyYXRvcihpZERlc3RydWN0dXJlZCwgdmFsKSwgZGVjbGFyYXRvcnMpXG5cdH0sXG5cblx0bWFrZURlY2xhcmF0b3IgPSAoY3gsIGxvYywgYXNzaWduZWUsIGssIHZhbHVlLCB2YWx1ZUlzQWxyZWFkeUxhenkpID0+IHtcblx0XHQvLyBUT0RPOiBhc3NlcnQoaXNFbXB0eShhc3NpZ25lZS5vcFR5cGUpKVxuXHRcdC8vIG9yIFRPRE86IEFsbG93IHR5cGUgY2hlY2sgb24gbGF6eSB2YWx1ZT9cblx0XHR2YWx1ZSA9IGFzc2lnbmVlLmlzTGF6eSA/IHZhbHVlIDpcblx0XHRcdG1heWJlV3JhcEluQ2hlY2tDb250YWlucyhjeCwgdmFsdWUsIGFzc2lnbmVlLm9wVHlwZSwgYXNzaWduZWUubmFtZSlcblx0XHRzd2l0Y2ggKGspIHtcblx0XHRcdGNhc2UgJz0nOiBjYXNlICcuICc6IGNhc2UgJzx+JzogY2FzZSAnPH5+Jzoge1xuXHRcdFx0XHRjb25zdCB2YWwgPSBhc3NpZ25lZS5pc0xhenkgJiYgIXZhbHVlSXNBbHJlYWR5TGF6eSA/IGxhenlXcmFwKHZhbHVlKSA6IHZhbHVlXG5cdFx0XHRcdGFzc2VydChhc3NpZ25lZS5pc0xhenkgfHwgIXZhbHVlSXNBbHJlYWR5TGF6eSlcblx0XHRcdFx0cmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcihpZEZvckRlY2xhcmVDYWNoZWQoYXNzaWduZWUpLCB2YWwpXG5cdFx0XHR9XG5cdFx0XHRjYXNlICdleHBvcnQnOiB7XG5cdFx0XHRcdC8vIFRPRE86RVM2XG5cdFx0XHRcdGFzc2VydCghYXNzaWduZWUuaXNMYXp5KVxuXHRcdFx0XHRyZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yKFxuXHRcdFx0XHRcdGlkRm9yRGVjbGFyZUNhY2hlZChhc3NpZ25lZSksXG5cdFx0XHRcdFx0QXNzaWdubWVudEV4cHJlc3Npb24oJz0nLCBtZW1iZXIoSWRFeHBvcnRzLCBhc3NpZ25lZS5uYW1lKSwgdmFsdWUpKVxuXHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGspXG5cdFx0fVxuXHR9LFxuXG5cdGFjY2Vzc0xvY2FsID0gKGxvY2FsQWNjZXNzLCB2cikgPT5cblx0XHRhY2Nlc3NMb2NhbERlY2xhcmUodnIuYWNjZXNzVG9Mb2NhbC5nZXQobG9jYWxBY2Nlc3MpKSxcblxuXHRhY2Nlc3NMb2NhbERlY2xhcmUgPSBsb2NhbERlY2xhcmUgPT5cblx0XHRsb2NhbERlY2xhcmUuaXNMYXp5ID9cblx0XHRcdG1zVW5sYXp5KFsgaWRGb3JEZWNsYXJlQ2FjaGVkKGxvY2FsRGVjbGFyZSkgXSkgOlxuXHRcdFx0aWRGb3JEZWNsYXJlTmV3KGxvY2FsRGVjbGFyZSksXG5cblx0bWF5YmVXcmFwSW5DaGVja0NvbnRhaW5zID0gKGN4LCBhc3QsIG9wVHlwZSwgbmFtZSkgPT5cblx0XHRjeC5vcHRzLmluY2x1ZGVUeXBlQ2hlY2tzKCkgP1xuXHRcdFx0aWZFbHNlKG9wVHlwZSxcblx0XHRcdFx0dHlwID0+IG1zQ2hlY2tDb250YWlucyhbIHQwKHR5cCksIGFzdCwgTGl0ZXJhbChuYW1lKSBdKSxcblx0XHRcdFx0KCkgPT4gYXN0KSA6XG5cdFx0XHRhc3QsXG5cblx0b3BMb2NhbENoZWNrID0gKGN4LCBsb2NhbCwgaXNMYXp5KSA9PiB7XG5cdFx0Ly8gVE9ETzogV2F5IHRvIHR5cGVjaGVjayBsYXppZXNcblx0XHRpZiAoIWN4Lm9wdHMuaW5jbHVkZVR5cGVDaGVja3MoKSB8fCBpc0xhenkpXG5cdFx0XHRyZXR1cm4gTm9uZVxuXHRcdGVsc2UgcmV0dXJuIGxvY2FsLm9wVHlwZS5tYXAodHlwID0+XG5cdFx0XHRFeHByZXNzaW9uU3RhdGVtZW50KG1zQ2hlY2tDb250YWlucyhbXG5cdFx0XHRcdHQwKHR5cCksXG5cdFx0XHRcdGFjY2Vzc0xvY2FsRGVjbGFyZShsb2NhbCksXG5cdFx0XHRcdExpdGVyYWwobG9jYWwubmFtZSldKSkpXG5cdH0sXG5cblx0bGF6eVdyYXAgPSB2YWx1ZSA9PiBtc0xhenkoWyB0aHVuayh2YWx1ZSkgXSlcblxuY29uc3QgZ2V0TWVtYmVyID0gKGN4LCBhc3RPYmplY3QsIGdvdE5hbWUsIGlzTGF6eSwgaXNNb2R1bGUpID0+IHtcblx0aWYgKGlzTGF6eSlcblx0XHRyZXR1cm4gbXNMYXp5R2V0KFsgYXN0T2JqZWN0LCBMaXRlcmFsKGdvdE5hbWUpIF0pXG5cdGVsc2UgaWYgKGlzTW9kdWxlICYmIGN4Lm9wdHMuaW5jbHVkZVVzZUNoZWNrcygpKVxuXHRcdHJldHVybiBtc0dldChbIGFzdE9iamVjdCwgTGl0ZXJhbChnb3ROYW1lKSBdKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG1lbWJlcihhc3RPYmplY3QsIGdvdE5hbWUpXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==