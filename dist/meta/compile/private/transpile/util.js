if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', '../U/Bag', '../U/op', '../U/util', './transpile', './esast-util'], function (exports, _esastDistAst, _esastDistUtil, _UBag, _UOp, _UUtil, _transpile, _esastUtil) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const LitEmptyArray = _esastDistAst.ArrayExpression([]),
	      LitEmptyString = _esastDistAst.Literal(''),
	      LitNull = _esastDistAst.Literal(null),
	      LitStrDisplayName = _esastDistAst.Literal('displayName'),
	      Break = _esastDistAst.BreakStatement(),
	      ReturnRes = _esastDistAst.ReturnStatement(_esastDistAst.Identifier('res')),
	      IdDefine = _esastDistAst.Identifier('define'),
	      IdDisplayName = _esastDistAst.Identifier('displayName'),
	      IdExports = _esastDistAst.Identifier('exports'),
	      IdArguments = _esastDistAst.Identifier('arguments'),
	      IdArraySliceCall = _esastDistUtil.member(_esastDistUtil.member(LitEmptyArray, 'slice'), 'call'),
	      IdFunctionApplyCall = _esastDistUtil.member(_esastDistUtil.member(_esastDistAst.Identifier('Function'), 'apply'), 'call'),
	      IdModule = _esastDistAst.Identifier('module'),
	      IdMs = _esastDistAst.Identifier('_ms');

	exports.LitEmptyArray = LitEmptyArray;
	exports.LitEmptyString = LitEmptyString;
	exports.LitNull = LitNull;
	exports.LitStrDisplayName = LitStrDisplayName;
	exports.Break = Break;
	exports.ReturnRes = ReturnRes;
	exports.IdDefine = IdDefine;
	exports.IdDisplayName = IdDisplayName;
	exports.IdExports = IdExports;
	exports.IdArguments = IdArguments;
	exports.IdArraySliceCall = IdArraySliceCall;
	exports.IdFunctionApplyCall = IdFunctionApplyCall;
	exports.IdModule = IdModule;
	exports.IdMs = IdMs;
	const ms = function (name) {
		const m = _esastDistUtil.member(IdMs, name);
		return function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _esastDistAst.CallExpression(m, args);
		};
	};
	const msGetDefaultExport = ms('getDefaultExport'),
	      msGet = ms('get'),
	      msGetModule = ms('getModule'),
	      msLazyGetModule = ms('lazyGetModule'),
	      msArr = ms('arr'),
	      msBool = ms('bool'),
	      msExtract = ms('extract'),
	      msLset = ms('lset'),
	      msSet = ms('set'),
	      msMap = ms('map'),
	      msShow = ms('show'),
	      msCheckContains = ms('checkContains'),
	      msUnlazy = ms('unlazy'),
	      msLazy = ms('lazy'),
	      msLazyGet = ms('lazyProp');

	exports.msGetDefaultExport = msGetDefaultExport;
	exports.msGet = msGet;
	exports.msGetModule = msGetModule;
	exports.msLazyGetModule = msLazyGetModule;
	exports.msArr = msArr;
	exports.msBool = msBool;
	exports.msExtract = msExtract;
	exports.msLset = msLset;
	exports.msSet = msSet;
	exports.msMap = msMap;
	exports.msShow = msShow;
	exports.msCheckContains = msCheckContains;
	exports.msUnlazy = msUnlazy;
	exports.msLazy = msLazy;
	exports.msLazyGet = msLazyGet;
	const makeDestructureDeclarators = function (cx, loc, assignees, isLazy, value, isModule, isExport) {
		const destructuredName = '_$' + loc.start.line;
		const idDestructured = _esastDistAst.Identifier(destructuredName);
		const declarators = assignees.map(function (assignee) {
			// TODO: Don't compile it if it's never accessed
			const get = getMember(cx, idDestructured, assignee.name, isLazy, isModule);
			return makeDeclarator(cx, assignee.loc, assignee, get, isLazy, isExport);
		});
		// Getting lazy module is done by ms.lazyGetModule.
		const val = isLazy && !isModule ? lazyWrap(value) : value;
		return _UBag.unshift(_esastDistAst.VariableDeclarator(idDestructured, val), declarators);
	},
	      makeDeclarator = function (cx, loc, assignee, value, valueIsAlreadyLazy, isExport) {
		// TODO: assert(assignee.opType === null)
		// or TODO: Allow type check on lazy value?
		value = assignee.isLazy ? value : maybeWrapInCheckContains(cx, value, assignee.opType, assignee.name);

		if (isExport) {
			// TODO:ES6
			cx.check(!assignee.isLazy, assignee.loc, 'Lazy export not supported.');
			return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), _esastDistAst.AssignmentExpression('=', _esastDistUtil.member(IdExports, assignee.name), value));
		} else {
			const val = assignee.isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value;
			_UUtil.assert(assignee.isLazy || !valueIsAlreadyLazy);
			return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), val);
		}
	},
	      accessLocal = function (localAccess, vr) {
		return accessLocalDeclare(vr.accessToLocal.get(localAccess));
	},
	      accessLocalDeclare = function (localDeclare) {
		return localDeclare.isLazy ? msUnlazy(_esastUtil.idForDeclareCached(localDeclare)) : _esastUtil.idForDeclareNew(localDeclare);
	},
	      maybeWrapInCheckContains = function (cx, ast, opType, name) {
		return cx.opts.includeTypeChecks() && opType !== null ? msCheckContains(_transpile.t0(opType), ast, _esastDistAst.Literal(name)) : ast;
	},
	      opLocalCheck = function (cx, local, isLazy) {
		return (
			// TODO: Way to typecheck lazies
			!cx.opts.includeTypeChecks() || isLazy ? null : _UOp.opMap(local.opType, function (typ) {
				return _esastDistAst.ExpressionStatement(msCheckContains(_transpile.t0(typ), accessLocalDeclare(local), _esastDistAst.Literal(local.name)));
			})
		);
	},
	      lazyWrap = function (value) {
		return msLazy(_esastDistUtil.thunk(value));
	},
	      toStatements = function (_) {
		return _ instanceof Array ? _.map(_esastDistUtil.toStatement) : [_esastDistUtil.toStatement(_)];
	};

	exports.makeDestructureDeclarators = makeDestructureDeclarators;
	exports.makeDeclarator = makeDeclarator;
	exports.accessLocal = accessLocal;
	exports.accessLocalDeclare = accessLocalDeclare;
	exports.maybeWrapInCheckContains = maybeWrapInCheckContains;
	exports.opLocalCheck = opLocalCheck;
	exports.lazyWrap = lazyWrap;
	exports.toStatements = toStatements;
	const getMember = function (cx, astObject, gotName, isLazy, isModule) {
		if (isLazy) return msLazyGet(astObject, _esastDistAst.Literal(gotName));else if (isModule && cx.opts.includeUseChecks()) return msGet(astObject, _esastDistAst.Literal(gotName));else return _esastDistUtil.member(astObject, gotName);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVNPLE9BQ04sYUFBYSxHQUFHLGNBVlIsZUFBZSxDQVVTLEVBQUUsQ0FBQztPQUNuQyxjQUFjLEdBQUcsY0FWTCxPQUFPLENBVU0sRUFBRSxDQUFDO09BQzVCLE9BQU8sR0FBRyxjQVhFLE9BQU8sQ0FXRCxJQUFJLENBQUM7T0FDdkIsaUJBQWlCLEdBQUcsY0FaUixPQUFPLENBWVMsYUFBYSxDQUFDO09BQzFDLEtBQUssR0FBRyxjQWR1QyxjQUFjLEVBY3JDO09BQ3hCLFNBQVMsR0FBRyxjQWRTLGVBQWUsQ0FjUixjQWQ1QixVQUFVLENBYzZCLEtBQUssQ0FBQyxDQUFDO09BQzlDLFFBQVEsR0FBRyxjQWZYLFVBQVUsQ0FlWSxRQUFRLENBQUM7T0FDL0IsYUFBYSxHQUFHLGNBaEJoQixVQUFVLENBZ0JpQixhQUFhLENBQUM7T0FDekMsU0FBUyxHQUFHLGNBakJaLFVBQVUsQ0FpQmEsU0FBUyxDQUFDO09BQ2pDLFdBQVcsR0FBRyxjQWxCZCxVQUFVLENBa0JlLFdBQVcsQ0FBQztPQUNyQyxnQkFBZ0IsR0FBRyxlQWxCWCxNQUFNLENBa0JZLGVBbEJsQixNQUFNLENBa0JtQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDO09BQ2pFLG1CQUFtQixHQUFHLGVBbkJkLE1BQU0sQ0FtQmUsZUFuQnJCLE1BQU0sQ0FtQnNCLGNBcEJwQyxVQUFVLENBb0JxQyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUM7T0FDN0UsUUFBUSxHQUFHLGNBckJYLFVBQVUsQ0FxQlksUUFBUSxDQUFDO09BQy9CLElBQUksR0FBRyxjQXRCUCxVQUFVLENBc0JRLEtBQUssQ0FBQyxDQUFBOztTQWJ4QixhQUFhLEdBQWIsYUFBYTtTQUNiLGNBQWMsR0FBZCxjQUFjO1NBQ2QsT0FBTyxHQUFQLE9BQU87U0FDUCxpQkFBaUIs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QztTQUFJLENBQUMsWUFBWSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsZ0JBckd2QixXQUFXLENBcUd5QixHQUFHLENBQUUsZUFyR3pDLFdBQVcsQ0FxRzBDLENBQUMsQ0FBQyxDQUFFO0VBQUEsQ0FBQTs7U0F4RGhGLDBCQUEwQixHQUExQiwwQkFBMEI7U0FhMUIsY0FBYyxHQUFkLGNBQWM7U0FtQmQsV0FBVyxHQUFYLFdBQVc7U0FHWCxrQkFBa0IsR0FBbEIsa0JBQWtCO1NBS2xCLHdCQUF3QixHQUF4Qix3QkFBd0I7U0FLeEIsWUFBWSxHQUFaLFlBQVk7U0FTWixRQUFRLEdBQVIsUUFBUTtTQUVSLFlBQVksR0FBWixZQUFZO0FBRWIsT0FBTSxTQUFTLEdBQUcsVUFBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFLO0FBQy9ELE1BQUksTUFBTSxFQUNULE9BQU8sU0FBUyxDQUFDLFNBQVMsRUFBRSxjQTFHakIsT0FBTyxDQTBHa0IsT0FBTyxDQUFDLENBQUMsQ0FBQSxLQUN6QyxJQUFJLFFBQVEsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQzlDLE9BQU8sS0FBSyxDQUFDLFNBQVMsRUFBRSxjQTVHYixPQUFPLENBNEdjLE9BQU8sQ0FBQyxDQUFDLENBQUEsS0FFekMsT0FBTyxlQTdHQSxNQUFNLENBNkdDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtFQUNsQyxDQUFBIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJyYXlFeHByZXNzaW9uLCBBc3NpZ25tZW50RXhwcmVzc2lvbiwgQnJlYWtTdGF0ZW1lbnQsIENhbGxFeHByZXNzaW9uLCBFeHByZXNzaW9uU3RhdGVtZW50LFxuXHRJZGVudGlmaWVyLCBMaXRlcmFsLCBSZXR1cm5TdGF0ZW1lbnQsIFZhcmlhYmxlRGVjbGFyYXRvciB9IGZyb20gJ2VzYXN0L2Rpc3QvYXN0J1xuaW1wb3J0IHsgbWVtYmVyLCB0aHVuaywgdG9TdGF0ZW1lbnQgfSBmcm9tICdlc2FzdC9kaXN0L3V0aWwnXG5pbXBvcnQgeyB1bnNoaWZ0IH0gZnJvbSAnLi4vVS9CYWcnXG5pbXBvcnQgeyBvcE1hcCB9IGZyb20gJy4uL1Uvb3AnXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9VL3V0aWwnXG5pbXBvcnQgeyB0MCB9IGZyb20gJy4vdHJhbnNwaWxlJ1xuaW1wb3J0IHsgaWRGb3JEZWNsYXJlQ2FjaGVkLCBpZEZvckRlY2xhcmVOZXcgfSBmcm9tICcuL2VzYXN0LXV0aWwnXG5cbmV4cG9ydCBjb25zdFxuXHRMaXRFbXB0eUFycmF5ID0gQXJyYXlFeHByZXNzaW9uKFtdKSxcblx0TGl0RW1wdHlTdHJpbmcgPSBMaXRlcmFsKCcnKSxcblx0TGl0TnVsbCA9IExpdGVyYWwobnVsbCksXG5cdExpdFN0ckRpc3BsYXlOYW1lID0gTGl0ZXJhbCgnZGlzcGxheU5hbWUnKSxcblx0QnJlYWsgPSBCcmVha1N0YXRlbWVudCgpLFxuXHRSZXR1cm5SZXMgPSBSZXR1cm5TdGF0ZW1lbnQoSWRlbnRpZmllcigncmVzJykpLFxuXHRJZERlZmluZSA9IElkZW50aWZpZXIoJ2RlZmluZScpLFxuXHRJZERpc3BsYXlOYW1lID0gSWRlbnRpZmllcignZGlzcGxheU5hbWUnKSxcblx0SWRFeHBvcnRzID0gSWRlbnRpZmllcignZXhwb3J0cycpLFxuXHRJZEFyZ3VtZW50cyA9IElkZW50aWZpZXIoJ2FyZ3VtZW50cycpLFxuXHRJZEFycmF5U2xpY2VDYWxsID0gbWVtYmVyKG1lbWJlcihMaXRFbXB0eUFycmF5LCAnc2xpY2UnKSwgJ2NhbGwnKSxcblx0SWRGdW5jdGlvbkFwcGx5Q2FsbCA9IG1lbWJlcihtZW1iZXIoSWRlbnRpZmllcignRnVuY3Rpb24nKSwgJ2FwcGx5JyksICdjYWxsJyksXG5cdElkTW9kdWxlID0gSWRlbnRpZmllcignbW9kdWxlJyksXG5cdElkTXMgPSBJZGVudGlmaWVyKCdfbXMnKVxuXG5jb25zdCBtcyA9IG5hbWUgPT4ge1xuXHRjb25zdCBtID0gbWVtYmVyKElkTXMsIG5hbWUpXG5cdHJldHVybiAoLi4uYXJncykgPT4gQ2FsbEV4cHJlc3Npb24obSwgYXJncylcbn1cbmV4cG9ydCBjb25zdFxuXHRtc0dldERlZmF1bHRFeHBvcnQgPSBtcygnZ2V0RGVmYXVsdEV4cG9ydCcpLFxuXHRtc0dldCA9IG1zKCdnZXQnKSxcblx0bXNHZXRNb2R1bGUgPSBtcygnZ2V0TW9kdWxlJyksXG5cdG1zTGF6eUdldE1vZHVsZSA9IG1zKCdsYXp5R2V0TW9kdWxlJyksXG5cdG1zQXJyID0gbXMoJ2FycicpLFxuXHRtc0Jvb2wgPSBtcygnYm9vbCcpLFxuXHRtc0V4dHJhY3QgPSBtcygnZXh0cmFjdCcpLFxuXHRtc0xzZXQgPSBtcygnbHNldCcpLFxuXHRtc1NldCA9IG1zKCdzZXQnKSxcblx0bXNNYXAgPSBtcygnbWFwJyksXG5cdG1zU2hvdyA9IG1zKCdzaG93JyksXG5cdG1zQ2hlY2tDb250YWlucyA9IG1zKCdjaGVja0NvbnRhaW5zJyksXG5cdG1zVW5sYXp5ID0gbXMoJ3VubGF6eScpLFxuXHRtc0xhenkgPSBtcygnbGF6eScpLFxuXHRtc0xhenlHZXQgPSBtcygnbGF6eVByb3AnKVxuXG5leHBvcnQgY29uc3Rcblx0bWFrZURlc3RydWN0dXJlRGVjbGFyYXRvcnMgPSAoY3gsIGxvYywgYXNzaWduZWVzLCBpc0xhenksIHZhbHVlLCBpc01vZHVsZSwgaXNFeHBvcnQpID0+IHtcblx0XHRjb25zdCBkZXN0cnVjdHVyZWROYW1lID0gYF8kJHtsb2Muc3RhcnQubGluZX1gXG5cdFx0Y29uc3QgaWREZXN0cnVjdHVyZWQgPSBJZGVudGlmaWVyKGRlc3RydWN0dXJlZE5hbWUpXG5cdFx0Y29uc3QgZGVjbGFyYXRvcnMgPSBhc3NpZ25lZXMubWFwKGFzc2lnbmVlID0+IHtcblx0XHRcdC8vIFRPRE86IERvbid0IGNvbXBpbGUgaXQgaWYgaXQncyBuZXZlciBhY2Nlc3NlZFxuXHRcdFx0Y29uc3QgZ2V0ID0gZ2V0TWVtYmVyKGN4LCBpZERlc3RydWN0dXJlZCwgYXNzaWduZWUubmFtZSwgaXNMYXp5LCBpc01vZHVsZSlcblx0XHRcdHJldHVybiBtYWtlRGVjbGFyYXRvcihjeCwgYXNzaWduZWUubG9jLCBhc3NpZ25lZSwgZ2V0LCBpc0xhenksIGlzRXhwb3J0KVxuXHRcdH0pXG5cdFx0Ly8gR2V0dGluZyBsYXp5IG1vZHVsZSBpcyBkb25lIGJ5IG1zLmxhenlHZXRNb2R1bGUuXG5cdFx0Y29uc3QgdmFsID0gKGlzTGF6eSAmJiAhaXNNb2R1bGUpID8gbGF6eVdyYXAodmFsdWUpIDogdmFsdWVcblx0XHRyZXR1cm4gdW5zaGlmdChWYXJpYWJsZURlY2xhcmF0b3IoaWREZXN0cnVjdHVyZWQsIHZhbCksIGRlY2xhcmF0b3JzKVxuXHR9LFxuXG5cdG1ha2VEZWNsYXJhdG9yID0gKGN4LCBsb2MsIGFzc2lnbmVlLCB2YWx1ZSwgdmFsdWVJc0FscmVhZHlMYXp5LCBpc0V4cG9ydCkgPT4ge1xuXHRcdC8vIFRPRE86IGFzc2VydChhc3NpZ25lZS5vcFR5cGUgPT09IG51bGwpXG5cdFx0Ly8gb3IgVE9ETzogQWxsb3cgdHlwZSBjaGVjayBvbiBsYXp5IHZhbHVlP1xuXHRcdHZhbHVlID0gYXNzaWduZWUuaXNMYXp5ID8gdmFsdWUgOlxuXHRcdFx0bWF5YmVXcmFwSW5DaGVja0NvbnRhaW5zKGN4LCB2YWx1ZSwgYXNzaWduZWUub3BUeXBlLCBhc3NpZ25lZS5uYW1lKVxuXG5cdFx0aWYgKGlzRXhwb3J0KSB7XG5cdFx0XHQvLyBUT0RPOkVTNlxuXHRcdFx0Y3guY2hlY2soIWFzc2lnbmVlLmlzTGF6eSwgYXNzaWduZWUubG9jLCAnTGF6eSBleHBvcnQgbm90IHN1cHBvcnRlZC4nKVxuXHRcdFx0cmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcihcblx0XHRcdFx0aWRGb3JEZWNsYXJlQ2FjaGVkKGFzc2lnbmVlKSxcblx0XHRcdFx0QXNzaWdubWVudEV4cHJlc3Npb24oJz0nLCBtZW1iZXIoSWRFeHBvcnRzLCBhc3NpZ25lZS5uYW1lKSwgdmFsdWUpKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB2YWwgPSBhc3NpZ25lZS5pc0xhenkgJiYgIXZhbHVlSXNBbHJlYWR5TGF6eSA/IGxhenlXcmFwKHZhbHVlKSA6IHZhbHVlXG5cdFx0XHRhc3NlcnQoYXNzaWduZWUuaXNMYXp5IHx8ICF2YWx1ZUlzQWxyZWFkeUxhenkpXG5cdFx0XHRyZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yKGlkRm9yRGVjbGFyZUNhY2hlZChhc3NpZ25lZSksIHZhbClcblx0XHR9XG5cdH0sXG5cblx0YWNjZXNzTG9jYWwgPSAobG9jYWxBY2Nlc3MsIHZyKSA9PlxuXHRcdGFjY2Vzc0xvY2FsRGVjbGFyZSh2ci5hY2Nlc3NUb0xvY2FsLmdldChsb2NhbEFjY2VzcykpLFxuXG5cdGFjY2Vzc0xvY2FsRGVjbGFyZSA9IGxvY2FsRGVjbGFyZSA9PlxuXHRcdGxvY2FsRGVjbGFyZS5pc0xhenkgP1xuXHRcdFx0bXNVbmxhenkoaWRGb3JEZWNsYXJlQ2FjaGVkKGxvY2FsRGVjbGFyZSkpIDpcblx0XHRcdGlkRm9yRGVjbGFyZU5ldyhsb2NhbERlY2xhcmUpLFxuXG5cdG1heWJlV3JhcEluQ2hlY2tDb250YWlucyA9IChjeCwgYXN0LCBvcFR5cGUsIG5hbWUpID0+XG5cdFx0KGN4Lm9wdHMuaW5jbHVkZVR5cGVDaGVja3MoKSAmJiBvcFR5cGUgIT09IG51bGwpID9cblx0XHRcdG1zQ2hlY2tDb250YWlucyh0MChvcFR5cGUpLCBhc3QsIExpdGVyYWwobmFtZSkpIDpcblx0XHRcdGFzdCxcblxuXHRvcExvY2FsQ2hlY2sgPSAoY3gsIGxvY2FsLCBpc0xhenkpID0+XG5cdFx0Ly8gVE9ETzogV2F5IHRvIHR5cGVjaGVjayBsYXppZXNcblx0XHQoIWN4Lm9wdHMuaW5jbHVkZVR5cGVDaGVja3MoKSB8fCBpc0xhenkpID8gbnVsbCA6XG5cdFx0XHRvcE1hcChsb2NhbC5vcFR5cGUsIHR5cCA9PlxuXHRcdFx0XHRFeHByZXNzaW9uU3RhdGVtZW50KG1zQ2hlY2tDb250YWlucyhcblx0XHRcdFx0XHR0MCh0eXApLFxuXHRcdFx0XHRcdGFjY2Vzc0xvY2FsRGVjbGFyZShsb2NhbCksXG5cdFx0XHRcdFx0TGl0ZXJhbChsb2NhbC5uYW1lKSkpKSxcblxuXHRsYXp5V3JhcCA9IHZhbHVlID0+IG1zTGF6eSh0aHVuayh2YWx1ZSkpLFxuXG5cdHRvU3RhdGVtZW50cyA9IF8gPT4gXyBpbnN0YW5jZW9mIEFycmF5ID8gXy5tYXAodG9TdGF0ZW1lbnQpIDogWyB0b1N0YXRlbWVudChfKSBdXG5cbmNvbnN0IGdldE1lbWJlciA9IChjeCwgYXN0T2JqZWN0LCBnb3ROYW1lLCBpc0xhenksIGlzTW9kdWxlKSA9PiB7XG5cdGlmIChpc0xhenkpXG5cdFx0cmV0dXJuIG1zTGF6eUdldChhc3RPYmplY3QsIExpdGVyYWwoZ290TmFtZSkpXG5cdGVsc2UgaWYgKGlzTW9kdWxlICYmIGN4Lm9wdHMuaW5jbHVkZVVzZUNoZWNrcygpKVxuXHRcdHJldHVybiBtc0dldChhc3RPYmplY3QsIExpdGVyYWwoZ290TmFtZSkpXG5cdGVsc2Vcblx0XHRyZXR1cm4gbWVtYmVyKGFzdE9iamVjdCwgZ290TmFtZSlcbn1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9