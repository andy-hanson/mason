if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', '../U/Bag', '../U/Op', '../U/util', './transpile', './esast-util'], function (exports, _esastDistAst, _esastDistUtil, _UBag, _UOp, _UUtil, _transpile, _esastUtil) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	const LitEmptyArray = _esastDistAst.ArrayExpression([]),
	      LitEmptyString = _esastDistAst.Literal(''),
	      LitNull = _esastDistAst.Literal(null),
	      LitStrDisplayName = _esastDistAst.Literal('displayName'),
	      Break = _esastDistAst.BreakStatement(),
	      ReturnRes = _esastDistAst.ReturnStatement(_esastDistAst.Identifier('res')),
	      IdDefine = _esastDistAst.Identifier('define'),
	      IdDisplayName = _esastDistAst.Identifier('displayName'),
	      IdExports = _esastDistAst.Identifier('exports'),
	      IdArguments = _esastDistAst.Identifier('arguments'),
	      IdArraySliceCall = _esastDistUtil.member(_esastDistUtil.member(LitEmptyArray, 'slice'), 'call'),
	      IdFunctionApplyCall = _esastDistUtil.member(_esastDistUtil.member(_esastDistAst.Identifier('Function'), 'apply'), 'call'),
	      IdModule = _esastDistAst.Identifier('module'),
	      IdMs = _esastDistAst.Identifier('_ms');

	exports.LitEmptyArray = LitEmptyArray;
	exports.LitEmptyString = LitEmptyString;
	exports.LitNull = LitNull;
	exports.LitStrDisplayName = LitStrDisplayName;
	exports.Break = Break;
	exports.ReturnRes = ReturnRes;
	exports.IdDefine = IdDefine;
	exports.IdDisplayName = IdDisplayName;
	exports.IdExports = IdExports;
	exports.IdArguments = IdArguments;
	exports.IdArraySliceCall = IdArraySliceCall;
	exports.IdFunctionApplyCall = IdFunctionApplyCall;
	exports.IdModule = IdModule;
	exports.IdMs = IdMs;
	const ms = function (name) {
		const m = _esastDistUtil.member(IdMs, name);
		return function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _esastDistAst.CallExpression(m, args);
		};
	};
	const msGetDefaultExport = ms('getDefaultExport'),
	      msGet = ms('get'),
	      msGetModule = ms('getModule'),
	      msLazyGetModule = ms('lazyGetModule'),
	      msArr = ms('arr'),
	      msBool = ms('bool'),
	      msExtract = ms('extract'),
	      msLset = ms('lset'),
	      msSet = ms('set'),
	      msMap = ms('map'),
	      msShow = ms('show'),
	      msCheckContains = ms('checkContains'),
	      msUnlazy = ms('unlazy'),
	      msLazy = ms('lazy'),
	      msLazyGet = ms('lazyProp');

	exports.msGetDefaultExport = msGetDefaultExport;
	exports.msGet = msGet;
	exports.msGetModule = msGetModule;
	exports.msLazyGetModule = msLazyGetModule;
	exports.msArr = msArr;
	exports.msBool = msBool;
	exports.msExtract = msExtract;
	exports.msLset = msLset;
	exports.msSet = msSet;
	exports.msMap = msMap;
	exports.msShow = msShow;
	exports.msCheckContains = msCheckContains;
	exports.msUnlazy = msUnlazy;
	exports.msLazy = msLazy;
	exports.msLazyGet = msLazyGet;
	const makeDestructureDeclarators = function (cx, loc, assignees, isLazy, value, k, isModule) {
		const destructuredName = '_$' + loc.start.line;
		const idDestructured = _esastDistAst.Identifier(destructuredName);
		const declarators = assignees.map(function (assignee) {
			// TODO: Don't compile it if it's never accessed
			const get = getMember(cx, idDestructured, assignee.name, isLazy, isModule);
			return makeDeclarator(cx, assignee.loc, assignee, k, get, isLazy);
		});
		// Getting lazy module is done by ms.lazyGetModule.
		const val = isLazy && !isModule ? lazyWrap(value) : value;
		return _UBag.unshift(_esastDistAst.VariableDeclarator(idDestructured, val), declarators);
	},
	      makeDeclarator = function (cx, loc, assignee, k, value, valueIsAlreadyLazy) {
		// TODO: assert(isEmpty(assignee.opType))
		// or TODO: Allow type check on lazy value?
		value = assignee.isLazy ? value : maybeWrapInCheckContains(cx, value, assignee.opType, assignee.name);
		switch (k) {
			case '=':case '. ':case '<~':case '<~~':
				{
					const val = assignee.isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value;
					_UUtil.assert(assignee.isLazy || !valueIsAlreadyLazy);
					return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), val);
				}
			case 'export':
				{
					// TODO:ES6
					_UUtil.assert(!assignee.isLazy);
					return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(assignee), _esastDistAst.AssignmentExpression('=', _esastDistUtil.member(IdExports, assignee.name), value));
				}
			default:
				throw new Error(k);
		}
	},
	      accessLocal = function (localAccess, vr) {
		return accessLocalDeclare(vr.accessToLocal.get(localAccess));
	},
	      accessLocalDeclare = function (localDeclare) {
		return localDeclare.isLazy ? msUnlazy(_esastUtil.idForDeclareCached(localDeclare)) : _esastUtil.idForDeclareNew(localDeclare);
	},
	      maybeWrapInCheckContains = function (cx, ast, opType, name) {
		return cx.opts.includeTypeChecks() ? _UOp.ifElse(opType, function (typ) {
			return msCheckContains(_transpile.t0(typ), ast, _esastDistAst.Literal(name));
		}, function () {
			return ast;
		}) : ast;
	},
	      opLocalCheck = function (cx, local, isLazy) {
		// TODO: Way to typecheck lazies
		if (!cx.opts.includeTypeChecks() || isLazy) return _UOp.None;else return local.opType.map(function (typ) {
			return _esastDistAst.ExpressionStatement(msCheckContains(_transpile.t0(typ), accessLocalDeclare(local), _esastDistAst.Literal(local.name)));
		});
	},
	      lazyWrap = function (value) {
		return msLazy(_esastDistUtil.thunk(value));
	};

	exports.makeDestructureDeclarators = makeDestructureDeclarators;
	exports.makeDeclarator = makeDeclarator;
	exports.accessLocal = accessLocal;
	exports.accessLocalDeclare = accessLocalDeclare;
	exports.maybeWrapInCheckContains = maybeWrapInCheckContains;
	exports.opLocalCheck = opLocalCheck;
	exports.lazyWrap = lazyWrap;
	const getMember = function (cx, astObject, gotName, isLazy, isModule) {
		if (isLazy) return msLazyGet(astObject, _esastDistAst.Literal(gotName));else if (isModule && cx.opts.includeUseChecks()) return msGet(astObject, _esastDistAst.Literal(gotName));else return _esastDistUtil.member(astObject, gotName);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVNPLE9BQ04sYUFBYSxHQUFHLGNBVlIsZUFBZSxDQVVTLEVBQUUsQ0FBQztPQUNuQyxjQUFjLEdBQUcsY0FWTCxPQUFPLENBVU0sRUFBRSxDQUFDO09BQzVCLE9BQU8sR0FBRyxjQVhFLE9BQU8sQ0FXRCxJQUFJLENBQUM7T0FDdkIsaUJBQWlCLEdBQUcsY0FaUixPQUFPLENBWVMsYUFBYSxDQUFDO09BQzFDLEtBQUssR0FBRyxjQWR1QyxjQUFjLEVBY3JDO09BQ3hCLFNBQVMsR0FBRyxjQWRTLGVBQWUsQ0FjUixjQWQ1QixVQUFVLENBYzZCLEtBQUssQ0FBQyxDQUFDO09BQzlDLFFBQVEsR0FBRyxjQWZYLFVBQVUsQ0FlWSxRQUFRLENBQUM7T0FDL0IsYUFBYSxHQUFHLGNBaEJoQixVQUFVLENBZ0JpQixhQUFhLENBQUM7T0FDekMsU0FBUyxHQUFHLGNBakJaLFVBQVUsQ0FpQmEsU0FBUyxDQUFDO09BQ2pDLFdBQVcsR0FBRyxjQWxCZCxVQUFVLENBa0JlLFdBQVcsQ0FBQztPQUNyQyxnQkFBZ0IsR0FBRyxlQWxCWCxNQUFNLENBa0JZLGVBbEJsQixNQUFNLENBa0JtQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDO09BQ2pFLG1CQUFtQixHQUFHLGVBbkJkLE1BQU0sQ0FtQmUsZUFuQnJCLE1BQU0sQ0FtQnNCLGNBcEJwQyxVQUFVLENBb0JxQyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUM7T0FDN0UsUUFBUSxHQUFHLGNBckJYLFVBQVUsQ0FxQlksUUFBUSxDQUFDO09BQy9CLElBQUksR0FBRyxjQXRCUCxVQUFVLENBc0JRLEtBQUssQ0FBQyxDQUFBOztTQWJ4QixhQUFhLEdBQWIsYUFBYTtTQUNiLGNBQWMsR0FBZCxjQUFjO1NBQ2QsT0FBTyxHQUFQLE9BQU87U0FDUCxpQkFBaUIs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QUFLLENBQUMsRUFDekIsY0F4R1MsT0FBTyxDQXdHUixLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUFBLENBQUMsQ0FBQTtFQUN4QjtPQUVELFFBQVEsR0FBRyxVQUFBLEtBQUs7U0FBSSxNQUFNLENBQUMsZUExR1gsS0FBSyxDQTBHWSxLQUFLLENBQUMsQ0FBQztFQUFBLENBQUE7O1NBN0R4QywwQkFBMEIsR0FBMUIsMEJBQTBCO1NBYTFCLGNBQWMsR0FBZCxjQUFjO1NBc0JkLFdBQVcsR0FBWCxXQUFXO1NBR1gsa0JBQWtCLEdBQWxCLGtCQUFrQjtTQUtsQix3QkFBd0IsR0FBeEIsd0JBQXdCO1NBT3hCLFlBQVksR0FBWixZQUFZO1NBV1osUUFBUSxHQUFSLFFBQVE7QUFFVCxPQUFNLFNBQVMsR0FBRyxVQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUs7QUFDL0QsTUFBSSxNQUFNLEVBQ1QsT0FBTyxTQUFTLENBQUMsU0FBUyxFQUFFLGNBL0dqQixPQUFPLENBK0drQixPQUFPLENBQUMsQ0FBQyxDQUFBLEtBQ3pDLElBQUksUUFBUSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFDOUMsT0FBTyxLQUFLLENBQUMsU0FBUyxFQUFFLGNBakhiLE9BQU8sQ0FpSGMsT0FBTyxDQUFDLENBQUMsQ0FBQSxLQUV6QyxPQUFPLGVBbEhBLE1BQU0sQ0FrSEMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO0VBQ2xDLENBQUEiLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvdHJhbnNwaWxlL3V0aWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcnJheUV4cHJlc3Npb24sIEFzc2lnbm1lbnRFeHByZXNzaW9uLCBCcmVha1N0YXRlbWVudCwgQ2FsbEV4cHJlc3Npb24sIEV4cHJlc3Npb25TdGF0ZW1lbnQsXG5cdElkZW50aWZpZXIsIExpdGVyYWwsIFJldHVyblN0YXRlbWVudCwgVmFyaWFibGVEZWNsYXJhdG9yIH0gZnJvbSAnZXNhc3QvZGlzdC9hc3QnXG5pbXBvcnQgeyBtZW1iZXIsIHRodW5rIH0gZnJvbSAnZXNhc3QvZGlzdC91dGlsJ1xuaW1wb3J0IHsgdW5zaGlmdCB9IGZyb20gJy4uL1UvQmFnJ1xuaW1wb3J0IHsgaWZFbHNlLCBOb25lIH0gZnJvbSAnLi4vVS9PcCdcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCB7IHQwIH0gZnJvbSAnLi90cmFuc3BpbGUnXG5pbXBvcnQgeyBpZEZvckRlY2xhcmVDYWNoZWQsIGlkRm9yRGVjbGFyZU5ldyB9IGZyb20gJy4vZXNhc3QtdXRpbCdcblxuZXhwb3J0IGNvbnN0XG5cdExpdEVtcHR5QXJyYXkgPSBBcnJheUV4cHJlc3Npb24oW10pLFxuXHRMaXRFbXB0eVN0cmluZyA9IExpdGVyYWwoJycpLFxuXHRMaXROdWxsID0gTGl0ZXJhbChudWxsKSxcblx0TGl0U3RyRGlzcGxheU5hbWUgPSBMaXRlcmFsKCdkaXNwbGF5TmFtZScpLFxuXHRCcmVhayA9IEJyZWFrU3RhdGVtZW50KCksXG5cdFJldHVyblJlcyA9IFJldHVyblN0YXRlbWVudChJZGVudGlmaWVyKCdyZXMnKSksXG5cdElkRGVmaW5lID0gSWRlbnRpZmllcignZGVmaW5lJyksXG5cdElkRGlzcGxheU5hbWUgPSBJZGVudGlmaWVyKCdkaXNwbGF5TmFtZScpLFxuXHRJZEV4cG9ydHMgPSBJZGVudGlmaWVyKCdleHBvcnRzJyksXG5cdElkQXJndW1lbnRzID0gSWRlbnRpZmllcignYXJndW1lbnRzJyksXG5cdElkQXJyYXlTbGljZUNhbGwgPSBtZW1iZXIobWVtYmVyKExpdEVtcHR5QXJyYXksICdzbGljZScpLCAnY2FsbCcpLFxuXHRJZEZ1bmN0aW9uQXBwbHlDYWxsID0gbWVtYmVyKG1lbWJlcihJZGVudGlmaWVyKCdGdW5jdGlvbicpLCAnYXBwbHknKSwgJ2NhbGwnKSxcblx0SWRNb2R1bGUgPSBJZGVudGlmaWVyKCdtb2R1bGUnKSxcblx0SWRNcyA9IElkZW50aWZpZXIoJ19tcycpXG5cbmNvbnN0IG1zID0gbmFtZSA9PiB7XG5cdGNvbnN0IG0gPSBtZW1iZXIoSWRNcywgbmFtZSlcblx0cmV0dXJuICguLi5hcmdzKSA9PiBDYWxsRXhwcmVzc2lvbihtLCBhcmdzKVxufVxuZXhwb3J0IGNvbnN0XG5cdG1zR2V0RGVmYXVsdEV4cG9ydCA9IG1zKCdnZXREZWZhdWx0RXhwb3J0JyksXG5cdG1zR2V0ID0gbXMoJ2dldCcpLFxuXHRtc0dldE1vZHVsZSA9IG1zKCdnZXRNb2R1bGUnKSxcblx0bXNMYXp5R2V0TW9kdWxlID0gbXMoJ2xhenlHZXRNb2R1bGUnKSxcblx0bXNBcnIgPSBtcygnYXJyJyksXG5cdG1zQm9vbCA9IG1zKCdib29sJyksXG5cdG1zRXh0cmFjdCA9IG1zKCdleHRyYWN0JyksXG5cdG1zTHNldCA9IG1zKCdsc2V0JyksXG5cdG1zU2V0ID0gbXMoJ3NldCcpLFxuXHRtc01hcCA9IG1zKCdtYXAnKSxcblx0bXNTaG93ID0gbXMoJ3Nob3cnKSxcblx0bXNDaGVja0NvbnRhaW5zID0gbXMoJ2NoZWNrQ29udGFpbnMnKSxcblx0bXNVbmxhenkgPSBtcygndW5sYXp5JyksXG5cdG1zTGF6eSA9IG1zKCdsYXp5JyksXG5cdG1zTGF6eUdldCA9IG1zKCdsYXp5UHJvcCcpXG5cbmV4cG9ydCBjb25zdFxuXHRtYWtlRGVzdHJ1Y3R1cmVEZWNsYXJhdG9ycyA9IChjeCwgbG9jLCBhc3NpZ25lZXMsIGlzTGF6eSwgdmFsdWUsIGssIGlzTW9kdWxlKSA9PiB7XG5cdFx0Y29uc3QgZGVzdHJ1Y3R1cmVkTmFtZSA9IGBfJCR7bG9jLnN0YXJ0LmxpbmV9YFxuXHRcdGNvbnN0IGlkRGVzdHJ1Y3R1cmVkID0gSWRlbnRpZmllcihkZXN0cnVjdHVyZWROYW1lKVxuXHRcdGNvbnN0IGRlY2xhcmF0b3JzID0gYXNzaWduZWVzLm1hcChhc3NpZ25lZSA9PiB7XG5cdFx0XHQvLyBUT0RPOiBEb24ndCBjb21waWxlIGl0IGlmIGl0J3MgbmV2ZXIgYWNjZXNzZWRcblx0XHRcdGNvbnN0IGdldCA9IGdldE1lbWJlcihjeCwgaWREZXN0cnVjdHVyZWQsIGFzc2lnbmVlLm5hbWUsIGlzTGF6eSwgaXNNb2R1bGUpXG5cdFx0XHRyZXR1cm4gbWFrZURlY2xhcmF0b3IoY3gsIGFzc2lnbmVlLmxvYywgYXNzaWduZWUsIGssIGdldCwgaXNMYXp5KVxuXHRcdH0pXG5cdFx0Ly8gR2V0dGluZyBsYXp5IG1vZHVsZSBpcyBkb25lIGJ5IG1zLmxhenlHZXRNb2R1bGUuXG5cdFx0Y29uc3QgdmFsID0gKGlzTGF6eSAmJiAhaXNNb2R1bGUpID8gbGF6eVdyYXAodmFsdWUpIDogdmFsdWVcblx0XHRyZXR1cm4gdW5zaGlmdChWYXJpYWJsZURlY2xhcmF0b3IoaWREZXN0cnVjdHVyZWQsIHZhbCksIGRlY2xhcmF0b3JzKVxuXHR9LFxuXG5cdG1ha2VEZWNsYXJhdG9yID0gKGN4LCBsb2MsIGFzc2lnbmVlLCBrLCB2YWx1ZSwgdmFsdWVJc0FscmVhZHlMYXp5KSA9PiB7XG5cdFx0Ly8gVE9ETzogYXNzZXJ0KGlzRW1wdHkoYXNzaWduZWUub3BUeXBlKSlcblx0XHQvLyBvciBUT0RPOiBBbGxvdyB0eXBlIGNoZWNrIG9uIGxhenkgdmFsdWU/XG5cdFx0dmFsdWUgPSBhc3NpZ25lZS5pc0xhenkgPyB2YWx1ZSA6XG5cdFx0XHRtYXliZVdyYXBJbkNoZWNrQ29udGFpbnMoY3gsIHZhbHVlLCBhc3NpZ25lZS5vcFR5cGUsIGFzc2lnbmVlLm5hbWUpXG5cdFx0c3dpdGNoIChrKSB7XG5cdFx0XHRjYXNlICc9JzogY2FzZSAnLiAnOiBjYXNlICc8fic6IGNhc2UgJzx+fic6IHtcblx0XHRcdFx0Y29uc3QgdmFsID0gYXNzaWduZWUuaXNMYXp5ICYmICF2YWx1ZUlzQWxyZWFkeUxhenkgPyBsYXp5V3JhcCh2YWx1ZSkgOiB2YWx1ZVxuXHRcdFx0XHRhc3NlcnQoYXNzaWduZWUuaXNMYXp5IHx8ICF2YWx1ZUlzQWxyZWFkeUxhenkpXG5cdFx0XHRcdHJldHVybiBWYXJpYWJsZURlY2xhcmF0b3IoaWRGb3JEZWNsYXJlQ2FjaGVkKGFzc2lnbmVlKSwgdmFsKVxuXHRcdFx0fVxuXHRcdFx0Y2FzZSAnZXhwb3J0Jzoge1xuXHRcdFx0XHQvLyBUT0RPOkVTNlxuXHRcdFx0XHRhc3NlcnQoIWFzc2lnbmVlLmlzTGF6eSlcblx0XHRcdFx0cmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcihcblx0XHRcdFx0XHRpZEZvckRlY2xhcmVDYWNoZWQoYXNzaWduZWUpLFxuXHRcdFx0XHRcdEFzc2lnbm1lbnRFeHByZXNzaW9uKCc9JywgbWVtYmVyKElkRXhwb3J0cywgYXNzaWduZWUubmFtZSksIHZhbHVlKSlcblx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihrKVxuXHRcdH1cblx0fSxcblxuXHRhY2Nlc3NMb2NhbCA9IChsb2NhbEFjY2VzcywgdnIpID0+XG5cdFx0YWNjZXNzTG9jYWxEZWNsYXJlKHZyLmFjY2Vzc1RvTG9jYWwuZ2V0KGxvY2FsQWNjZXNzKSksXG5cblx0YWNjZXNzTG9jYWxEZWNsYXJlID0gbG9jYWxEZWNsYXJlID0+XG5cdFx0bG9jYWxEZWNsYXJlLmlzTGF6eSA/XG5cdFx0XHRtc1VubGF6eShpZEZvckRlY2xhcmVDYWNoZWQobG9jYWxEZWNsYXJlKSkgOlxuXHRcdFx0aWRGb3JEZWNsYXJlTmV3KGxvY2FsRGVjbGFyZSksXG5cblx0bWF5YmVXcmFwSW5DaGVja0NvbnRhaW5zID0gKGN4LCBhc3QsIG9wVHlwZSwgbmFtZSkgPT5cblx0XHRjeC5vcHRzLmluY2x1ZGVUeXBlQ2hlY2tzKCkgP1xuXHRcdFx0aWZFbHNlKG9wVHlwZSxcblx0XHRcdFx0dHlwID0+IG1zQ2hlY2tDb250YWlucyh0MCh0eXApLCBhc3QsIExpdGVyYWwobmFtZSkpLFxuXHRcdFx0XHQoKSA9PiBhc3QpIDpcblx0XHRcdGFzdCxcblxuXHRvcExvY2FsQ2hlY2sgPSAoY3gsIGxvY2FsLCBpc0xhenkpID0+IHtcblx0XHQvLyBUT0RPOiBXYXkgdG8gdHlwZWNoZWNrIGxhemllc1xuXHRcdGlmICghY3gub3B0cy5pbmNsdWRlVHlwZUNoZWNrcygpIHx8IGlzTGF6eSlcblx0XHRcdHJldHVybiBOb25lXG5cdFx0ZWxzZSByZXR1cm4gbG9jYWwub3BUeXBlLm1hcCh0eXAgPT5cblx0XHRcdEV4cHJlc3Npb25TdGF0ZW1lbnQobXNDaGVja0NvbnRhaW5zKFxuXHRcdFx0XHR0MCh0eXApLFxuXHRcdFx0XHRhY2Nlc3NMb2NhbERlY2xhcmUobG9jYWwpLFxuXHRcdFx0XHRMaXRlcmFsKGxvY2FsLm5hbWUpKSkpXG5cdH0sXG5cblx0bGF6eVdyYXAgPSB2YWx1ZSA9PiBtc0xhenkodGh1bmsodmFsdWUpKVxuXG5jb25zdCBnZXRNZW1iZXIgPSAoY3gsIGFzdE9iamVjdCwgZ290TmFtZSwgaXNMYXp5LCBpc01vZHVsZSkgPT4ge1xuXHRpZiAoaXNMYXp5KVxuXHRcdHJldHVybiBtc0xhenlHZXQoYXN0T2JqZWN0LCBMaXRlcmFsKGdvdE5hbWUpKVxuXHRlbHNlIGlmIChpc01vZHVsZSAmJiBjeC5vcHRzLmluY2x1ZGVVc2VDaGVja3MoKSlcblx0XHRyZXR1cm4gbXNHZXQoYXN0T2JqZWN0LCBMaXRlcmFsKGdvdE5hbWUpKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG1lbWJlcihhc3RPYmplY3QsIGdvdE5hbWUpXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==