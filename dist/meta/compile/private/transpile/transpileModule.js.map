{"version":3,"sources":["meta/compile/private/transpile/transpileModule.js"],"names":[],"mappings":"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","file":"meta/compile/private/transpile/transpileModule.js","sourcesContent":["import { ArrayExpression, BinaryExpression, BlockStatement, CallExpression, Identifier,\n\tExpressionStatement, FunctionExpression, IfStatement, Literal, ObjectExpression, Program,\n\tReturnStatement, UnaryExpression, VariableDeclaration, VariableDeclarator\n\t} from 'esast/dist/ast'\nimport { idCached, member } from 'esast/dist/util'\nimport { assignmentExpressionPlain } from 'esast/dist/specialize'\nimport manglePath from '../manglePath'\nimport { flatMap, isEmpty, last } from '../U/Bag'\nimport { None, opIf } from '../U/Op'\nimport { idForDeclareCached } from './esast-util'\nimport { t } from './transpile'\nimport { IdDefine, IdExports, IdModule, lazyWrap,\n\tmsGetModule, msLazyGetModule, msGetDefaultExport,\n\tmakeDestructureDeclarators, msLazy } from './util'\n\n/*\n'use strict';\nif (typeof define !== 'function')\n\tvar define = require('amdefine')(module);\ndefine(['exports', 'a', 'b', 'c'], function(exports) {\n\t// Fake exports -- just a getter.\n\texports._get = _ms.lazy(function() {\n\t\tconst exports = {} // Real exports\n\t\t... imports ...\n\t\t{\n\t\t\t... exports ...\n\t\t}\n\t\treturn exports\n\t})\n})\n*/\nexport default (_, cx) => {\n\tconst allUses = _.doUses.concat(_.uses, _.debugUses)\n\tconst amdNames = ArrayExpression(AmdFirstUses.concat(\n\t\tallUses.map(use => Literal(manglePath(use.path)))))\n\tconst useIdentifiers = allUses.map(useIdentifier)\n\tconst amdArgs = AmdFirstArgs.concat(useIdentifiers)\n\tconst useDos = _.doUses.map((use, i) => {\n\t\tconst d = ExpressionStatement(msGetModule([ useIdentifiers[i] ]))\n\t\td.loc = use.loc\n\t\treturn d\n\t})\n\tconst allUseDeclarators = flatMap(_.uses.concat(_.debugUses), (use, i) =>\n\t\tuseDeclarators(cx, use, useIdentifiers[i + _.doUses.length]))\n\tconst opUseDeclare = opIf(!isEmpty(allUseDeclarators),\n\t\t() => VariableDeclaration('const', allUseDeclarators))\n\n\t// TODO: Some way of determining when it's OK for a module to not be lazy.\n\tconst isLazy = cx.opts.lazyModule()\n\n\tconst lead = useDos.concat(opUseDeclare, opIf(isLazy, () => DeclareExports))\n\tconst trail = [ ReturnStatement(IdExports) ]\n\tconst moduleBody = t(_.block, lead, None, trail)\n\tconst body =\n\t\tisLazy ?\n\t\t\tBlockStatement([ lazyBody(moduleBody) ])\n\t\t\t: moduleBody\n\n\tconst doDefine = ExpressionStatement(\n\t\tCallExpression(IdDefine, [\n\t\t\tamdNames,\n\t\t\tFunctionExpression(null, amdArgs, body) ]))\n\n\treturn Program([ UseStrict ].concat(\n\t\topIf(cx.opts.amdefine(), () => AmdefineHeader),\n\t\t[ doDefine ]))\n}\n\nconst useDeclarators = (cx, _, moduleIdentifier) => {\n\t// TODO: Could be neater about this\n\tconst isLazy = (isEmpty(_.used) ? _.opUseDefault[0] : _.used[0]).isLazy\n\tconst value = (isLazy ? msLazyGetModule : msGetModule)([ moduleIdentifier ])\n\n\tconst usedDefault = _.opUseDefault.map(def => {\n\t\tconst defexp = msGetDefaultExport([ moduleIdentifier ])\n\t\tconst val = isLazy ? lazyWrap(defexp) : defexp\n\t\tconst vd = VariableDeclarator(idForDeclareCached(def), val)\n\t\tvd.loc = def.loc\n\t\treturn vd\n\t})\n\n\tconst usedDestruct = isEmpty(_.used) ? [] :\n\t\tmakeDestructureDeclarators(cx, _.loc, _.used, isLazy, value, '=', true)\n\tusedDestruct.forEach(_ => _.loc = _.loc)\n\n\treturn usedDefault.concat(usedDestruct)\n}\n\nconst\n\tuseIdentifier = (use, i) => idCached(`${last(use.path.split('/'))}_${i}`),\n\n\t// const exports = { }\n\tDeclareExports = VariableDeclaration('const', [\n\t\tVariableDeclarator(IdExports, ObjectExpression([]))]),\n\n\tlazyBody = body =>\n\t\tExpressionStatement(\n\t\t\tassignmentExpressionPlain(member(IdExports, '_get'), msLazy([\n\t\t\t\tFunctionExpression(null, [ ], body)]))),\n\n\t// if (typeof define !== 'function') var define = require('amdefine')(module)\n\tAmdefineHeader = IfStatement(\n\t\tBinaryExpression('!==', UnaryExpression('typeof', IdDefine), Literal('function')),\n\t\tVariableDeclaration('var', [\n\t\t\tVariableDeclarator(IdDefine, CallExpression(\n\t\t\t\tCallExpression(Identifier('require'), [ Literal('amdefine') ]),\n\t\t\t\t[ IdModule ])) ])),\n\n\tUseStrict = ExpressionStatement(Literal('use strict')),\n\n\tAmdFirstUses = [ Literal('exports') ],\n\tAmdFirstArgs = [ IdExports ]\n"],"sourceRoot":"/src"}