{"version":3,"sources":["meta/compile/private/transpile/util.js"],"names":[],"mappings":"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","file":"meta/compile/private/transpile/util.js","sourcesContent":["import { ArrayExpression, AssignmentExpression, BreakStatement, CallExpression, ExpressionStatement,\n\tIdentifier, Literal, ReturnStatement, VariableDeclarator } from 'esast/dist/ast'\nimport Loc from 'esast/dist/Loc'\nimport { member, thunk } from 'esast/dist/util'\nimport Expression, { LocalAccess, LocalDeclare } from '../../Expression'\nimport { KAssign } from '../Lang'\nimport { unshift } from '../U/Bag'\nimport { ifElse, None } from '../U/Op'\nimport type from '../U/type'\nimport { assert } from '../U/util'\nimport Vr from '../Vr'\nimport { t } from './transpile'\nimport { idForDeclareCached, idForDeclareNew } from './esast-util'\n\nexport const\n\tLitEmptyArray = ArrayExpression([]),\n\tLitEmptyString = Literal(''),\n\tLitNull = Literal(null),\n\tLitStrDisplayName = Literal('displayName'),\n\tBreak = BreakStatement(),\n\tReturnRes = ReturnStatement(Identifier('res')),\n\tIdDefine = Identifier('define'),\n\tIdDisplayName = Identifier('displayName'),\n\tIdExports = Identifier('exports'),\n\tIdArguments = Identifier('arguments'),\n\tIdArraySliceCall = member(member(LitEmptyArray, 'slice'), 'call'),\n\tIdFunctionApplyCall = member(member(Identifier('Function'), 'apply'), 'call'),\n\tIdModule = Identifier('module'),\n\tIdMs = Identifier('_ms')\n\nconst ms = name => {\n\tconst m = member(IdMs, name)\n\treturn args => CallExpression(m, args)\n}\nexport const\n\tmsGetDefaultExport = ms('getDefaultExport'),\n\tmsGet = ms('get'),\n\tmsGetModule = ms('getModule'),\n\tmsLazyGetModule = ms('lazyGetModule'),\n\tmsArr = ms('arr'),\n\tmsBool = ms('bool'),\n\tmsLset = ms('lset'),\n\tmsSet = ms('set'),\n\tmsMap = ms('map'),\n\tmsShow = ms('show'),\n\tmsCheckContains = ms('checkContains'),\n\tmsUnlazy = ms('unlazy'),\n\tmsLazy = ms('lazy'),\n\tmsLazyGet = ms('lazyProp')\n\nexport const makeDestructureDeclarators = (cx, loc, assignees, isLazy, value, k, isModule) => {\n\ttype(loc, Loc, assignees, [LocalDeclare],\n\t\tisLazy, Boolean, value, Object, k, KAssign, isModule, Boolean)\n\tconst destructuredName = `_$${loc.start.line}`\n\tconst idDestructured = Identifier(destructuredName)\n\tconst declarators = assignees.map(assignee => {\n\t\t// TODO: Don't compile it if it's never accessed\n\t\tconst get = getMember(cx, idDestructured, assignee.name, isLazy, isModule)\n\t\treturn makeDeclarator(cx, assignee.loc, assignee, k, get, isLazy)\n\t})\n\t// Getting lazy module is done by ms.lazyGetModule.\n\tconst val = (isLazy && !isModule) ? lazyWrap(value) : value\n\treturn unshift(VariableDeclarator(idDestructured, val), declarators)\n}\n\nconst getMember = (cx, astObject, gotName, isLazy, isModule) => {\n\ttype(astObject, Object, gotName, String, isLazy, Boolean, isModule, Boolean)\n\tif (isLazy)\n\t\treturn msLazyGet([ astObject, Literal(gotName) ])\n\telse if (isModule && cx.opts.includeUseChecks())\n\t\treturn msGet([ astObject, Literal(gotName) ])\n\telse\n\t\treturn member(astObject, gotName)\n}\n\nexport const makeDeclarator = (cx, loc, assignee, k, value, valueIsAlreadyLazy) => {\n\ttype(loc, Loc, assignee, Expression, k, KAssign, value, Object)\n\t// TODO: assert(isEmpty(assignee.opType))\n\t// or TODO: Allow type check on lazy value?\n\tvalue = assignee.isLazy ? value :\n\t\tmaybeWrapInCheckContains(cx, value, assignee.opType, assignee.name)\n\tswitch (k) {\n\t\tcase '=': case '. ': case '<~': case '<~~': {\n\t\t\tconst val = assignee.isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value\n\t\t\tassert(assignee.isLazy || !valueIsAlreadyLazy)\n\t\t\treturn VariableDeclarator(idForDeclareCached(assignee), val)\n\t\t}\n\t\tcase 'export': {\n\t\t\t// TODO:ES6\n\t\t\tassert(!assignee.isLazy)\n\t\t\treturn VariableDeclarator(\n\t\t\t\tidForDeclareCached(assignee),\n\t\t\t\tAssignmentExpression('=', member(IdExports, assignee.name), value))\n\t\t}\n\t\tdefault: throw new Error(k)\n\t}\n}\n\nexport const accessLocal = (localAccess, vr) => {\n\ttype(localAccess, LocalAccess, vr, Vr)\n\treturn accessLocalDeclare(vr.accessToLocal.get(localAccess))\n}\nexport const accessLocalDeclare = localDeclare => {\n\ttype(localDeclare, LocalDeclare)\n\treturn localDeclare.isLazy ?\n\t\tmsUnlazy([ idForDeclareCached(localDeclare) ]) :\n\t\tidForDeclareNew(localDeclare)\n}\n\nexport const maybeWrapInCheckContains = (cx, ast, opType, name) =>\n\tcx.opts.includeTypeChecks() ?\n\t\tifElse(opType,\n\t\t\ttyp => msCheckContains([ t(typ), ast, Literal(name) ]),\n\t\t\t() => ast) :\n\t\tast\n\nexport const opLocalCheck = (cx, local, isLazy) => {\n\ttype(local, LocalDeclare, isLazy, Boolean)\n\t// TODO: Way to typecheck lazies\n\tif (!cx.opts.includeTypeChecks() || isLazy)\n\t\treturn None\n\telse return local.opType.map(typ =>\n\t\tExpressionStatement(msCheckContains([\n\t\t\tt(typ),\n\t\t\taccessLocalDeclare(local),\n\t\t\tLiteral(local.name)])))\n}\n\nexport const lazyWrap = value => msLazy([ thunk(value) ])\n"],"sourceRoot":"/src"}