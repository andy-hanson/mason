if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', 'esast/dist/specialize', '../../Expression', '../U/Bag', '../U/Op', '../U/util', './esast-util', './transpileModule', './util'], function (exports, _esastDistAst, _esastDistUtil, _esastDistSpecialize, _Expression, _UBag, _UOp, _UUtil, _esastUtil, _transpileModule, _util) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	exports.default = transpile;

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _transpileModule2 = _interopRequire(_transpileModule);

	const ExtractVar = _esastDistAst.Identifier('_$');

	let cx, vr, isInGenerator;

	function transpile(_cx, e, _vr) {
		cx = _cx;
		vr = _vr;
		isInGenerator = false;
		const res = t0(e);
		// Release for garbage collection
		cx = vr = undefined;
		return res;
	}

	const t0 = function (expr) {
		const ast = expr.transpileSubtree();
		ast.loc = expr.loc;
		return ast;
	};
	exports.t0 = t0;
	const t1 = function (expr, arg) {
		const ast = expr.transpileSubtree(arg);
		ast.loc = expr.loc;
		return ast;
	};
	const t3 = function (expr, arg, arg2, arg3) {
		const ast = expr.transpileSubtree(arg, arg2, arg3);
		ast.loc = expr.loc;
		return ast;
	};
	exports.t3 = t3;
	const tm = function (expr) {
		const ast = expr.transpileSubtree();
		if (!(ast instanceof Array))
			// Debug may produce multiple statements.
			ast.loc = expr.loc;
		return ast;
	};

	exports.tm = tm;
	function transpileBlock(lead, opResDeclare, opOut) {
		var _this = this;

		if (lead === undefined) lead = [];
		if (opResDeclare === undefined) opResDeclare = opOut = _UOp.None;
		const body = _UBag.flatMap(this.lines, function (line) {
			return _util.toStatements(tm(line));
		});
		const isVal = this instanceof _Expression.BlockVal;
		const fin = _UOp.ifElse(opResDeclare, function (rd) {
			_UUtil.assert(isVal);
			const returned = _util.maybeWrapInCheckContains(cx, t0(_this.returned), rd.opType, 'res');
			return _UOp.ifElse(opOut, function (o) {
				return [_esastUtil.declare(rd, returned)].concat(o, [_util.ReturnRes]);
			}, function () {
				return [_esastDistAst.ReturnStatement(returned)];
			});
		}, function () {
			return opOut.concat(_UOp.opIf(isVal, function () {
				return _esastDistAst.ReturnStatement(t0(_this.returned));
			}));
		});
		return _esastDistAst.BlockStatement(lead.concat(body, fin));
	}

	function casePart(alternate) {
		if (this.test instanceof _Expression.Pattern) {
			const decl = _esastDistSpecialize.variableDeclarationConst([_esastDistAst.VariableDeclarator(ExtractVar, _util.msExtract(t0(this.test.type), t0(this.test.patterned)))]);
			const test = _esastUtil.binaryExpressionNotEqual(ExtractVar, _esastDistAst.Literal(null));
			const ext = arrayExtract(this.test.locals);
			const res = t3(this.result, [ext]);
			return _esastDistAst.BlockStatement([decl, _esastDistAst.IfStatement(test, res, alternate)]);
		} else {
			const checkedTest = cx.opts.includeCaseChecks() ? _util.msBool(t0(this.test)) : t0(this.test);
			// alternate written to by `caseBody`.
			return _esastDistAst.IfStatement(checkedTest, t0(this.result), alternate);
		}
	}

	_UUtil.implementMany(_Expression, 'transpileSubtree', {
		Assign: function () {
			return _esastDistSpecialize.variableDeclarationConst([_util.makeDeclarator(cx, this.loc, this.assignee, t0(this.value), false, vr.isExportAssign(this))]);
		},
		// TODO:ES6 Just use native destructuring assign
		AssignDestructure: function () {
			return _esastDistSpecialize.variableDeclarationConst(_util.makeDestructureDeclarators(cx, this.loc, this.assignees, this.isLazy, t0(this.value), false, vr.isExportAssign(this)));
		},
		BlockDo: transpileBlock,
		BlockVal: transpileBlock,
		BlockWrap: function () {
			return blockWrap(this, t0(this.block));
		},
		Call: function () {
			const anySplat = this.args.some(function (arg) {
				return arg instanceof _Expression.Splat;
			});
			if (anySplat) {
				const args = this.args.map(function (arg) {
					return arg instanceof _Expression.Splat ? _util.msArr(t0(arg.splatted)) : t0(arg);
				});
				return _esastDistAst.CallExpression(_util.IdFunctionApplyCall, [t0(this.called), _util.LitNull, _esastDistAst.CallExpression(_esastDistUtil.member(_util.LitEmptyArray, 'concat'), args)]);
			} else return _esastDistAst.CallExpression(t0(this.called), this.args.map(t0));
		},
		CaseDo: function () {
			const body = caseBody(this.parts, this.opElse);
			return _UOp.ifElse(this.opCased, function (cased) {
				return _esastDistAst.BlockStatement([t0(cased), body]);
			}, function () {
				return body;
			});
		},
		CaseVal: function () {
			const body = caseBody(this.parts, this.opElse);
			const block = _UOp.ifElse(this.opCased, function (cased) {
				return [t0(cased), body];
			}, function () {
				return [body];
			});
			return blockWrap(this, _esastDistAst.BlockStatement(block));
		},
		CaseDoPart: casePart,
		CaseValPart: casePart,
		// TODO: includeInoutChecks is misnamed
		Debug: function () {
			return cx.opts.includeInoutChecks() ? _UBag.flatMap(this.lines, function (line) {
				return _util.toStatements(t0(line));
			}) : [];
		},
		ObjReturn: function () {
			var _this2 = this;

			// TODO: includeTypeChecks() is not the right method for this
			const keys = cx.opts.includeTypeChecks() ? this.keys : this.keys.filter(function (_) {
				return !vr.isDebugLocal(_);
			});
			return _UOp.ifElse(this.opObjed, function (objed) {
				const astObjed = t0(objed);
				const keysVals = _UBag.cat(_UBag.flatMap(keys, function (key) {
					return [_esastDistAst.Literal(key.name), _util.accessLocalDeclare(key)];
				}), _UBag.flatMap(_this2.opDisplayName, function (dn) {
					return [_util.LitStrDisplayName, _esastDistAst.Literal(dn)];
				}));
				const anyLazy = keys.some(function (key) {
					return key.isLazy;
				});
				return (anyLazy ? _util.msLset : _util.msSet).apply(undefined, [astObjed].concat(_toConsumableArray(keysVals)));
			}, function () {
				const props = keys.map(function (key) {
					const val = _util.accessLocalDeclare(key);
					const id = _esastDistUtil.propertyIdOrLiteralCached(key.name);
					return key.isLazy ? _esastDistSpecialize.property('get', id, _esastDistUtil.thunk(val)) : _esastDistSpecialize.property('init', id, val);
				});
				const opPropDisplayName = _this2.opDisplayName.map(function (dn) {
					return _esastDistSpecialize.property('init', _util.IdDisplayName, _esastDistAst.Literal(dn));
				});
				return _esastDistAst.ObjectExpression(_UBag.cat(props, opPropDisplayName));
			});
		},
		ObjSimple: function () {
			return _esastDistAst.ObjectExpression(this.pairs.map(function (pair) {
				return _esastDistSpecialize.property('init', _esastDistUtil.propertyIdOrLiteralCached(pair.key), t0(pair.value));
			}));
		},
		EndLoop: function () {
			return _esastDistAst.BreakStatement(loopId(vr.endLoopToLoop.get(this)));
		},
		Fun: function () {
			const oldInGenerator = isInGenerator;
			isInGenerator = this.isGenerator;

			// TODO:ES6 use `...`
			const nArgs = _esastDistAst.Literal(this.args.length);
			const opDeclareRest = this.opRestArg.map(function (rest) {
				return _esastUtil.declare(rest, _esastDistAst.CallExpression(_util.IdArraySliceCall, [_util.IdArguments, nArgs]));
			});
			const argChecks = _UBag.flatMap(this.args, function (arg) {
				return _util.opLocalCheck(cx, arg, arg.isLazy);
			});
			const _in = _UBag.flatMap(this.opIn, t0);
			const lead = opDeclareRest.concat(argChecks, _in);

			const _out = this.opOut.map(t0);
			const body = t3(this.block, lead, this.opResDeclare, _out);
			const args = this.args.map(t0);
			const res = _esastDistSpecialize.functionExpressionPlain(args, body, this.isGenerator);

			isInGenerator = oldInGenerator;
			return res;
		},
		Lazy: function () {
			return _util.lazyWrap(t0(this.value));
		},
		ListReturn: function () {
			const length = vr.listMapLength(this);
			_UUtil.assert(length >= 0);
			return _esastDistAst.ArrayExpression(_UBag.range(0, length).map(function (i) {
				return _esastDistUtil.idCached('_' + i);
			}));
		},
		ListSimple: function () {
			return _esastDistAst.ArrayExpression(this.parts.map(t0));
		},
		ListEntry: function () {
			return _esastUtil.declareSpecial('_' + vr.listMapEntryIndex(this), t0(this.value));
		},
		NumberLiteral: function () {
			// Negative numbers are not part of ES spec.
			// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3
			const lit = _esastDistAst.Literal(Math.abs(this.value));
			return _UUtil.isPositive(this.value) ? lit : _esastUtil.unaryExpressionNegate(lit);
		},
		GlobalAccess: function () {
			return _esastDistAst.Identifier(this.name);
		},
		LocalAccess: function () {
			return _util.accessLocal(this, vr);
		},
		LocalDeclare: function () {
			return _esastUtil.idForDeclareCached(this);
		},
		// TODO: Don't always label!
		Loop: function () {
			return _esastDistAst.LabeledStatement(loopId(this), _esastUtil.whileStatementInfinite(t0(this.block)));
		},
		MapEntry: function () {
			const index = vr.listMapEntryIndex(this);
			const k = '_k' + index;
			const v = '_v' + index;
			return _esastDistSpecialize.variableDeclarationConst([_esastDistAst.VariableDeclarator(_esastDistUtil.idCached(k), t0(this.key)), _esastDistAst.VariableDeclarator(_esastDistUtil.idCached(v), t0(this.val))]);
		},
		MapReturn: function () {
			const length = vr.listMapLength(this);
			return _util.msMap.apply(undefined, _toConsumableArray(_UBag.flatMap(_UBag.range(0, length), function (i) {
				return [_esastDistUtil.idCached('_k' + i), _esastDistUtil.idCached('_v' + i)];
			})));
		},
		Member: function () {
			return _esastDistUtil.member(t0(this.object), this.name);
		},
		Module: function () {
			return _transpileModule2(this, cx);
		},
		// TODO:ES6 Use `export default`
		ModuleDefaultExport: function () {
			const m = _esastDistUtil.member(_util.IdExports, 'default');
			return _esastDistAst.AssignmentExpression('=', m, t0(this.value));
		},
		Quote: function () {
			// TODO:ES6 use template strings
			const part0 = this.parts[0];

			var _ref = typeof part0 === 'string' ? [_esastDistAst.Literal(part0), _UBag.tail(this.parts)] : [_util.LitEmptyString, this.parts];

			var _ref2 = _slicedToArray(_ref, 2);

			const first = _ref2[0];
			const restParts = _ref2[1];

			return restParts.reduce(function (ex, _) {
				return _esastUtil.binaryExpressionPlus(ex, typeof _ === 'string' ? _esastDistAst.Literal(_) : _util.msShow(t0(_)));
			}, first);
		},
		Special: function () {
			// Make new objects because we will assign `loc` to them.
			switch (this.kind) {
				case _Expression.SP_Contains:
					return _esastDistUtil.member(_util.IdMs, 'contains');
				case _Expression.SP_Debugger:
					return _esastDistAst.DebuggerStatement();
				case _Expression.SP_False:
					return _esastDistAst.Literal(false);
				case _Expression.SP_Sub:
					return _esastDistUtil.member(_util.IdMs, 'sub');
				case _Expression.SP_This:
					return _esastDistAst.ThisExpression();
				case _Expression.SP_ThisModuleDirectory:
					return _esastDistAst.Identifier('__dirname');
				case _Expression.SP_True:
					return _esastDistAst.Literal(true);
				default:
					throw new Error(this.kind);
			}
		},
		Splat: function () {
			cx.fail(this.loc, 'Splat must appear as argument to a call.');
		},
		Yield: function () {
			return _esastDistSpecialize.yieldExpressionNoDelegate(t0(this.yielded));
		},
		YieldTo: function () {
			return _esastDistSpecialize.yieldExpressionDelegate(t0(this.yieldedTo));
		}
	});

	const arrayExtract = function (locals) {
		return _esastDistSpecialize.variableDeclarationConst(locals.map(function (l, index) {
			return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(l), _esastDistSpecialize.memberExpression(ExtractVar, _esastDistAst.Literal(index)));
		}));
	},
	      blockWrap = function (_, block) {
		const invoke = _esastDistSpecialize.callExpressionThunk(_esastDistSpecialize.functionExpressionThunk(block, isInGenerator));
		return isInGenerator ? _esastDistSpecialize.yieldExpressionDelegate(invoke) : invoke;
	},
	      caseBody = function (parts, opElse) {
		let acc = _UOp.ifElse(opElse, t0, function () {
			return _esastUtil.throwError('No branch of `case` matches.');
		});
		for (let i = parts.length - 1; i >= 0; i = i - 1) acc = t1(parts[i], acc);
		return acc;
	},
	      loopId = function (loop) {
		return _esastDistUtil.idCached('loop' + loop.loc.start.line);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS90cmFuc3BpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O21CQTZCd0IsU0FBUzs7Ozs7Ozs7OztBQUpqQyxPQUFNLFVBQVUsR0FBRyxjQXhCaUIsVUFBVSxDQXdCaEIsSUFBSSxDQUFDLENBQUE7O0FBRW5DLEtBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxhQUFhLENBQUE7O0FBRVYsVUFBUyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDOUMsSUFBRSxHQUFHLEdBQUcsQ0FBQTtBQUNSLElBQUUsR0FBRyxHQUFHLENBQUE7QUFDUixlQUFhLEdBQUcsS0FBSyxDQUFBO0FBQ3JCLFFBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7QUFFakIsSUFBRSxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUE7QUFDbkIsU0FBTyxHQUFHLENBQUE7RUFDVjs7QUFFTSxPQUFNLEVBQUUsR0FBRyxVQUFBLElBQUksRUFBSTtBQUN6QixRQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQTtBQUNuQyxLQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUE7QUFDbEIsU0FBTyxHQUFHLENBQUE7RUFDVixDQUFBO1NBSlksRUFBRSxHQUFGLEVBQUU7QUFLZixPQUFNLEVBQUUsR0FBRyxVQUFDLElBQUksRUFBRSxHQUFHLEVBQUs7QUFDekIsUUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQ3RDLEtBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQTtBQUNsQixTQUFPLEdBQUcsQ0FBQTtFQUNWLENBQUE7QUFDTSxPQUFNLEVBQUUsR0FBRyxVQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBSztBQUM1QyxRQUFNLEdBQUcsR0FB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ZS90cmFuc3BpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcnJheUV4cHJlc3Npb24sIEFzc2lnbm1lbnRFeHByZXNzaW9uLCBCbG9ja1N0YXRlbWVudCwgQnJlYWtTdGF0ZW1lbnQsXG5cdENhbGxFeHByZXNzaW9uLCBEZWJ1Z2dlclN0YXRlbWVudCwgSWRlbnRpZmllciwgSWZTdGF0ZW1lbnQsIExhYmVsZWRTdGF0ZW1lbnQsIExpdGVyYWwsXG5cdE9iamVjdEV4cHJlc3Npb24sIFRoaXNFeHByZXNzaW9uLCBWYXJpYWJsZURlY2xhcmF0b3IsIFJldHVyblN0YXRlbWVudCB9IGZyb20gJ2VzYXN0L2Rpc3QvYXN0J1xuaW1wb3J0IHsgaWRDYWNoZWQsIG1lbWJlciwgcHJvcGVydHlJZE9yTGl0ZXJhbENhY2hlZCwgdGh1bmsgfSBmcm9tICdlc2FzdC9kaXN0L3V0aWwnXG5pbXBvcnQgeyBjYWxsRXhwcmVzc2lvblRodW5rLCBmdW5jdGlvbkV4cHJlc3Npb25QbGFpbiwgZnVuY3Rpb25FeHByZXNzaW9uVGh1bmssIG1lbWJlckV4cHJlc3Npb24sXG5cdHByb3BlcnR5LCB2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QsIHlpZWxkRXhwcmVzc2lvbkRlbGVnYXRlLCB5aWVsZEV4cHJlc3Npb25Ob0RlbGVnYXRlXG5cdH0gZnJvbSAnZXNhc3QvZGlzdC9zcGVjaWFsaXplJ1xuaW1wb3J0ICogYXMgRUV4cG9ydHMgZnJvbSAnLi4vLi4vRXhwcmVzc2lvbidcbmltcG9ydCB7IEJsb2NrVmFsLCBQYXR0ZXJuLCBTcGxhdCxcblx0U1BfQ29udGFpbnMsIFNQX0RlYnVnZ2VyLCBTUF9GYWxzZSwgU1BfU3ViLCBTUF9UaGlzLCBTUF9UaGlzTW9kdWxlRGlyZWN0b3J5LCBTUF9UcnVlXG5cdH0gZnJvbSAnLi4vLi4vRXhwcmVzc2lvbidcbmltcG9ydCB7IGNhdCwgZmxhdE1hcCwgcmFuZ2UsIHRhaWwgfSBmcm9tICcuLi9VL0JhZydcbmltcG9ydCB7IGlmRWxzZSwgTm9uZSwgb3BJZiB9IGZyb20gJy4uL1UvT3AnXG5pbXBvcnQgeyBhc3NlcnQsIGltcGxlbWVudE1hbnksIGlzUG9zaXRpdmUgfSBmcm9tICcuLi9VL3V0aWwnXG5pbXBvcnQgeyBiaW5hcnlFeHByZXNzaW9uUGx1cywgYmluYXJ5RXhwcmVzc2lvbk5vdEVxdWFsLCBkZWNsYXJlLCBkZWNsYXJlU3BlY2lhbCxcblx0aWRGb3JEZWNsYXJlQ2FjaGVkLCB0aHJvd0Vycm9yLCB1bmFyeUV4cHJlc3Npb25OZWdhdGUsIHdoaWxlU3RhdGVtZW50SW5maW5pdGVcblx0fSBmcm9tICcuL2VzYXN0LXV0aWwnXG5pbXBvcnQgdHJhbnNwaWxlTW9kdWxlIGZyb20gJy4vdHJhbnNwaWxlTW9kdWxlJ1xuaW1wb3J0IHtcblx0SWRBcmd1bWVudHMsIElkQXJyYXlTbGljZUNhbGwsIElkRGlzcGxheU5hbWUsIElkRXhwb3J0cywgSWRGdW5jdGlvbkFwcGx5Q2FsbCwgSWRNcyxcblx0TGl0RW1wdHlBcnJheSwgTGl0RW1wdHlTdHJpbmcsIExpdE51bGwsIExpdFN0ckRpc3BsYXlOYW1lLCBSZXR1cm5SZXMsXG5cdGFjY2Vzc0xvY2FsLCBhY2Nlc3NMb2NhbERlY2xhcmUsIGxhenlXcmFwLCBtYWtlRGVjbGFyYXRvciwgbWFrZURlc3RydWN0dXJlRGVjbGFyYXRvcnMsXG5cdG1heWJlV3JhcEluQ2hlY2tDb250YWlucywgb3BMb2NhbENoZWNrLCB0b1N0YXRlbWVudHMsXG5cdG1zQXJyLCBtc0Jvb2wsIG1zRXh0cmFjdCwgbXNMc2V0LCBtc01hcCwgbXNTZXQsIG1zU2hvdyB9IGZyb20gJy4vdXRpbCdcblxuY29uc3QgRXh0cmFjdFZhciA9IElkZW50aWZpZXIoJ18kJylcblxubGV0IGN4LCB2ciwgaXNJbkdlbmVyYXRvclxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc3BpbGUoX2N4LCBlLCBfdnIpIHtcblx0Y3ggPSBfY3hcblx0dnIgPSBfdnJcblx0aXNJbkdlbmVyYXRvciA9IGZhbHNlXG5cdGNvbnN0IHJlcyA9IHQwKGUpXG5cdC8vIFJlbGVhc2UgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuXHRjeCA9IHZyID0gdW5kZWZpbmVkXG5cdHJldHVybiByZXNcbn1cblxuZXhwb3J0IGNvbnN0IHQwID0gZXhwciA9PiB7XG5cdGNvbnN0IGFzdCA9IGV4cHIudHJhbnNwaWxlU3VidHJlZSgpXG5cdGFzdC5sb2MgPSBleHByLmxvY1xuXHRyZXR1cm4gYXN0XG59XG5jb25zdCB0MSA9IChleHByLCBhcmcpID0+IHtcblx0Y29uc3QgYXN0ID0gZXhwci50cmFuc3BpbGVTdWJ0cmVlKGFyZylcblx0YXN0LmxvYyA9IGV4cHIubG9jXG5cdHJldHVybiBhc3Rcbn1cbmV4cG9ydCBjb25zdCB0MyA9IChleHByLCBhcmcsIGFyZzIsIGFyZzMpID0+IHtcblx0Y29uc3QgYXN0ID0gZXhwci50cmFuc3BpbGVTdWJ0cmVlKGFyZywgYXJnMiwgYXJnMylcblx0YXN0LmxvYyA9IGV4cHIubG9jXG5cdHJldHVybiBhc3Rcbn1cbmV4cG9ydCBjb25zdCB0bSA9IGV4cHIgPT4ge1xuXHRjb25zdCBhc3QgPSBleHByLnRyYW5zcGlsZVN1YnRyZWUoKVxuXHRpZiAoIShhc3QgaW5zdGFuY2VvZiBBcnJheSkpXG5cdFx0Ly8gRGVidWcgbWF5IHByb2R1Y2UgbXVsdGlwbGUgc3RhdGVtZW50cy5cblx0XHRhc3QubG9jID0gZXhwci5sb2Ncblx0cmV0dXJuIGFzdFxufVxuXG5mdW5jdGlvbiB0cmFuc3BpbGVCbG9jayhsZWFkLCBvcFJlc0RlY2xhcmUsIG9wT3V0KSB7XG5cdGlmIChsZWFkID09PSB1bmRlZmluZWQpXG5cdFx0bGVhZCA9IFtdXG5cdGlmIChvcFJlc0RlY2xhcmUgPT09IHVuZGVmaW5lZClcblx0XHRvcFJlc0RlY2xhcmUgPSBvcE91dCA9IE5vbmVcblx0Y29uc3QgYm9keSA9IGZsYXRNYXAodGhpcy5saW5lcywgbGluZSA9PiB0b1N0YXRlbWVudHModG0obGluZSkpKVxuXHRjb25zdCBpc1ZhbCA9IHRoaXMgaW5zdGFuY2VvZiBCbG9ja1ZhbFxuXHRjb25zdCBmaW4gPSBpZkVsc2Uob3BSZXNEZWNsYXJlLFxuXHRcdHJkID0+IHtcblx0XHRcdGFzc2VydChpc1ZhbClcblx0XHRcdGNvbnN0IHJldHVybmVkID0gbWF5YmVXcmFwSW5DaGVja0NvbnRhaW5zKGN4LCB0MCh0aGlzLnJldHVybmVkKSwgcmQub3BUeXBlLCAncmVzJylcblx0XHRcdHJldHVybiBpZkVsc2Uob3BPdXQsXG5cdFx0XHRcdG8gPT4gWyBkZWNsYXJlKHJkLCByZXR1cm5lZCkgXS5jb25jYXQobywgWyBSZXR1cm5SZXMgXSksXG5cdFx0XHRcdCgpID0+IFsgUmV0dXJuU3RhdGVtZW50KHJldHVybmVkKSBdKVxuXHRcdH0sXG5cdFx0KCkgPT4gb3BPdXQuY29uY2F0KG9wSWYoaXNWYWwsICgpID0+IFJldHVyblN0YXRlbWVudCh0MCh0aGlzLnJldHVybmVkKSkpKSlcblx0cmV0dXJuIEJsb2NrU3RhdGVtZW50KGxlYWQuY29uY2F0KGJvZHksIGZpbikpXG59XG5cbmZ1bmN0aW9uIGNhc2VQYXJ0KGFsdGVybmF0ZSkge1xuXHRpZiAodGhpcy50ZXN0IGluc3RhbmNlb2YgUGF0dGVybikge1xuXHRcdGNvbnN0IGRlY2wgPSB2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QoW1xuXHRcdFx0VmFyaWFibGVEZWNsYXJhdG9yKFxuXHRcdFx0XHRFeHRyYWN0VmFyLFxuXHRcdFx0XHRtc0V4dHJhY3QodDAodGhpcy50ZXN0LnR5cGUpLCB0MCh0aGlzLnRlc3QucGF0dGVybmVkKSkpXG5cdFx0XHRdKVxuXHRcdGNvbnN0IHRlc3QgPSBiaW5hcnlFeHByZXNzaW9uTm90RXF1YWwoRXh0cmFjdFZhciwgTGl0ZXJhbChudWxsKSlcblx0XHRjb25zdCBleHQgPSBhcnJheUV4dHJhY3QodGhpcy50ZXN0LmxvY2Fscylcblx0XHRjb25zdCByZXMgPSB0Myh0aGlzLnJlc3VsdCwgWyBleHQgXSlcblx0XHRyZXR1cm4gQmxvY2tTdGF0ZW1lbnQoWyBkZWNsLCBJZlN0YXRlbWVudCh0ZXN0LCByZXMsIGFsdGVybmF0ZSkgXSlcblx0fSBlbHNlIHtcblx0XHRjb25zdCBjaGVja2VkVGVzdCA9IGN4Lm9wdHMuaW5jbHVkZUNhc2VDaGVja3MoKSA/IG1zQm9vbCh0MCh0aGlzLnRlc3QpKSA6IHQwKHRoaXMudGVzdClcblx0XHQvLyBhbHRlcm5hdGUgd3JpdHRlbiB0byBieSBgY2FzZUJvZHlgLlxuXHRcdHJldHVybiBJZlN0YXRlbWVudChjaGVja2VkVGVzdCwgdDAodGhpcy5yZXN1bHQpLCBhbHRlcm5hdGUpXG5cdH1cbn1cblxuaW1wbGVtZW50TWFueShFRXhwb3J0cywgJ3RyYW5zcGlsZVN1YnRyZWUnLCB7XG5cdEFzc2lnbigpIHtcblx0XHRyZXR1cm4gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFtcblx0XHRcdG1ha2VEZWNsYXJhdG9yKFxuXHRcdFx0XHRjeCwgdGhpcy5sb2MsXG5cdFx0XHRcdHRoaXMuYXNzaWduZWUsXG5cdFx0XHRcdHQwKHRoaXMudmFsdWUpLFxuXHRcdFx0XHRmYWxzZSwgdnIuaXNFeHBvcnRBc3NpZ24odGhpcykpIF0pXG5cdH0sXG5cdC8vIFRPRE86RVM2IEp1c3QgdXNlIG5hdGl2ZSBkZXN0cnVjdHVyaW5nIGFzc2lnblxuXHRBc3NpZ25EZXN0cnVjdHVyZSgpIHtcblx0XHRyZXR1cm4gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFxuXHRcdFx0bWFrZURlc3RydWN0dXJlRGVjbGFyYXRvcnMoXG5cdFx0XHRcdGN4LFxuXHRcdFx0XHR0aGlzLmxvYyxcblx0XHRcdFx0dGhpcy5hc3NpZ25lZXMsXG5cdFx0XHRcdHRoaXMuaXNMYXp5LFxuXHRcdFx0XHR0MCh0aGlzLnZhbHVlKSxcblx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdHZyLmlzRXhwb3J0QXNzaWduKHRoaXMpKSlcblx0fSxcblx0QmxvY2tEbzogdHJhbnNwaWxlQmxvY2ssXG5cdEJsb2NrVmFsOiB0cmFuc3BpbGVCbG9jayxcblx0QmxvY2tXcmFwKCkgeyByZXR1cm4gYmxvY2tXcmFwKHRoaXMsIHQwKHRoaXMuYmxvY2spKSB9LFxuXHRDYWxsKCkge1xuXHRcdGNvbnN0IGFueVNwbGF0ID0gdGhpcy5hcmdzLnNvbWUoYXJnID0+IGFyZyBpbnN0YW5jZW9mIFNwbGF0KVxuXHRcdGlmIChhbnlTcGxhdCkge1xuXHRcdFx0Y29uc3QgYXJncyA9IHRoaXMuYXJncy5tYXAoYXJnID0+XG5cdFx0XHRcdGFyZyBpbnN0YW5jZW9mIFNwbGF0ID9cblx0XHRcdFx0XHRtc0Fycih0MChhcmcuc3BsYXR0ZWQpKSA6XG5cdFx0XHRcdFx0dDAoYXJnKSlcblx0XHRcdHJldHVybiBDYWxsRXhwcmVzc2lvbihJZEZ1bmN0aW9uQXBwbHlDYWxsLCBbXG5cdFx0XHRcdHQwKHRoaXMuY2FsbGVkKSxcblx0XHRcdFx0TGl0TnVsbCxcblx0XHRcdFx0Q2FsbEV4cHJlc3Npb24obWVtYmVyKExpdEVtcHR5QXJyYXksICdjb25jYXQnKSwgYXJncyldKVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBDYWxsRXhwcmVzc2lvbih0MCh0aGlzLmNhbGxlZCksIHRoaXMuYXJncy5tYXAodDApKVxuXHR9LFxuXHRDYXNlRG8oKSB7XG5cdFx0Y29uc3QgYm9keSA9IGNhc2VCb2R5KHRoaXMucGFydHMsIHRoaXMub3BFbHNlKVxuXHRcdHJldHVybiBpZkVsc2UodGhpcy5vcENhc2VkLFxuXHRcdFx0Y2FzZWQgPT4gQmxvY2tTdGF0ZW1lbnQoWyB0MChjYXNlZCksIGJvZHkgXSksXG5cdFx0XHQoKSA9PiBib2R5KVxuXHR9LFxuXHRDYXNlVmFsKCkge1xuXHRcdGNvbnN0IGJvZHkgPSBjYXNlQm9keSh0aGlzLnBhcnRzLCB0aGlzLm9wRWxzZSlcblx0XHRjb25zdCBibG9jayA9IGlmRWxzZSh0aGlzLm9wQ2FzZWQsIGNhc2VkID0+IFsgdDAoY2FzZWQpLCBib2R5IF0sICgpID0+IFsgYm9keSBdKVxuXHRcdHJldHVybiBibG9ja1dyYXAodGhpcywgQmxvY2tTdGF0ZW1lbnQoYmxvY2spKVxuXHR9LFxuXHRDYXNlRG9QYXJ0OiBjYXNlUGFydCxcblx0Q2FzZVZhbFBhcnQ6IGNhc2VQYXJ0LFxuXHQvLyBUT0RPOiBpbmNsdWRlSW5vdXRDaGVja3MgaXMgbWlzbmFtZWRcblx0RGVidWcoKSB7XG5cdFx0cmV0dXJuIGN4Lm9wdHMuaW5jbHVkZUlub3V0Q2hlY2tzKCkgP1xuXHRcdFx0ZmxhdE1hcCh0aGlzLmxpbmVzLCBsaW5lID0+IHRvU3RhdGVtZW50cyh0MChsaW5lKSkpIDpcblx0XHRcdFsgXVxuXHR9LFxuXHRPYmpSZXR1cm4oKSB7XG5cdFx0Ly8gVE9ETzogaW5jbHVkZVR5cGVDaGVja3MoKSBpcyBub3QgdGhlIHJpZ2h0IG1ldGhvZCBmb3IgdGhpc1xuXHRcdGNvbnN0IGtleXMgPVxuXHRcdFx0Y3gub3B0cy5pbmNsdWRlVHlwZUNoZWNrcygpID8gdGhpcy5rZXlzIDogdGhpcy5rZXlzLmZpbHRlcihfID0+ICF2ci5pc0RlYnVnTG9jYWwoXykpXG5cdFx0cmV0dXJuIGlmRWxzZSh0aGlzLm9wT2JqZWQsXG5cdFx0XHRvYmplZCA9PiB7XG5cdFx0XHRcdGNvbnN0IGFzdE9iamVkID0gdDAob2JqZWQpXG5cdFx0XHRcdGNvbnN0IGtleXNWYWxzID0gY2F0KFxuXHRcdFx0XHRcdGZsYXRNYXAoa2V5cywga2V5ID0+IFsgTGl0ZXJhbChrZXkubmFtZSksIGFjY2Vzc0xvY2FsRGVjbGFyZShrZXkpIF0pLFxuXHRcdFx0XHRcdGZsYXRNYXAodGhpcy5vcERpc3BsYXlOYW1lLCBkbiA9PiBbTGl0U3RyRGlzcGxheU5hbWUsIExpdGVyYWwoZG4pXSkpXG5cdFx0XHRcdGNvbnN0IGFueUxhenkgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5pc0xhenkpXG5cdFx0XHRcdHJldHVybiAoYW55TGF6eSA/IG1zTHNldCA6IG1zU2V0KShhc3RPYmplZCwgLi4ua2V5c1ZhbHMpXG5cdFx0XHR9LFxuXHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRjb25zdCBwcm9wcyA9IGtleXMubWFwKGtleSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYWNjZXNzTG9jYWxEZWNsYXJlKGtleSlcblx0XHRcdFx0XHRjb25zdCBpZCA9IHByb3BlcnR5SWRPckxpdGVyYWxDYWNoZWQoa2V5Lm5hbWUpXG5cdFx0XHRcdFx0cmV0dXJuIGtleS5pc0xhenkgP1xuXHRcdFx0XHRcdFx0cHJvcGVydHkoJ2dldCcsIGlkLCB0aHVuayh2YWwpKSA6XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWwpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGNvbnN0IG9wUHJvcERpc3BsYXlOYW1lID0gdGhpcy5vcERpc3BsYXlOYW1lLm1hcChkbiA9PlxuXHRcdFx0XHRcdHByb3BlcnR5KCdpbml0JywgSWREaXNwbGF5TmFtZSwgTGl0ZXJhbChkbikpKVxuXHRcdFx0XHRyZXR1cm4gT2JqZWN0RXhwcmVzc2lvbihjYXQocHJvcHMsIG9wUHJvcERpc3BsYXlOYW1lKSlcblx0XHRcdH0pXG5cdH0sXG5cdE9ialNpbXBsZSgpIHtcblx0XHRyZXR1cm4gT2JqZWN0RXhwcmVzc2lvbih0aGlzLnBhaXJzLm1hcChwYWlyID0+XG5cdFx0XHRwcm9wZXJ0eSgnaW5pdCcsIHByb3BlcnR5SWRPckxpdGVyYWxDYWNoZWQocGFpci5rZXkpLCB0MChwYWlyLnZhbHVlKSkpKVxuXHR9LFxuXHRFbmRMb29wKCkgeyByZXR1cm4gQnJlYWtTdGF0ZW1lbnQobG9vcElkKHZyLmVuZExvb3BUb0xvb3AuZ2V0KHRoaXMpKSkgfSxcblx0RnVuKCkge1xuXHRcdGNvbnN0IG9sZEluR2VuZXJhdG9yID0gaXNJbkdlbmVyYXRvclxuXHRcdGlzSW5HZW5lcmF0b3IgPSB0aGlzLmlzR2VuZXJhdG9yXG5cblx0XHQvLyBUT0RPOkVTNiB1c2UgYC4uLmBcblx0XHRjb25zdCBuQXJncyA9IExpdGVyYWwodGhpcy5hcmdzLmxlbmd0aClcblx0XHRjb25zdCBvcERlY2xhcmVSZXN0ID0gdGhpcy5vcFJlc3RBcmcubWFwKHJlc3QgPT5cblx0XHRcdGRlY2xhcmUocmVzdCwgQ2FsbEV4cHJlc3Npb24oSWRBcnJheVNsaWNlQ2FsbCwgW0lkQXJndW1lbnRzLCBuQXJnc10pKSlcblx0XHRjb25zdCBhcmdDaGVja3MgPSBmbGF0TWFwKHRoaXMuYXJncywgYXJnID0+IG9wTG9jYWxDaGVjayhjeCwgYXJnLCBhcmcuaXNMYXp5KSlcblx0XHRjb25zdCBfaW4gPSBmbGF0TWFwKHRoaXMub3BJbiwgdDApXG5cdFx0Y29uc3QgbGVhZCA9IG9wRGVjbGFyZVJlc3QuY29uY2F0KGFyZ0NoZWNrcywgX2luKVxuXG5cdFx0Y29uc3QgX291dCA9IHRoaXMub3BPdXQubWFwKHQwKVxuXHRcdGNvbnN0IGJvZHkgPSB0Myh0aGlzLmJsb2NrLCBsZWFkLCB0aGlzLm9wUmVzRGVjbGFyZSwgX291dClcblx0XHRjb25zdCBhcmdzID0gdGhpcy5hcmdzLm1hcCh0MClcblx0XHRjb25zdCByZXMgPSBmdW5jdGlvbkV4cHJlc3Npb25QbGFpbihhcmdzLCBib2R5LCB0aGlzLmlzR2VuZXJhdG9yKVxuXG5cdFx0aXNJbkdlbmVyYXRvciA9IG9sZEluR2VuZXJhdG9yXG5cdFx0cmV0dXJuIHJlc1xuXHR9LFxuXHRMYXp5KCkgeyByZXR1cm4gbGF6eVdyYXAodDAodGhpcy52YWx1ZSkpIH0sXG5cdExpc3RSZXR1cm4oKSB7XG5cdFx0Y29uc3QgbGVuZ3RoID0gdnIubGlzdE1hcExlbmd0aCh0aGlzKVxuXHRcdGFzc2VydChsZW5ndGggPj0gMClcblx0XHRyZXR1cm4gQXJyYXlFeHByZXNzaW9uKHJhbmdlKDAsIGxlbmd0aCkubWFwKGkgPT4gaWRDYWNoZWQoYF8ke2l9YCkpKVxuXHR9LFxuXHRMaXN0U2ltcGxlKCkgeyByZXR1cm4gQXJyYXlFeHByZXNzaW9uKHRoaXMucGFydHMubWFwKHQwKSkgfSxcblx0TGlzdEVudHJ5KCkgeyByZXR1cm4gZGVjbGFyZVNwZWNpYWwoYF8ke3ZyLmxpc3RNYXBFbnRyeUluZGV4KHRoaXMpfWAsIHQwKHRoaXMudmFsdWUpKSB9LFxuXHROdW1iZXJMaXRlcmFsKCkge1xuXHRcdC8vIE5lZ2F0aXZlIG51bWJlcnMgYXJlIG5vdCBwYXJ0IG9mIEVTIHNwZWMuXG5cdFx0Ly8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOC4zXG5cdFx0Y29uc3QgbGl0ID0gTGl0ZXJhbChNYXRoLmFicyh0aGlzLnZhbHVlKSlcblx0XHRyZXR1cm4gaXNQb3NpdGl2ZSh0aGlzLnZhbHVlKSA/IGxpdCA6IHVuYXJ5RXhwcmVzc2lvbk5lZ2F0ZShsaXQpXG5cdH0sXG5cdEdsb2JhbEFjY2VzcygpIHsgcmV0dXJuIElkZW50aWZpZXIodGhpcy5uYW1lKSB9LFxuXHRMb2NhbEFjY2VzcygpIHsgcmV0dXJuIGFjY2Vzc0xvY2FsKHRoaXMsIHZyKSB9LFxuXHRMb2NhbERlY2xhcmUoKSB7IHJldHVybiBpZEZvckRlY2xhcmVDYWNoZWQodGhpcykgfSxcblx0Ly8gVE9ETzogRG9uJ3QgYWx3YXlzIGxhYmVsIVxuXHRMb29wKCkge1xuXHRcdHJldHVybiBMYWJlbGVkU3RhdGVtZW50KGxvb3BJZCh0aGlzKSwgd2hpbGVTdGF0ZW1lbnRJbmZpbml0ZSh0MCh0aGlzLmJsb2NrKSkpXG5cdH0sXG5cdE1hcEVudHJ5KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdnIubGlzdE1hcEVudHJ5SW5kZXgodGhpcylcblx0XHRjb25zdCBrID0gYF9rJHtpbmRleH1gXG5cdFx0Y29uc3QgdiA9IGBfdiR7aW5kZXh9YFxuXHRcdHJldHVybiB2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QoW1xuXHRcdFx0VmFyaWFibGVEZWNsYXJhdG9yKGlkQ2FjaGVkKGspLCB0MCh0aGlzLmtleSkpLFxuXHRcdFx0VmFyaWFibGVEZWNsYXJhdG9yKGlkQ2FjaGVkKHYpLCB0MCh0aGlzLnZhbCkpXG5cdFx0XSlcblx0fSxcblx0TWFwUmV0dXJuKCkge1xuXHRcdGNvbnN0IGxlbmd0aCA9IHZyLmxpc3RNYXBMZW5ndGgodGhpcylcblx0XHRyZXR1cm4gbXNNYXAoLi4uZmxhdE1hcChyYW5nZSgwLCBsZW5ndGgpLCBpID0+XG5cdFx0XHRbIGlkQ2FjaGVkKGBfayR7aX1gKSwgaWRDYWNoZWQoYF92JHtpfWApIF0pKVxuXHR9LFxuXHRNZW1iZXIoKSB7XG5cdFx0cmV0dXJuIG1lbWJlcih0MCh0aGlzLm9iamVjdCksIHRoaXMubmFtZSlcblx0fSxcblx0TW9kdWxlKCkgeyByZXR1cm4gdHJhbnNwaWxlTW9kdWxlKHRoaXMsIGN4KSB9LFxuXHQvLyBUT0RPOkVTNiBVc2UgYGV4cG9ydCBkZWZhdWx0YFxuXHRNb2R1bGVEZWZhdWx0RXhwb3J0KCkge1xuXHRcdGNvbnN0IG0gPSBtZW1iZXIoSWRFeHBvcnRzLCAnZGVmYXVsdCcpXG5cdFx0cmV0dXJuIEFzc2lnbm1lbnRFeHByZXNzaW9uKCc9JywgbSwgdDAodGhpcy52YWx1ZSkpXG5cdH0sXG5cdFF1b3RlKCkge1xuXHRcdC8vIFRPRE86RVM2IHVzZSB0ZW1wbGF0ZSBzdHJpbmdzXG5cdFx0Y29uc3QgcGFydDAgPSB0aGlzLnBhcnRzWzBdXG5cdFx0Y29uc3QgWyBmaXJzdCwgcmVzdFBhcnRzIF0gPVxuXHRcdFx0dHlwZW9mIHBhcnQwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFsgTGl0ZXJhbChwYXJ0MCksIHRhaWwodGhpcy5wYXJ0cykgXSA6XG5cdFx0XHRcdFsgTGl0RW1wdHlTdHJpbmcsIHRoaXMucGFydHMgXVxuXHRcdHJldHVybiByZXN0UGFydHMucmVkdWNlKFxuXHRcdFx0KGV4LCBfKSA9PlxuXHRcdFx0XHRiaW5hcnlFeHByZXNzaW9uUGx1cyhleCwgdHlwZW9mIF8gPT09ICdzdHJpbmcnID8gTGl0ZXJhbChfKSA6IG1zU2hvdyh0MChfKSkpLFxuXHRcdFx0Zmlyc3QpXG5cdH0sXG5cdFNwZWNpYWwoKSB7XG5cdFx0Ly8gTWFrZSBuZXcgb2JqZWN0cyBiZWNhdXNlIHdlIHdpbGwgYXNzaWduIGBsb2NgIHRvIHRoZW0uXG5cdFx0c3dpdGNoICh0aGlzLmtpbmQpIHtcblx0XHRcdGNhc2UgU1BfQ29udGFpbnM6IHJldHVybiBtZW1iZXIoSWRNcywgJ2NvbnRhaW5zJylcblx0XHRcdGNhc2UgU1BfRGVidWdnZXI6IHJldHVybiBEZWJ1Z2dlclN0YXRlbWVudCgpXG5cdFx0XHRjYXNlIFNQX0ZhbHNlOiByZXR1cm4gTGl0ZXJhbChmYWxzZSlcblx0XHRcdGNhc2UgU1BfU3ViOiByZXR1cm4gbWVtYmVyKElkTXMsICdzdWInKVxuXHRcdFx0Y2FzZSBTUF9UaGlzOiByZXR1cm4gXHRUaGlzRXhwcmVzc2lvbigpXG5cdFx0XHRjYXNlIFNQX1RoaXNNb2R1bGVEaXJlY3Rvcnk6IHJldHVybiBJZGVudGlmaWVyKCdfX2Rpcm5hbWUnKVxuXHRcdFx0Y2FzZSBTUF9UcnVlOiByZXR1cm4gTGl0ZXJhbCh0cnVlKVxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKHRoaXMua2luZClcblx0XHR9XG5cdH0sXG5cdFNwbGF0KCkgeyBjeC5mYWlsKHRoaXMubG9jLCAnU3BsYXQgbXVzdCBhcHBlYXIgYXMgYXJndW1lbnQgdG8gYSBjYWxsLicpIH0sXG5cdFlpZWxkKCkgeyByZXR1cm4geWllbGRFeHByZXNzaW9uTm9EZWxlZ2F0ZSh0MCh0aGlzLnlpZWxkZWQpKSB9LFxuXHRZaWVsZFRvKCkgeyByZXR1cm4geWllbGRFeHByZXNzaW9uRGVsZWdhdGUodDAodGhpcy55aWVsZGVkVG8pKSB9XG59KVxuXG5jb25zdFxuXHRhcnJheUV4dHJhY3QgPSBsb2NhbHMgPT5cblx0XHR2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QobG9jYWxzLm1hcCgobCwgaW5kZXgpID0+XG5cdFx0XHRWYXJpYWJsZURlY2xhcmF0b3IoXG5cdFx0XHRcdGlkRm9yRGVjbGFyZUNhY2hlZChsKSxcblx0XHRcdFx0bWVtYmVyRXhwcmVzc2lvbihFeHRyYWN0VmFyLCBMaXRlcmFsKGluZGV4KSkpKSksXG5cblx0YmxvY2tXcmFwID0gKF8sIGJsb2NrKSA9PiB7XG5cdFx0Y29uc3QgaW52b2tlID0gY2FsbEV4cHJlc3Npb25UaHVuayhmdW5jdGlvbkV4cHJlc3Npb25UaHVuayhibG9jaywgaXNJbkdlbmVyYXRvcikpXG5cdFx0cmV0dXJuIGlzSW5HZW5lcmF0b3IgPyB5aWVsZEV4cHJlc3Npb25EZWxlZ2F0ZShpbnZva2UpIDogaW52b2tlXG5cdH0sXG5cblx0Y2FzZUJvZHkgPSAocGFydHMsIG9wRWxzZSkgPT4ge1xuXHRcdGxldCBhY2MgPSBpZkVsc2Uob3BFbHNlLCB0MCwgKCkgPT4gdGhyb3dFcnJvcignTm8gYnJhbmNoIG9mIGBjYXNlYCBtYXRjaGVzLicpKVxuXHRcdGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGkgPSBpIC0gMSlcblx0XHRcdGFjYyA9IHQxKHBhcnRzW2ldLCBhY2MpXG5cdFx0cmV0dXJuIGFjY1xuXHR9LFxuXG5cdGxvb3BJZCA9IGxvb3AgPT4gaWRDYWNoZWQoYGxvb3Ake2xvb3AubG9jLnN0YXJ0LmxpbmV9YClcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9