if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', 'esast/dist/specialize', '../../Expression', '../U/Bag', '../U/Op', '../U/util', './esast-util', './transpileObj', './transpileModule', './util'], function (exports, _esastDistAst, _esastDistUtil, _esastDistSpecialize, _Expression, _UBag, _UOp, _UUtil, _esastUtil, _transpileObj, _transpileModule, _util) {
	'use strict';

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };

	var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	exports.default = transpile;

	var _transpileModule2 = _interopRequire(_transpileModule);

	let cx, vr, isInGenerator;

	function transpile(_cx, e, _vr) {
		cx = _cx;
		vr = _vr;
		isInGenerator = false;
		const res = t(e);
		// Release for garbage collection
		cx = vr = undefined;
		return res;
	}

	const t = function (expr, arg, arg2, arg3) {
		const ast = expr.transpileSubtree(arg, arg2, arg3);
		if (cx.opts.sourceMap() && !(ast instanceof Array))
			// Array is only allowed for statement groups inside of Blocks, such as Debug.
			ast.loc = expr.loc;
		return ast;
	};

	exports.t = t;
	function transpileBlock(lead, opResDeclare, opOut) {
		var _this = this;

		if (lead === undefined) lead = [];
		if (opResDeclare === undefined) opResDeclare = opOut = _UOp.None;
		const body = _UBag.flatMap(this.lines, function (line) {
			return _esastDistUtil.toStatements(t(line));
		});
		const isVal = this instanceof _Expression.BlockVal;
		const fin = _UOp.ifElse(opResDeclare, function (rd) {
			_UUtil.assert(isVal);
			const returned = _util.maybeWrapInCheckContains(cx, t(_this.returned), rd.opType, 'res');
			return _UOp.ifElse(opOut, function (o) {
				return [_esastUtil.declare(rd, returned)].concat(o, [_util.ReturnRes]);
			}, function () {
				return [_esastDistAst.ReturnStatement(returned)];
			});
		}, function () {
			return opOut.concat(_UOp.opIf(isVal, function () {
				return _esastDistAst.ReturnStatement(t(_this.returned));
			}));
		});
		return _esastDistAst.BlockStatement(lead.concat(body, fin));
	}

	_UUtil.implementMany(_Expression, 'transpileSubtree', {
		Assign: function () {
			return _esastDistSpecialize.variableDeclarationConst([_util.makeDeclarator(cx, this.loc, this.assignee, this.k, t(this.value))]);
		},
		// TODO:ES6 Just use native destructuring assign
		AssignDestructure: function () {
			return _esastDistSpecialize.variableDeclarationConst(_util.makeDestructureDeclarators(cx, this.loc, this.assignees, this.isLazy, t(this.value), this.k, false));
		},
		BlockDo: transpileBlock,
		BlockVal: transpileBlock,
		BlockWrap: function () {
			return blockWrap(this, t(this.block));
		},
		Call: function () {
			const anySplat = this.args.some(function (arg) {
				return arg instanceof _Expression.Splat;
			});
			if (anySplat) {
				const args = this.args.map(function (arg) {
					return arg instanceof _Expression.Splat ? _util.msArr([t(arg.splatted)]) : t(arg);
				});
				return _esastDistAst.CallExpression(_util.IdFunctionApplyCall, [t(this.called), _util.LitNull, _esastDistAst.CallExpression(_esastDistUtil.member(_util.LitEmptyArray, 'concat'), args)]);
			} else return _esastDistAst.CallExpression(t(this.called), this.args.map(t));
		},
		CaseDo: function () {
			var _this2 = this;

			return _UOp.ifElse(this.opCased, function (cased) {
				return _esastDistAst.BlockStatement([t(cased), caseBody(_this2.parts, _this2.opElse)]);
			}, function () {
				return caseBody(_this2.parts, _this2.opElse);
			});
		},
		CaseVal: function () {
			const body = caseBody(this.parts, this.opElse);
			const block = _UOp.ifElse(this.opCased, function (cased) {
				return [t(cased), body];
			}, function () {
				return [body];
			});
			return blockWrap(this, _esastDistAst.BlockStatement(block));
		},
		CaseDoPart: function () {
			return casePart(this.test, this.result, true);
		},
		CaseValPart: function () {
			return casePart(this.test, this.result, false);
		},
		// TODO: includeInoutChecks is misnamed
		Debug: function () {
			return cx.opts.includeInoutChecks() ? _UBag.flatMap(this.lines, function (line) {
				return _esastDistUtil.toStatements(t(line));
			}) : [];
		},
		ObjReturn: function () {
			return _transpileObj.transpileObjReturn(this, cx);
		},
		ObjSimple: function () {
			return _transpileObj.transpileObjSimple(this, cx);
		},
		EndLoop: function () {
			return _esastDistAst.BreakStatement(loopId(vr.endLoopToLoop.get(this)));
		},
		Fun: function () {
			const oldInGenerator = isInGenerator;
			isInGenerator = this.k === '~|';

			// TODO:ES6 use `...`
			const nArgs = _esastDistAst.Literal(this.args.length);
			const opDeclareRest = this.opRestArg.map(function (rest) {
				return _esastUtil.declare(rest, _esastDistAst.CallExpression(_util.IdArraySliceCall, [_util.IdArguments, nArgs]));
			});
			const argChecks = _UBag.flatMap(this.args, function (arg) {
				return _util.opLocalCheck(cx, arg, arg.isLazy);
			});
			const _in = _UBag.flatMap(this.opIn, function (i) {
				return _esastDistUtil.toStatements(t(i));
			});
			const lead = opDeclareRest.concat(argChecks, _in);

			const _out = _UBag.flatMap(this.opOut, function (o) {
				return _esastDistUtil.toStatements(t(o));
			});
			const body = t(this.block, lead, this.opResDeclare, _out);
			const args = this.args.map(t);
			const res = _esastDistSpecialize.functionExpressionPlain(args, body, this.k === '~|');

			isInGenerator = oldInGenerator;
			return res;
		},
		Lazy: function () {
			return _util.lazyWrap(t(this.value));
		},
		ListReturn: function () {
			return _esastDistAst.ArrayExpression(_UBag.range(0, this.length).map(function (i) {
				return _esastDistUtil.idCached('_' + i);
			}));
		},
		ListSimple: function () {
			return _esastDistAst.ArrayExpression(this.parts.map(t));
		},
		ListEntry: function () {
			return _esastUtil.declareSpecial('_' + this.index, t(this.value));
		},
		NumberLiteral: function () {
			// Negative numbers are not part of ES spec.
			// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3
			const lit = _esastDistAst.Literal(Math.abs(this.value));
			return _UUtil.isPositive(this.value) ? lit : _esastDistSpecialize.unaryExpressionNegate(lit);
		},
		GlobalAccess: function () {
			return _esastDistAst.Identifier(this.name);
		},
		LocalAccess: function () {
			return _util.accessLocal(this, vr);
		},
		LocalDeclare: function () {
			return _esastUtil.idForDeclareCached(this);
		},
		// TODO: Don't always label!
		Loop: function () {
			return _esastDistAst.LabeledStatement(loopId(this), _esastDistSpecialize.whileStatementInfinite(t(this.block)));
		},
		MapReturn: function () {
			return _util.msMap(_UBag.flatMap(_UBag.range(0, this.length), function (i) {
				return [_esastDistUtil.idCached('_k' + i.toString()), _esastDistUtil.idCached('_v' + i.toString())];
			}));
		},
		MapEntry: function () {
			return _esastDistSpecialize.variableDeclarationConst([_esastDistAst.VariableDeclarator(_esastDistUtil.idCached('_k' + this.index), t(this.key)), _esastDistAst.VariableDeclarator(_esastDistUtil.idCached('_v' + this.index), t(this.val))]);
		},
		Member: function () {
			return _esastDistUtil.member(t(this.object), this.name);
		},
		Module: function () {
			return _transpileModule2(this, cx);
		},
		// TODO:ES6 Use `export default`
		ModuleDefaultExport: function () {
			const m = _esastDistUtil.member(_util.IdExports, 'default');
			return _esastDistAst.AssignmentExpression('=', m, t(this.value));
		},
		Quote: function () {
			// TODO:ES6 use template strings
			const part0 = this.parts[0];

			var _ref = typeof part0 === 'string' ? [_esastDistAst.Literal(part0), _UBag.tail(this.parts)] : [_util.LitEmptyString, this.parts];

			var _ref2 = _slicedToArray(_ref, 2);

			const first = _ref2[0];
			const restParts = _ref2[1];

			return restParts.reduce(function (ex, _) {
				return _esastDistSpecialize.binaryExpressionPlus(ex, typeof _ === 'string' ? _esastDistAst.Literal(_) : _util.msShow([t(_)]));
			}, first);
		},
		Special: function () {
			// Make new objects because we will assign `loc` to them.
			switch (this.k) {
				case 'contains':
					return _esastDistUtil.member(_util.IdMs, 'contains');
				case 'debugger':
					return _esastDistAst.DebuggerStatement();
				case 'sub':
					return _esastDistUtil.member(_util.IdMs, 'sub');
				case 'this':
					return _esastDistAst.ThisExpression();
				case 'this-module-directory':
					return _esastDistAst.Identifier('__dirname');
				default:
					throw new Error(this.k);
			}
		},
		Splat: function () {
			cx.fail(this.loc, 'Splat must appear as argument to a call.');
		},
		Yield: function () {
			return _esastDistSpecialize.yieldExpressionNoDelegate(t(this.yielded));
		},
		YieldTo: function () {
			return _esastDistSpecialize.yieldExpressionDelegate(t(this.yieldedTo));
		}
	});

	const blockWrap = function (_, block) {
		const g = isInGenerator;
		const invoke = _esastDistSpecialize.callExpressionThunk(_esastDistSpecialize.functionExpressionThunk(block, g));
		return g ? _esastDistSpecialize.yieldExpressionDelegate(invoke) : invoke;
	};

	const caseFail = _esastDistAst.SwitchCase(null, [_esastDistUtil.throwError('No branch of `case` matches.')]);
	function caseBody(parts, opElse) {
		const elze = _UOp.ifElse(opElse, function (_) {
			return _esastDistAst.SwitchCase(null, [t(_)]);
		}, function () {
			return caseFail;
		});
		const cases = _UBag.push(parts.map(function (part) {
			return t(part);
		}), elze);
		return _esastDistSpecialize.switchStatementOnTrue(cases);
	}

	function casePart(test, result, needBreak) {
		const checkedTest = cx.opts.includeCaseChecks() ? _util.msBool([t(test)]) : t(test);
		const lines = needBreak ? [t(result), _util.Break] : [t(result)];
		return _esastDistAst.SwitchCase(checkedTest, lines);
	}

	// TODO: MOVE
	const loopId = function (loop) {
		return _esastDistUtil.idCached('loop' + loop.loc.start.line);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS90cmFuc3BpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzttQkF5QndCLFNBQVM7Ozs7QUFGakMsS0FBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLGFBQWEsQ0FBQTs7QUFFVixVQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRTtBQUM5QyxJQUFFLEdBQUcsR0FBRyxDQUFBO0FBQ1IsSUFBRSxHQUFHLEdBQUcsQ0FBQTtBQUNSLGVBQWEsR0FBRyxLQUFLLENBQUE7QUFDckIsUUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOztBQUVoQixJQUFFLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQTtBQUNuQixTQUFPLEdBQUcsQ0FBQTtFQUNWOztBQUVNLE9BQU0sQ0FBQyxHQUFHLFVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFLO0FBQzNDLFFBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO0FBQ2xELE1BQUksRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsWUFBWSxLQUFLLENBQUEsQUFBQzs7QUFFakQsTUFBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFBO0FBQ25CLFNBQU8sR0FBRyxDQUFBO0VBQ1YsQ0FBQTs7U0FOWSxDQUFDLEdBQUQsQ0FBQztBQVFkLFVBQVMsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFOzs7QUFDbEQsTUFBSSxJQUFJLEtBQUssU0FBUyxFQUNyQixJQUFJLEdBQUcsRUFBRSxDQUFBO0FBQ1YsTUFBSSxZQUFZLEtBQUssU0FBUyxFQUM3QixZQUFZLEdBQUcsS0FBSyxRQXBDTCxJQUFJLEFBb0NRLENBQUE7QUFDNUIsUUFBTSxJ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QUFNLEVBQUU7QUFDaEMsUUFBTSxJQUFJLEdBQUcsS0F4TUwsTUFBTSxDQXdNTSxNQUFNLEVBQ3pCLFVBQUEsQ0FBQztVQUFJLGNBbE5OLFVBQVUsQ0FrTk8sSUFBSSxFQUFFLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUM7R0FBQSxFQUMvQjtVQUFNLFFBQVE7R0FBQSxDQUFDLENBQUE7QUFDaEIsUUFBTSxLQUFLLEdBQUcsTUE1TUcsSUFBSSxDQTRNRixLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUEsSUFBSTtVQUFJLENBQUMsQ0FBQyxJQUFJLENBQUM7R0FBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFDcEQsU0FBTyxxQkFqTlAscUJBQXFCLENBaU5RLEtBQUssQ0FBQyxDQUFBO0VBQ25DOztBQUVELFVBQVMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFO0FBQzFDLFFBQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxNQXRNN0IsTUFBTSxDQXNNOEIsQ0FBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUMvRSxRQUFNLEtBQUssR0FBRyxTQUFTLEdBQUcsQ0FBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBMU1HLEtBQUssQ0EwTUMsR0FBRyxDQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBRSxDQUFBO0FBQzlELFNBQU8sY0EzTlAsVUFBVSxDQTJOUSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUE7RUFDckM7OztBQUdELE9BQU0sTUFBTSxHQUFHLFVBQUEsSUFBSSxFQUFJO0FBQ3RCLFNBQU8sZUEvTkMsUUFBUSxVQStOTyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUcsQ0FBQTtFQUM3QyxDQUFBIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS90cmFuc3BpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcnJheUV4cHJlc3Npb24sIEFzc2lnbm1lbnRFeHByZXNzaW9uLCBCbG9ja1N0YXRlbWVudCwgQnJlYWtTdGF0ZW1lbnQsXG5cdENhbGxFeHByZXNzaW9uLCBEZWJ1Z2dlclN0YXRlbWVudCwgSWRlbnRpZmllciwgTGFiZWxlZFN0YXRlbWVudCwgTGl0ZXJhbCxcblx0U3dpdGNoQ2FzZSwgVGhpc0V4cHJlc3Npb24sIFZhcmlhYmxlRGVjbGFyYXRvciwgUmV0dXJuU3RhdGVtZW50IH0gZnJvbSAnZXNhc3QvZGlzdC9hc3QnXG5pbXBvcnQgeyBpZENhY2hlZCwgbWVtYmVyLCB0aHJvd0Vycm9yLCB0b1N0YXRlbWVudHMgfSBmcm9tICdlc2FzdC9kaXN0L3V0aWwnXG5pbXBvcnQge1xuXHRiaW5hcnlFeHByZXNzaW9uUGx1cywgY2FsbEV4cHJlc3Npb25UaHVuaywgZnVuY3Rpb25FeHByZXNzaW9uUGxhaW4sIGZ1bmN0aW9uRXhwcmVzc2lvblRodW5rLFxuXHRzd2l0Y2hTdGF0ZW1lbnRPblRydWUsXG5cdHVuYXJ5RXhwcmVzc2lvbk5lZ2F0ZSwgdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0LCB3aGlsZVN0YXRlbWVudEluZmluaXRlLFxuXHR5aWVsZEV4cHJlc3Npb25EZWxlZ2F0ZSwgeWllbGRFeHByZXNzaW9uTm9EZWxlZ2F0ZSB9IGZyb20gJ2VzYXN0L2Rpc3Qvc3BlY2lhbGl6ZSdcbmltcG9ydCAqIGFzIEVFeHBvcnRzIGZyb20gJy4uLy4uL0V4cHJlc3Npb24nXG5pbXBvcnQgeyBmbGF0TWFwLCBwdXNoLCByYW5nZSwgdGFpbCB9IGZyb20gJy4uL1UvQmFnJ1xuaW1wb3J0IHsgaWZFbHNlLCBOb25lLCBvcElmIH0gZnJvbSAnLi4vVS9PcCdcbmltcG9ydCB7IGFzc2VydCwgaW1wbGVtZW50TWFueSwgaXNQb3NpdGl2ZSB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCB7IGRlY2xhcmUsIGRlY2xhcmVTcGVjaWFsLCBpZEZvckRlY2xhcmVDYWNoZWQgfSBmcm9tICcuL2VzYXN0LXV0aWwnXG5pbXBvcnQgeyB0cmFuc3BpbGVPYmpSZXR1cm4sIHRyYW5zcGlsZU9ialNpbXBsZSB9IGZyb20gJy4vdHJhbnNwaWxlT2JqJ1xuaW1wb3J0IHRyYW5zcGlsZU1vZHVsZSBmcm9tICcuL3RyYW5zcGlsZU1vZHVsZSdcbmltcG9ydCB7XG5cdElkRXhwb3J0cywgSWRBcmd1bWVudHMsIElkQXJyYXlTbGljZUNhbGwsIElkRnVuY3Rpb25BcHBseUNhbGwsIElkTXMsXG5cdExpdEVtcHR5QXJyYXksIExpdEVtcHR5U3RyaW5nLCBMaXROdWxsLCBCcmVhaywgUmV0dXJuUmVzLFxuXHRhY2Nlc3NMb2NhbCwgbGF6eVdyYXAsIG1ha2VEZWNsYXJhdG9yLCBtYWtlRGVzdHJ1Y3R1cmVEZWNsYXJhdG9ycyxcblx0bWF5YmVXcmFwSW5DaGVja0NvbnRhaW5zLFxuXHRvcExvY2FsQ2hlY2ssIG1zQXJyLCBtc0Jvb2wsIG1zTWFwLCBtc1Nob3cgfSBmcm9tICcuL3V0aWwnXG5cbmxldCBjeCwgdnIsIGlzSW5HZW5lcmF0b3JcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNwaWxlKF9jeCwgZSwgX3ZyKSB7XG5cdGN4ID0gX2N4XG5cdHZyID0gX3ZyXG5cdGlzSW5HZW5lcmF0b3IgPSBmYWxzZVxuXHRjb25zdCByZXMgPSB0KGUpXG5cdC8vIFJlbGVhc2UgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuXHRjeCA9IHZyID0gdW5kZWZpbmVkXG5cdHJldHVybiByZXNcbn1cblxuZXhwb3J0IGNvbnN0IHQgPSAoZXhwciwgYXJnLCBhcmcyLCBhcmczKSA9PiB7XG5cdGNvbnN0IGFzdCA9IGV4cHIudHJhbnNwaWxlU3VidHJlZShhcmcsIGFyZzIsIGFyZzMpXG5cdGlmIChjeC5vcHRzLnNvdXJjZU1hcCgpICYmICEoYXN0IGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdC8vIEFycmF5IGlzIG9ubHkgYWxsb3dlZCBmb3Igc3RhdGVtZW50IGdyb3VwcyBpbnNpZGUgb2YgQmxvY2tzLCBzdWNoIGFzIERlYnVnLlxuXHRcdGFzdC5sb2MgPSBleHByLmxvY1xuXHRyZXR1cm4gYXN0XG59XG5cbmZ1bmN0aW9uIHRyYW5zcGlsZUJsb2NrKGxlYWQsIG9wUmVzRGVjbGFyZSwgb3BPdXQpIHtcblx0aWYgKGxlYWQgPT09IHVuZGVmaW5lZClcblx0XHRsZWFkID0gW11cblx0aWYgKG9wUmVzRGVjbGFyZSA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wUmVzRGVjbGFyZSA9IG9wT3V0ID0gTm9uZVxuXHRjb25zdCBib2R5ID0gZmxhdE1hcCh0aGlzLmxpbmVzLCBsaW5lID0+IHRvU3RhdGVtZW50cyh0KGxpbmUpKSlcblx0Y29uc3QgaXNWYWwgPSB0aGlzIGluc3RhbmNlb2YgRUV4cG9ydHMuQmxvY2tWYWxcblx0Y29uc3QgZmluID0gaWZFbHNlKG9wUmVzRGVjbGFyZSxcblx0XHRyZCA9PiB7XG5cdFx0XHRhc3NlcnQoaXNWYWwpXG5cdFx0XHRjb25zdCByZXR1cm5lZCA9IG1heWJlV3JhcEluQ2hlY2tDb250YWlucyhjeCwgdCh0aGlzLnJldHVybmVkKSwgcmQub3BUeXBlLCAncmVzJylcblx0XHRcdHJldHVybiBpZkVsc2Uob3BPdXQsXG5cdFx0XHRcdG8gPT4gWyBkZWNsYXJlKHJkLCByZXR1cm5lZCkgXS5jb25jYXQobywgWyBSZXR1cm5SZXMgXSksXG5cdFx0XHRcdCgpID0+IFsgUmV0dXJuU3RhdGVtZW50KHJldHVybmVkKSBdKVxuXHRcdH0sXG5cdFx0KCkgPT4gb3BPdXQuY29uY2F0KG9wSWYoaXNWYWwsICgpID0+IFJldHVyblN0YXRlbWVudCh0KHRoaXMucmV0dXJuZWQpKSkpKVxuXHRyZXR1cm4gQmxvY2tTdGF0ZW1lbnQobGVhZC5jb25jYXQoYm9keSwgZmluKSlcbn1cblxuaW1wbGVtZW50TWFueShFRXhwb3J0cywgJ3RyYW5zcGlsZVN1YnRyZWUnLCB7XG5cdEFzc2lnbigpIHtcblx0XHRyZXR1cm4gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFtcblx0XHRcdG1ha2VEZWNsYXJhdG9yKGN4LCB0aGlzLmxvYywgdGhpcy5hc3NpZ25lZSwgdGhpcy5rLCB0KHRoaXMudmFsdWUpKSBdKVxuXHR9LFxuXHQvLyBUT0RPOkVTNiBKdXN0IHVzZSBuYXRpdmUgZGVzdHJ1Y3R1cmluZyBhc3NpZ25cblx0QXNzaWduRGVzdHJ1Y3R1cmUoKSB7XG5cdFx0cmV0dXJuIHZhcmlhYmxlRGVjbGFyYXRpb25Db25zdChcblx0XHRcdG1ha2VEZXN0cnVjdHVyZURlY2xhcmF0b3JzKFxuXHRcdFx0XHRjeCxcblx0XHRcdFx0dGhpcy5sb2MsXG5cdFx0XHRcdHRoaXMuYXNzaWduZWVzLFxuXHRcdFx0XHR0aGlzLmlzTGF6eSxcblx0XHRcdFx0dCh0aGlzLnZhbHVlKSxcblx0XHRcdFx0dGhpcy5rLFxuXHRcdFx0XHRmYWxzZSkpXG5cdH0sXG5cdEJsb2NrRG86IHRyYW5zcGlsZUJsb2NrLFxuXHRCbG9ja1ZhbDogdHJhbnNwaWxlQmxvY2ssXG5cdEJsb2NrV3JhcCgpIHsgcmV0dXJuIGJsb2NrV3JhcCh0aGlzLCB0KHRoaXMuYmxvY2spKSB9LFxuXHRDYWxsKCkge1xuXHRcdGNvbnN0IGFueVNwbGF0ID0gdGhpcy5hcmdzLnNvbWUoYXJnID0+IGFyZyBpbnN0YW5jZW9mIEVFeHBvcnRzLlNwbGF0KVxuXHRcdGlmIChhbnlTcGxhdCkge1xuXHRcdFx0Y29uc3QgYXJncyA9IHRoaXMuYXJncy5tYXAoYXJnID0+XG5cdFx0XHRcdGFyZyBpbnN0YW5jZW9mIEVFeHBvcnRzLlNwbGF0ID9cblx0XHRcdFx0XHRtc0FycihbIHQoYXJnLnNwbGF0dGVkKSBdKSA6XG5cdFx0XHRcdFx0dChhcmcpKVxuXHRcdFx0cmV0dXJuIENhbGxFeHByZXNzaW9uKElkRnVuY3Rpb25BcHBseUNhbGwsIFtcblx0XHRcdFx0dCh0aGlzLmNhbGxlZCksXG5cdFx0XHRcdExpdE51bGwsXG5cdFx0XHRcdENhbGxFeHByZXNzaW9uKG1lbWJlcihMaXRFbXB0eUFycmF5LCAnY29uY2F0JyksIGFyZ3MpXSlcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gQ2FsbEV4cHJlc3Npb24odCh0aGlzLmNhbGxlZCksIHRoaXMuYXJncy5tYXAodCkpXG5cdH0sXG5cdENhc2VEbygpIHtcblx0XHRyZXR1cm4gaWZFbHNlKHRoaXMub3BDYXNlZCxcblx0XHRcdGNhc2VkID0+IEJsb2NrU3RhdGVtZW50KFsgdChjYXNlZCksIGNhc2VCb2R5KHRoaXMucGFydHMsIHRoaXMub3BFbHNlKSBdKSxcblx0XHRcdCgpID0+IGNhc2VCb2R5KHRoaXMucGFydHMsIHRoaXMub3BFbHNlKSlcblx0fSxcblx0Q2FzZVZhbCgpIHtcblx0XHRjb25zdCBib2R5ID0gY2FzZUJvZHkodGhpcy5wYXJ0cywgdGhpcy5vcEVsc2UpXG5cdFx0Y29uc3QgYmxvY2sgPSBpZkVsc2UodGhpcy5vcENhc2VkLCBjYXNlZCA9PiBbIHQoY2FzZWQpLCBib2R5IF0sICgpID0+IFsgYm9keSBdKVxuXHRcdHJldHVybiBibG9ja1dyYXAodGhpcywgQmxvY2tTdGF0ZW1lbnQoYmxvY2spKVxuXHR9LFxuXHRDYXNlRG9QYXJ0KCkgeyByZXR1cm4gY2FzZVBhcnQodGhpcy50ZXN0LCB0aGlzLnJlc3VsdCwgdHJ1ZSkgfSxcblx0Q2FzZVZhbFBhcnQoKSB7IHJldHVybiBjYXNlUGFydCh0aGlzLnRlc3QsIHRoaXMucmVzdWx0LCBmYWxzZSkgfSxcblx0Ly8gVE9ETzogaW5jbHVkZUlub3V0Q2hlY2tzIGlzIG1pc25hbWVkXG5cdERlYnVnKCkge1xuXHRcdHJldHVybiBjeC5vcHRzLmluY2x1ZGVJbm91dENoZWNrcygpID9cblx0XHRcdGZsYXRNYXAodGhpcy5saW5lcywgbGluZSA9PiB0b1N0YXRlbWVudHModChsaW5lKSkpIDpcblx0XHRcdFsgXVxuXHR9LFxuXHRPYmpSZXR1cm4oKSB7IHJldHVybiB0cmFuc3BpbGVPYmpSZXR1cm4odGhpcywgY3gpIH0sXG5cdE9ialNpbXBsZSgpIHsgcmV0dXJuIHRyYW5zcGlsZU9ialNpbXBsZSh0aGlzLCBjeCkgfSxcblx0RW5kTG9vcCgpIHsgcmV0dXJuIEJyZWFrU3RhdGVtZW50KGxvb3BJZCh2ci5lbmRMb29wVG9Mb29wLmdldCh0aGlzKSkpIH0sXG5cdEZ1bigpIHtcblx0XHRjb25zdCBvbGRJbkdlbmVyYXRvciA9IGlzSW5HZW5lcmF0b3Jcblx0XHRpc0luR2VuZXJhdG9yID0gdGhpcy5rID09PSAnfnwnXG5cblx0XHQvLyBUT0RPOkVTNiB1c2UgYC4uLmBcblx0XHRjb25zdCBuQXJncyA9IExpdGVyYWwodGhpcy5hcmdzLmxlbmd0aClcblx0XHRjb25zdCBvcERlY2xhcmVSZXN0ID0gdGhpcy5vcFJlc3RBcmcubWFwKHJlc3QgPT5cblx0XHRcdGRlY2xhcmUocmVzdCwgQ2FsbEV4cHJlc3Npb24oSWRBcnJheVNsaWNlQ2FsbCwgW0lkQXJndW1lbnRzLCBuQXJnc10pKSlcblx0XHRjb25zdCBhcmdDaGVja3MgPSBmbGF0TWFwKHRoaXMuYXJncywgYXJnID0+IG9wTG9jYWxDaGVjayhjeCwgYXJnLCBhcmcuaXNMYXp5KSlcblx0XHRjb25zdCBfaW4gPSBmbGF0TWFwKHRoaXMub3BJbiwgaSA9PiB0b1N0YXRlbWVudHModChpKSkpXG5cdFx0Y29uc3QgbGVhZCA9IG9wRGVjbGFyZVJlc3QuY29uY2F0KGFyZ0NoZWNrcywgX2luKVxuXG5cdFx0Y29uc3QgX291dCA9IGZsYXRNYXAodGhpcy5vcE91dCwgbyA9PiB0b1N0YXRlbWVudHModChvKSkpXG5cdFx0Y29uc3QgYm9keSA9IHQodGhpcy5ibG9jaywgbGVhZCwgdGhpcy5vcFJlc0RlY2xhcmUsIF9vdXQpXG5cdFx0Y29uc3QgYXJncyA9IHRoaXMuYXJncy5tYXAodClcblx0XHRjb25zdCByZXMgPSBmdW5jdGlvbkV4cHJlc3Npb25QbGFpbihhcmdzLCBib2R5LCB0aGlzLmsgPT09ICd+fCcpXG5cblx0XHRpc0luR2VuZXJhdG9yID0gb2xkSW5HZW5lcmF0b3Jcblx0XHRyZXR1cm4gcmVzXG5cdH0sXG5cdExhenkoKSB7IHJldHVybiBsYXp5V3JhcCh0KHRoaXMudmFsdWUpKSB9LFxuXHRMaXN0UmV0dXJuKCkge1xuXHRcdHJldHVybiBBcnJheUV4cHJlc3Npb24ocmFuZ2UoMCwgdGhpcy5sZW5ndGgpLm1hcChpID0+IGlkQ2FjaGVkKGBfJHtpfWApKSlcblx0fSxcblx0TGlzdFNpbXBsZSgpIHsgcmV0dXJuIEFycmF5RXhwcmVzc2lvbih0aGlzLnBhcnRzLm1hcCh0KSkgfSxcblx0TGlzdEVudHJ5KCkgeyByZXR1cm4gZGVjbGFyZVNwZWNpYWwoYF8ke3RoaXMuaW5kZXh9YCwgdCh0aGlzLnZhbHVlKSkgfSxcblx0TnVtYmVyTGl0ZXJhbCgpIHtcblx0XHQvLyBOZWdhdGl2ZSBudW1iZXJzIGFyZSBub3QgcGFydCBvZiBFUyBzcGVjLlxuXHRcdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjguM1xuXHRcdGNvbnN0IGxpdCA9IExpdGVyYWwoTWF0aC5hYnModGhpcy52YWx1ZSkpXG5cdFx0cmV0dXJuIGlzUG9zaXRpdmUodGhpcy52YWx1ZSkgPyBsaXQgOiB1bmFyeUV4cHJlc3Npb25OZWdhdGUobGl0KVxuXHR9LFxuXHRHbG9iYWxBY2Nlc3MoKSB7IHJldHVybiBJZGVudGlmaWVyKHRoaXMubmFtZSkgfSxcblx0TG9jYWxBY2Nlc3MoKSB7IHJldHVybiBhY2Nlc3NMb2NhbCh0aGlzLCB2cikgfSxcblx0TG9jYWxEZWNsYXJlKCkgeyByZXR1cm4gaWRGb3JEZWNsYXJlQ2FjaGVkKHRoaXMpIH0sXG5cdC8vIFRPRE86IERvbid0IGFsd2F5cyBsYWJlbCFcblx0TG9vcCgpIHtcblx0XHRyZXR1cm4gTGFiZWxlZFN0YXRlbWVudChsb29wSWQodGhpcyksIHdoaWxlU3RhdGVtZW50SW5maW5pdGUodCh0aGlzLmJsb2NrKSkpXG5cdH0sXG5cdE1hcFJldHVybigpIHtcblx0XHRyZXR1cm4gbXNNYXAoZmxhdE1hcChyYW5nZSgwLCB0aGlzLmxlbmd0aCksIGkgPT5cblx0XHRcdFsgaWRDYWNoZWQoJ19rJyArIGkudG9TdHJpbmcoKSksIGlkQ2FjaGVkKCdfdicgKyBpLnRvU3RyaW5nKCkpIF0pKVxuXHR9LFxuXHRNYXBFbnRyeSgpIHtcblx0XHRyZXR1cm4gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFtcblx0XHRcdFZhcmlhYmxlRGVjbGFyYXRvcihpZENhY2hlZChgX2ske3RoaXMuaW5kZXh9YCksIHQodGhpcy5rZXkpKSxcblx0XHRcdFZhcmlhYmxlRGVjbGFyYXRvcihpZENhY2hlZChgX3Yke3RoaXMuaW5kZXh9YCksIHQodGhpcy52YWwpKVxuXHRcdF0pXG5cdH0sXG5cdE1lbWJlcigpIHtcblx0XHRyZXR1cm4gbWVtYmVyKHQodGhpcy5vYmplY3QpLCB0aGlzLm5hbWUpXG5cdH0sXG5cdE1vZHVsZSgpIHsgcmV0dXJuIHRyYW5zcGlsZU1vZHVsZSh0aGlzLCBjeCkgfSxcblx0Ly8gVE9ETzpFUzYgVXNlIGBleHBvcnQgZGVmYXVsdGBcblx0TW9kdWxlRGVmYXVsdEV4cG9ydCgpIHtcblx0XHRjb25zdCBtID0gbWVtYmVyKElkRXhwb3J0cywgJ2RlZmF1bHQnKVxuXHRcdHJldHVybiBBc3NpZ25tZW50RXhwcmVzc2lvbignPScsIG0sIHQodGhpcy52YWx1ZSkpXG5cdH0sXG5cdFF1b3RlKCkge1xuXHRcdC8vIFRPRE86RVM2IHVzZSB0ZW1wbGF0ZSBzdHJpbmdzXG5cdFx0Y29uc3QgcGFydDAgPSB0aGlzLnBhcnRzWzBdXG5cdFx0Y29uc3QgWyBmaXJzdCwgcmVzdFBhcnRzIF0gPVxuXHRcdFx0dHlwZW9mIHBhcnQwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFsgTGl0ZXJhbChwYXJ0MCksIHRhaWwodGhpcy5wYXJ0cykgXSA6XG5cdFx0XHRcdFsgTGl0RW1wdHlTdHJpbmcsIHRoaXMucGFydHMgXVxuXHRcdHJldHVybiByZXN0UGFydHMucmVkdWNlKFxuXHRcdFx0KGV4LCBfKSA9PlxuXHRcdFx0XHRiaW5hcnlFeHByZXNzaW9uUGx1cyhleCwgdHlwZW9mIF8gPT09ICdzdHJpbmcnID8gTGl0ZXJhbChfKSA6IG1zU2hvdyhbIHQoXykgXSkpLFxuXHRcdFx0Zmlyc3QpXG5cdH0sXG5cdFNwZWNpYWwoKSB7XG5cdFx0Ly8gTWFrZSBuZXcgb2JqZWN0cyBiZWNhdXNlIHdlIHdpbGwgYXNzaWduIGBsb2NgIHRvIHRoZW0uXG5cdFx0c3dpdGNoICh0aGlzLmspIHtcblx0XHRcdGNhc2UgJ2NvbnRhaW5zJzogcmV0dXJuIG1lbWJlcihJZE1zLCAnY29udGFpbnMnKVxuXHRcdFx0Y2FzZSAnZGVidWdnZXInOiByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQoKVxuXHRcdFx0Y2FzZSAnc3ViJzogcmV0dXJuIG1lbWJlcihJZE1zLCAnc3ViJylcblx0XHRcdGNhc2UgJ3RoaXMnOiByZXR1cm4gXHRUaGlzRXhwcmVzc2lvbigpXG5cdFx0XHRjYXNlICd0aGlzLW1vZHVsZS1kaXJlY3RvcnknOiByZXR1cm4gSWRlbnRpZmllcignX19kaXJuYW1lJylcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcih0aGlzLmspXG5cdFx0fVxuXHR9LFxuXHRTcGxhdCgpIHsgY3guZmFpbCh0aGlzLmxvYywgJ1NwbGF0IG11c3QgYXBwZWFyIGFzIGFyZ3VtZW50IHRvIGEgY2FsbC4nKSB9LFxuXHRZaWVsZCgpIHsgcmV0dXJuIHlpZWxkRXhwcmVzc2lvbk5vRGVsZWdhdGUodCh0aGlzLnlpZWxkZWQpKSB9LFxuXHRZaWVsZFRvKCkgeyByZXR1cm4geWllbGRFeHByZXNzaW9uRGVsZWdhdGUodCh0aGlzLnlpZWxkZWRUbykpIH1cbn0pXG5cbmNvbnN0IGJsb2NrV3JhcCA9IChfLCBibG9jaykgPT4ge1xuXHRjb25zdCBnID0gaXNJbkdlbmVyYXRvclxuXHRjb25zdCBpbnZva2UgPSBjYWxsRXhwcmVzc2lvblRodW5rKGZ1bmN0aW9uRXhwcmVzc2lvblRodW5rKGJsb2NrLCBnKSlcblx0cmV0dXJuIGcgPyB5aWVsZEV4cHJlc3Npb25EZWxlZ2F0ZShpbnZva2UpIDogaW52b2tlXG59XG5cbmNvbnN0IGNhc2VGYWlsID0gU3dpdGNoQ2FzZShudWxsLCBbIHRocm93RXJyb3IoJ05vIGJyYW5jaCBvZiBgY2FzZWAgbWF0Y2hlcy4nKSBdKVxuZnVuY3Rpb24gY2FzZUJvZHkocGFydHMsIG9wRWxzZSkge1xuXHRjb25zdCBlbHplID0gaWZFbHNlKG9wRWxzZSxcblx0XHRfID0+IFN3aXRjaENhc2UobnVsbCwgWyB0KF8pIF0pLFxuXHRcdCgpID0+IGNhc2VGYWlsKVxuXHRjb25zdCBjYXNlcyA9IHB1c2gocGFydHMubWFwKHBhcnQgPT4gdChwYXJ0KSksIGVsemUpXG5cdHJldHVybiBzd2l0Y2hTdGF0ZW1lbnRPblRydWUoY2FzZXMpXG59XG5cbmZ1bmN0aW9uIGNhc2VQYXJ0KHRlc3QsIHJlc3VsdCwgbmVlZEJyZWFrKSB7XG5cdGNvbnN0IGNoZWNrZWRUZXN0ID0gY3gub3B0cy5pbmNsdWRlQ2FzZUNoZWNrcygpID8gbXNCb29sKFsgdCh0ZXN0KSBdKSA6IHQodGVzdClcblx0Y29uc3QgbGluZXMgPSBuZWVkQnJlYWsgPyBbIHQocmVzdWx0KSwgQnJlYWsgXSA6IFsgdChyZXN1bHQpIF1cblx0cmV0dXJuIFN3aXRjaENhc2UoY2hlY2tlZFRlc3QsIGxpbmVzKVxufVxuXG4vLyBUT0RPOiBNT1ZFXG5jb25zdCBsb29wSWQgPSBsb29wID0+IHtcblx0cmV0dXJuIGlkQ2FjaGVkKGBsb29wJHtsb29wLmxvYy5zdGFydC5saW5lfWApXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==