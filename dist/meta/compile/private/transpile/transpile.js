if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', 'esast/dist/specialize', '../../Expression', '../U/Bag', '../U/Op', '../U/util', './esast-util', './transpileObj', './transpileModule', './util'], function (exports, _esastDistAst, _esastDistUtil, _esastDistSpecialize, _Expression, _UBag, _UOp, _UUtil, _esastUtil, _transpileObj, _transpileModule, _util) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	exports.default = transpile;

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _transpileModule2 = _interopRequire(_transpileModule);

	const ExtractVar = _esastDistAst.Identifier('_$');

	let cx, vr, isInGenerator;

	function transpile(_cx, e, _vr) {
		cx = _cx;
		vr = _vr;
		isInGenerator = false;
		const res = t0(e);
		// Release for garbage collection
		cx = vr = undefined;
		return res;
	}

	const t0 = function (expr) {
		const ast = expr.transpileSubtree();
		ast.loc = expr.loc;
		return ast;
	};
	exports.t0 = t0;
	const t1 = function (expr, arg) {
		const ast = expr.transpileSubtree(arg);
		ast.loc = expr.loc;
		return ast;
	};
	const t3 = function (expr, arg, arg2, arg3) {
		const ast = expr.transpileSubtree(arg, arg2, arg3);
		ast.loc = expr.loc;
		return ast;
	};
	exports.t3 = t3;
	const tm = function (expr) {
		const ast = expr.transpileSubtree();
		if (!(ast instanceof Array))
			// Debug may produce multiple statements.
			ast.loc = expr.loc;
		return ast;
	};

	const toStatements = function (_) {
		return _ instanceof Array ? _.map(_esastDistUtil.toStatement) : [_esastDistUtil.toStatement(_)];
	};

	function transpileBlock(lead, opResDeclare, opOut) {
		var _this = this;

		if (lead === undefined) lead = [];
		if (opResDeclare === undefined) opResDeclare = opOut = _UOp.None;
		const body = _UBag.flatMap(this.lines, function (line) {
			return toStatements(tm(line));
		});
		const isVal = this instanceof _Expression.BlockVal;
		const fin = _UOp.ifElse(opResDeclare, function (rd) {
			_UUtil.assert(isVal);
			const returned = _util.maybeWrapInCheckContains(cx, t0(_this.returned), rd.opType, 'res');
			return _UOp.ifElse(opOut, function (o) {
				return [_esastUtil.declare(rd, returned)].concat(o, [_util.ReturnRes]);
			}, function () {
				return [_esastDistAst.ReturnStatement(returned)];
			});
		}, function () {
			return opOut.concat(_UOp.opIf(isVal, function () {
				return _esastDistAst.ReturnStatement(t0(_this.returned));
			}));
		});
		return _esastDistAst.BlockStatement(lead.concat(body, fin));
	}

	function casePart(alternate) {
		if (this.test instanceof _Expression.Pattern) {
			const decl = _esastDistSpecialize.variableDeclarationConst([_esastDistAst.VariableDeclarator(ExtractVar, _util.msExtract(t0(this.test.type), t0(this.test.patterned)))]);
			const test = _esastUtil.binaryExpressionNotEqual(ExtractVar, _esastDistAst.Literal(null));
			const ext = arrayExtract(this.test.locals);
			const res = t3(this.result, [ext]);
			return _esastDistAst.BlockStatement([decl, _esastDistAst.IfStatement(test, res, alternate)]);
		} else {
			const checkedTest = cx.opts.includeCaseChecks() ? _util.msBool(t0(this.test)) : t0(this.test);
			// alternate written to by `caseBody`.
			return _esastDistAst.IfStatement(checkedTest, t0(this.result), alternate);
		}
	}

	_UUtil.implementMany(_Expression, 'transpileSubtree', {
		Assign: function () {
			return _esastDistSpecialize.variableDeclarationConst([_util.makeDeclarator(cx, this.loc, this.assignee, this.k, t0(this.value))]);
		},
		// TODO:ES6 Just use native destructuring assign
		AssignDestructure: function () {
			return _esastDistSpecialize.variableDeclarationConst(_util.makeDestructureDeclarators(cx, this.loc, this.assignees, this.isLazy, t0(this.value), this.k, false));
		},
		BlockDo: transpileBlock,
		BlockVal: transpileBlock,
		BlockWrap: function () {
			return blockWrap(this, t0(this.block));
		},
		Call: function () {
			const anySplat = this.args.some(function (arg) {
				return arg instanceof _Expression.Splat;
			});
			if (anySplat) {
				const args = this.args.map(function (arg) {
					return arg instanceof _Expression.Splat ? _util.msArr(t0(arg.splatted)) : t0(arg);
				});
				return _esastDistAst.CallExpression(_util.IdFunctionApplyCall, [t0(this.called), _util.LitNull, _esastDistAst.CallExpression(_esastDistUtil.member(_util.LitEmptyArray, 'concat'), args)]);
			} else return _esastDistAst.CallExpression(t0(this.called), this.args.map(t0));
		},
		CaseDo: function () {
			const body = caseBody(this.parts, this.opElse);
			return _UOp.ifElse(this.opCased, function (cased) {
				return _esastDistAst.BlockStatement([t0(cased), body]);
			}, function () {
				return body;
			});
		},
		CaseVal: function () {
			const body = caseBody(this.parts, this.opElse);
			const block = _UOp.ifElse(this.opCased, function (cased) {
				return [t0(cased), body];
			}, function () {
				return [body];
			});
			return blockWrap(this, _esastDistAst.BlockStatement(block));
		},
		CaseDoPart: casePart,
		CaseValPart: casePart,
		// TODO: includeInoutChecks is misnamed
		Debug: function () {
			return cx.opts.includeInoutChecks() ? _UBag.flatMap(this.lines, function (line) {
				return toStatements(t0(line));
			}) : [];
		},
		ObjReturn: function () {
			return _transpileObj.transpileObjReturn(this, cx);
		},
		ObjSimple: function () {
			return _esastDistAst.ObjectExpression(this.pairs.map(function (pair) {
				return _esastDistSpecialize.property('init', _esastDistUtil.propertyIdOrLiteralCached(pair.key), t0(pair.value));
			}));
		},
		EndLoop: function () {
			return _esastDistAst.BreakStatement(loopId(vr.endLoopToLoop.get(this)));
		},
		Fun: function () {
			const oldInGenerator = isInGenerator;
			isInGenerator = this.isGenerator;

			// TODO:ES6 use `...`
			const nArgs = _esastDistAst.Literal(this.args.length);
			const opDeclareRest = this.opRestArg.map(function (rest) {
				return _esastUtil.declare(rest, _esastDistAst.CallExpression(_util.IdArraySliceCall, [_util.IdArguments, nArgs]));
			});
			const argChecks = _UBag.flatMap(this.args, function (arg) {
				return _util.opLocalCheck(cx, arg, arg.isLazy);
			});
			const _in = _UBag.flatMap(this.opIn, function (i) {
				return toStatements(t0(i));
			});
			const lead = opDeclareRest.concat(argChecks, _in);

			const _out = _UBag.flatMap(this.opOut, function (o) {
				return toStatements(t0(o));
			});
			const body = t3(this.block, lead, this.opResDeclare, _out);
			const args = this.args.map(t0);
			const res = _esastDistSpecialize.functionExpressionPlain(args, body, this.isGenerator);

			isInGenerator = oldInGenerator;
			return res;
		},
		Lazy: function () {
			return _util.lazyWrap(t0(this.value));
		},
		ListReturn: function () {
			const length = vr.listMapLength(this);
			_UUtil.assert(length >= 0);
			return _esastDistAst.ArrayExpression(_UBag.range(0, length).map(function (i) {
				return _esastDistUtil.idCached('_' + i);
			}));
		},
		ListSimple: function () {
			return _esastDistAst.ArrayExpression(this.parts.map(t0));
		},
		ListEntry: function () {
			return _esastUtil.declareSpecial('_' + vr.listMapEntryIndex(this), t0(this.value));
		},
		NumberLiteral: function () {
			// Negative numbers are not part of ES spec.
			// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3
			const lit = _esastDistAst.Literal(Math.abs(this.value));
			return _UUtil.isPositive(this.value) ? lit : _esastUtil.unaryExpressionNegate(lit);
		},
		GlobalAccess: function () {
			return _esastDistAst.Identifier(this.name);
		},
		LocalAccess: function () {
			return _util.accessLocal(this, vr);
		},
		LocalDeclare: function () {
			return _esastUtil.idForDeclareCached(this);
		},
		// TODO: Don't always label!
		Loop: function () {
			return _esastDistAst.LabeledStatement(loopId(this), _esastUtil.whileStatementInfinite(t0(this.block)));
		},
		MapEntry: function () {
			const index = vr.listMapEntryIndex(this);
			const k = '_k' + index;
			const v = '_v' + index;
			return _esastDistSpecialize.variableDeclarationConst([_esastDistAst.VariableDeclarator(_esastDistUtil.idCached(k), t0(this.key)), _esastDistAst.VariableDeclarator(_esastDistUtil.idCached(v), t0(this.val))]);
		},
		MapReturn: function () {
			const length = vr.listMapLength(this);
			return _util.msMap.apply(undefined, _toConsumableArray(_UBag.flatMap(_UBag.range(0, length), function (i) {
				return [_esastDistUtil.idCached('_k' + i), _esastDistUtil.idCached('_v' + i)];
			})));
		},
		Member: function () {
			return _esastDistUtil.member(t0(this.object), this.name);
		},
		Module: function () {
			return _transpileModule2(this, cx);
		},
		// TODO:ES6 Use `export default`
		ModuleDefaultExport: function () {
			const m = _esastDistUtil.member(_util.IdExports, 'default');
			return _esastDistAst.AssignmentExpression('=', m, t0(this.value));
		},
		Quote: function () {
			// TODO:ES6 use template strings
			const part0 = this.parts[0];

			var _ref = typeof part0 === 'string' ? [_esastDistAst.Literal(part0), _UBag.tail(this.parts)] : [_util.LitEmptyString, this.parts];

			var _ref2 = _slicedToArray(_ref, 2);

			const first = _ref2[0];
			const restParts = _ref2[1];

			return restParts.reduce(function (ex, _) {
				return _esastUtil.binaryExpressionPlus(ex, typeof _ === 'string' ? _esastDistAst.Literal(_) : _util.msShow(t0(_)));
			}, first);
		},
		Special: function () {
			// Make new objects because we will assign `loc` to them.
			switch (this.k) {
				case _Expression.SP_Contains:
					return _esastDistUtil.member(_util.IdMs, 'contains');
				case _Expression.SP_Debugger:
					return _esastDistAst.DebuggerStatement();
				case _Expression.SP_Sub:
					return _esastDistUtil.member(_util.IdMs, 'sub');
				case _Expression.SP_This:
					return _esastDistAst.ThisExpression();
				case _Expression.SP_ThisModuleDirectory:
					return _esastDistAst.Identifier('__dirname');
				default:
					throw new Error(this.k);
			}
		},
		Splat: function () {
			cx.fail(this.loc, 'Splat must appear as argument to a call.');
		},
		Yield: function () {
			return _esastDistSpecialize.yieldExpressionNoDelegate(t0(this.yielded));
		},
		YieldTo: function () {
			return _esastDistSpecialize.yieldExpressionDelegate(t0(this.yieldedTo));
		}
	});

	const arrayExtract = function (locals) {
		return _esastDistSpecialize.variableDeclarationConst(locals.map(function (l, index) {
			return _esastDistAst.VariableDeclarator(_esastUtil.idForDeclareCached(l), _esastDistSpecialize.memberExpression(ExtractVar, _esastDistAst.Literal(index)));
		}));
	},
	      blockWrap = function (_, block) {
		const invoke = _esastDistSpecialize.callExpressionThunk(_esastDistSpecialize.functionExpressionThunk(block, isInGenerator));
		return isInGenerator ? _esastDistSpecialize.yieldExpressionDelegate(invoke) : invoke;
	},
	      caseBody = function (parts, opElse) {
		let acc = _UOp.ifElse(opElse, t0, function () {
			return _esastUtil.throwError('No branch of `case` matches.');
		});
		for (let i = parts.length - 1; i >= 0; i = i - 1) acc = t1(parts[i], acc);
		return acc;
	},
	      loopId = function (loop) {
		return _esastDistUtil.idCached('loop' + loop.loc.start.line);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3RyYW5zcGlsZS90cmFuc3BpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O21CQThCd0IsU0FBUzs7Ozs7Ozs7OztBQUpqQyxPQUFNLFVBQVUsR0FBRyxjQXpCaUIsVUFBVSxDQXlCaEIsSUFBSSxDQUFDLENBQUE7O0FBRW5DLEtBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxhQUFhLENBQUE7O0FBRVYsVUFBUyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDOUMsSUFBRSxHQUFHLEdBQUcsQ0FBQTtBQUNSLElBQUUsR0FBRyxHQUFHLENBQUE7QUFDUixlQUFhLEdBQUcsS0FBSyxDQUFBO0FBQ3JCLFFBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7QUFFakIsSUFBRSxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUE7QUFDbkIsU0FBTyxHQUFHLENBQUE7RUFDVjs7QUFFTSxPQUFNLEVBQUUsR0FBRyxVQUFBLElBQUksRUFBSTtBQUN6QixRQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQTtBQUNuQyxLQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUE7QUFDbEIsU0FBTyxHQUFHLENBQUE7RUFDVixDQUFBO1NBSlksRUFBRSxHQUFGLEVBQUU7QUFLZixPQUFNLEVBQUUsR0FBRyxVQUFDLElBQUksRUFBRSxHQUFHLEVBQUs7QUFDekIsUUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQ3RDLEtBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQTtBQUNsQixTQUFPLEdBQUcsQ0FBQTtFQUNWLENBQUE7QUFDTSxPQUFNLEVBQUUsR0FBRyxVQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBSztBQUM1QyxRQUFNLEdBQUcsR0FB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Q0FpUVgsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFBO0VBQy9EO09BRUQsUUFBUSxHQUFHLFVBQUMsS0FBSyxFQUFFLE1BQU0sRUFBSztBQUM3QixNQUFJLEdBQUcsR0FBRyxLQTlQSCxNQUFNLENBOFBJLE1BQU0sRUFBRSxFQUFFLEVBQUU7VUFBTSxXQTNQaEIsVUFBVSxDQTJQaUIsOEJBQThCLENBQUM7R0FBQSxDQUFDLENBQUE7QUFDOUUsT0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUMvQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtBQUN4QixTQUFPLEdBQUcsQ0FBQTtFQUNWO09BRUQsTUFBTSxHQUFHLFVBQUEsSUFBSTtTQUFJLGVBN1FULFFBQVEsVUE2UWlCLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBRztFQUFBLENBQUEiLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvdHJhbnNwaWxlL3RyYW5zcGlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFycmF5RXhwcmVzc2lvbiwgQXNzaWdubWVudEV4cHJlc3Npb24sIEJsb2NrU3RhdGVtZW50LCBCcmVha1N0YXRlbWVudCxcblx0Q2FsbEV4cHJlc3Npb24sIERlYnVnZ2VyU3RhdGVtZW50LCBJZGVudGlmaWVyLCBJZlN0YXRlbWVudCwgTGFiZWxlZFN0YXRlbWVudCwgTGl0ZXJhbCxcblx0T2JqZWN0RXhwcmVzc2lvbiwgVGhpc0V4cHJlc3Npb24sIFZhcmlhYmxlRGVjbGFyYXRvciwgUmV0dXJuU3RhdGVtZW50IH0gZnJvbSAnZXNhc3QvZGlzdC9hc3QnXG5pbXBvcnQgeyBpZENhY2hlZCwgbWVtYmVyLCBwcm9wZXJ0eUlkT3JMaXRlcmFsQ2FjaGVkLCB0b1N0YXRlbWVudCB9IGZyb20gJ2VzYXN0L2Rpc3QvdXRpbCdcbmltcG9ydCB7IGNhbGxFeHByZXNzaW9uVGh1bmssIGZ1bmN0aW9uRXhwcmVzc2lvblBsYWluLCBmdW5jdGlvbkV4cHJlc3Npb25UaHVuaywgbWVtYmVyRXhwcmVzc2lvbixcblx0cHJvcGVydHksIHZhcmlhYmxlRGVjbGFyYXRpb25Db25zdCwgeWllbGRFeHByZXNzaW9uRGVsZWdhdGUsIHlpZWxkRXhwcmVzc2lvbk5vRGVsZWdhdGVcblx0fSBmcm9tICdlc2FzdC9kaXN0L3NwZWNpYWxpemUnXG5pbXBvcnQgKiBhcyBFRXhwb3J0cyBmcm9tICcuLi8uLi9FeHByZXNzaW9uJ1xuaW1wb3J0IHsgQmxvY2tWYWwsIFBhdHRlcm4sIFNwbGF0LFxuXHRTUF9Db250YWlucywgU1BfRGVidWdnZXIsIFNQX1N1YiwgU1BfVGhpcywgU1BfVGhpc01vZHVsZURpcmVjdG9yeVxuXHR9IGZyb20gJy4uLy4uL0V4cHJlc3Npb24nXG5pbXBvcnQgeyBmbGF0TWFwLCByYW5nZSwgdGFpbCB9IGZyb20gJy4uL1UvQmFnJ1xuaW1wb3J0IHsgaWZFbHNlLCBOb25lLCBvcElmIH0gZnJvbSAnLi4vVS9PcCdcbmltcG9ydCB7IGFzc2VydCwgaW1wbGVtZW50TWFueSwgaXNQb3NpdGl2ZSB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCB7IGJpbmFyeUV4cHJlc3Npb25QbHVzLCBiaW5hcnlFeHByZXNzaW9uTm90RXF1YWwsIGRlY2xhcmUsIGRlY2xhcmVTcGVjaWFsLFxuXHRpZEZvckRlY2xhcmVDYWNoZWQsIHRocm93RXJyb3IsIHVuYXJ5RXhwcmVzc2lvbk5lZ2F0ZSwgd2hpbGVTdGF0ZW1lbnRJbmZpbml0ZVxuXHR9IGZyb20gJy4vZXNhc3QtdXRpbCdcbmltcG9ydCB7IHRyYW5zcGlsZU9ialJldHVybiB9IGZyb20gJy4vdHJhbnNwaWxlT2JqJ1xuaW1wb3J0IHRyYW5zcGlsZU1vZHVsZSBmcm9tICcuL3RyYW5zcGlsZU1vZHVsZSdcbmltcG9ydCB7XG5cdElkQXJndW1lbnRzLCBJZEFycmF5U2xpY2VDYWxsLCBJZEV4cG9ydHMsIElkRnVuY3Rpb25BcHBseUNhbGwsIElkTXMsXG5cdExpdEVtcHR5QXJyYXksIExpdEVtcHR5U3RyaW5nLCBMaXROdWxsLCBSZXR1cm5SZXMsXG5cdGFjY2Vzc0xvY2FsLCBsYXp5V3JhcCwgbWFrZURlY2xhcmF0b3IsIG1ha2VEZXN0cnVjdHVyZURlY2xhcmF0b3JzLFxuXHRtYXliZVdyYXBJbkNoZWNrQ29udGFpbnMsIG9wTG9jYWxDaGVjayxcblx0bXNBcnIsIG1zQm9vbCwgbXNFeHRyYWN0LCBtc01hcCwgbXNTaG93IH0gZnJvbSAnLi91dGlsJ1xuXG5jb25zdCBFeHRyYWN0VmFyID0gSWRlbnRpZmllcignXyQnKVxuXG5sZXQgY3gsIHZyLCBpc0luR2VuZXJhdG9yXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zcGlsZShfY3gsIGUsIF92cikge1xuXHRjeCA9IF9jeFxuXHR2ciA9IF92clxuXHRpc0luR2VuZXJhdG9yID0gZmFsc2Vcblx0Y29uc3QgcmVzID0gdDAoZSlcblx0Ly8gUmVsZWFzZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdGN4ID0gdnIgPSB1bmRlZmluZWRcblx0cmV0dXJuIHJlc1xufVxuXG5leHBvcnQgY29uc3QgdDAgPSBleHByID0+IHtcblx0Y29uc3QgYXN0ID0gZXhwci50cmFuc3BpbGVTdWJ0cmVlKClcblx0YXN0LmxvYyA9IGV4cHIubG9jXG5cdHJldHVybiBhc3Rcbn1cbmNvbnN0IHQxID0gKGV4cHIsIGFyZykgPT4ge1xuXHRjb25zdCBhc3QgPSBleHByLnRyYW5zcGlsZVN1YnRyZWUoYXJnKVxuXHRhc3QubG9jID0gZXhwci5sb2Ncblx0cmV0dXJuIGFzdFxufVxuZXhwb3J0IGNvbnN0IHQzID0gKGV4cHIsIGFyZywgYXJnMiwgYXJnMykgPT4ge1xuXHRjb25zdCBhc3QgPSBleHByLnRyYW5zcGlsZVN1YnRyZWUoYXJnLCBhcmcyLCBhcmczKVxuXHRhc3QubG9jID0gZXhwci5sb2Ncblx0cmV0dXJuIGFzdFxufVxuY29uc3QgdG0gPSBleHByID0+IHtcblx0Y29uc3QgYXN0ID0gZXhwci50cmFuc3BpbGVTdWJ0cmVlKClcblx0aWYgKCEoYXN0IGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdC8vIERlYnVnIG1heSBwcm9kdWNlIG11bHRpcGxlIHN0YXRlbWVudHMuXG5cdFx0YXN0LmxvYyA9IGV4cHIubG9jXG5cdHJldHVybiBhc3Rcbn1cblxuY29uc3QgdG9TdGF0ZW1lbnRzID0gXyA9PiBfIGluc3RhbmNlb2YgQXJyYXkgPyBfLm1hcCh0b1N0YXRlbWVudCkgOiBbIHRvU3RhdGVtZW50KF8pIF1cblxuZnVuY3Rpb24gdHJhbnNwaWxlQmxvY2sobGVhZCwgb3BSZXNEZWNsYXJlLCBvcE91dCkge1xuXHRpZiAobGVhZCA9PT0gdW5kZWZpbmVkKVxuXHRcdGxlYWQgPSBbXVxuXHRpZiAob3BSZXNEZWNsYXJlID09PSB1bmRlZmluZWQpXG5cdFx0b3BSZXNEZWNsYXJlID0gb3BPdXQgPSBOb25lXG5cdGNvbnN0IGJvZHkgPSBmbGF0TWFwKHRoaXMubGluZXMsIGxpbmUgPT4gdG9TdGF0ZW1lbnRzKHRtKGxpbmUpKSlcblx0Y29uc3QgaXNWYWwgPSB0aGlzIGluc3RhbmNlb2YgQmxvY2tWYWxcblx0Y29uc3QgZmluID0gaWZFbHNlKG9wUmVzRGVjbGFyZSxcblx0XHRyZCA9PiB7XG5cdFx0XHRhc3NlcnQoaXNWYWwpXG5cdFx0XHRjb25zdCByZXR1cm5lZCA9IG1heWJlV3JhcEluQ2hlY2tDb250YWlucyhjeCwgdDAodGhpcy5yZXR1cm5lZCksIHJkLm9wVHlwZSwgJ3JlcycpXG5cdFx0XHRyZXR1cm4gaWZFbHNlKG9wT3V0LFxuXHRcdFx0XHRvID0+IFsgZGVjbGFyZShyZCwgcmV0dXJuZWQpIF0uY29uY2F0KG8sIFsgUmV0dXJuUmVzIF0pLFxuXHRcdFx0XHQoKSA9PiBbIFJldHVyblN0YXRlbWVudChyZXR1cm5lZCkgXSlcblx0XHR9LFxuXHRcdCgpID0+IG9wT3V0LmNvbmNhdChvcElmKGlzVmFsLCAoKSA9PiBSZXR1cm5TdGF0ZW1lbnQodDAodGhpcy5yZXR1cm5lZCkpKSkpXG5cdHJldHVybiBCbG9ja1N0YXRlbWVudChsZWFkLmNvbmNhdChib2R5LCBmaW4pKVxufVxuXG5mdW5jdGlvbiBjYXNlUGFydChhbHRlcm5hdGUpIHtcblx0aWYgKHRoaXMudGVzdCBpbnN0YW5jZW9mIFBhdHRlcm4pIHtcblx0XHRjb25zdCBkZWNsID0gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFtcblx0XHRcdFZhcmlhYmxlRGVjbGFyYXRvcihcblx0XHRcdFx0RXh0cmFjdFZhcixcblx0XHRcdFx0bXNFeHRyYWN0KHQwKHRoaXMudGVzdC50eXBlKSwgdDAodGhpcy50ZXN0LnBhdHRlcm5lZCkpKVxuXHRcdFx0XSlcblx0XHRjb25zdCB0ZXN0ID0gYmluYXJ5RXhwcmVzc2lvbk5vdEVxdWFsKEV4dHJhY3RWYXIsIExpdGVyYWwobnVsbCkpXG5cdFx0Y29uc3QgZXh0ID0gYXJyYXlFeHRyYWN0KHRoaXMudGVzdC5sb2NhbHMpXG5cdFx0Y29uc3QgcmVzID0gdDModGhpcy5yZXN1bHQsIFsgZXh0IF0pXG5cdFx0cmV0dXJuIEJsb2NrU3RhdGVtZW50KFsgZGVjbCwgSWZTdGF0ZW1lbnQodGVzdCwgcmVzLCBhbHRlcm5hdGUpIF0pXG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgY2hlY2tlZFRlc3QgPSBjeC5vcHRzLmluY2x1ZGVDYXNlQ2hlY2tzKCkgPyBtc0Jvb2wodDAodGhpcy50ZXN0KSkgOiB0MCh0aGlzLnRlc3QpXG5cdFx0Ly8gYWx0ZXJuYXRlIHdyaXR0ZW4gdG8gYnkgYGNhc2VCb2R5YC5cblx0XHRyZXR1cm4gSWZTdGF0ZW1lbnQoY2hlY2tlZFRlc3QsIHQwKHRoaXMucmVzdWx0KSwgYWx0ZXJuYXRlKVxuXHR9XG59XG5cbmltcGxlbWVudE1hbnkoRUV4cG9ydHMsICd0cmFuc3BpbGVTdWJ0cmVlJywge1xuXHRBc3NpZ24oKSB7XG5cdFx0cmV0dXJuIHZhcmlhYmxlRGVjbGFyYXRpb25Db25zdChbXG5cdFx0XHRtYWtlRGVjbGFyYXRvcihjeCwgdGhpcy5sb2MsIHRoaXMuYXNzaWduZWUsIHRoaXMuaywgdDAodGhpcy52YWx1ZSkpIF0pXG5cdH0sXG5cdC8vIFRPRE86RVM2IEp1c3QgdXNlIG5hdGl2ZSBkZXN0cnVjdHVyaW5nIGFzc2lnblxuXHRBc3NpZ25EZXN0cnVjdHVyZSgpIHtcblx0XHRyZXR1cm4gdmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFxuXHRcdFx0bWFrZURlc3RydWN0dXJlRGVjbGFyYXRvcnMoXG5cdFx0XHRcdGN4LFxuXHRcdFx0XHR0aGlzLmxvYyxcblx0XHRcdFx0dGhpcy5hc3NpZ25lZXMsXG5cdFx0XHRcdHRoaXMuaXNMYXp5LFxuXHRcdFx0XHR0MCh0aGlzLnZhbHVlKSxcblx0XHRcdFx0dGhpcy5rLFxuXHRcdFx0XHRmYWxzZSkpXG5cdH0sXG5cdEJsb2NrRG86IHRyYW5zcGlsZUJsb2NrLFxuXHRCbG9ja1ZhbDogdHJhbnNwaWxlQmxvY2ssXG5cdEJsb2NrV3JhcCgpIHsgcmV0dXJuIGJsb2NrV3JhcCh0aGlzLCB0MCh0aGlzLmJsb2NrKSkgfSxcblx0Q2FsbCgpIHtcblx0XHRjb25zdCBhbnlTcGxhdCA9IHRoaXMuYXJncy5zb21lKGFyZyA9PiBhcmcgaW5zdGFuY2VvZiBTcGxhdClcblx0XHRpZiAoYW55U3BsYXQpIHtcblx0XHRcdGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGFyZyA9PlxuXHRcdFx0XHRhcmcgaW5zdGFuY2VvZiBTcGxhdCA/XG5cdFx0XHRcdFx0bXNBcnIodDAoYXJnLnNwbGF0dGVkKSkgOlxuXHRcdFx0XHRcdHQwKGFyZykpXG5cdFx0XHRyZXR1cm4gQ2FsbEV4cHJlc3Npb24oSWRGdW5jdGlvbkFwcGx5Q2FsbCwgW1xuXHRcdFx0XHR0MCh0aGlzLmNhbGxlZCksXG5cdFx0XHRcdExpdE51bGwsXG5cdFx0XHRcdENhbGxFeHByZXNzaW9uKG1lbWJlcihMaXRFbXB0eUFycmF5LCAnY29uY2F0JyksIGFyZ3MpXSlcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gQ2FsbEV4cHJlc3Npb24odDAodGhpcy5jYWxsZWQpLCB0aGlzLmFyZ3MubWFwKHQwKSlcblx0fSxcblx0Q2FzZURvKCkge1xuXHRcdGNvbnN0IGJvZHkgPSBjYXNlQm9keSh0aGlzLnBhcnRzLCB0aGlzLm9wRWxzZSlcblx0XHRyZXR1cm4gaWZFbHNlKHRoaXMub3BDYXNlZCxcblx0XHRcdGNhc2VkID0+IEJsb2NrU3RhdGVtZW50KFsgdDAoY2FzZWQpLCBib2R5IF0pLFxuXHRcdFx0KCkgPT4gYm9keSlcblx0fSxcblx0Q2FzZVZhbCgpIHtcblx0XHRjb25zdCBib2R5ID0gY2FzZUJvZHkodGhpcy5wYXJ0cywgdGhpcy5vcEVsc2UpXG5cdFx0Y29uc3QgYmxvY2sgPSBpZkVsc2UodGhpcy5vcENhc2VkLCBjYXNlZCA9PiBbIHQwKGNhc2VkKSwgYm9keSBdLCAoKSA9PiBbIGJvZHkgXSlcblx0XHRyZXR1cm4gYmxvY2tXcmFwKHRoaXMsIEJsb2NrU3RhdGVtZW50KGJsb2NrKSlcblx0fSxcblx0Q2FzZURvUGFydDogY2FzZVBhcnQsXG5cdENhc2VWYWxQYXJ0OiBjYXNlUGFydCxcblx0Ly8gVE9ETzogaW5jbHVkZUlub3V0Q2hlY2tzIGlzIG1pc25hbWVkXG5cdERlYnVnKCkge1xuXHRcdHJldHVybiBjeC5vcHRzLmluY2x1ZGVJbm91dENoZWNrcygpID9cblx0XHRcdGZsYXRNYXAodGhpcy5saW5lcywgbGluZSA9PiB0b1N0YXRlbWVudHModDAobGluZSkpKSA6XG5cdFx0XHRbIF1cblx0fSxcblx0T2JqUmV0dXJuKCkgeyByZXR1cm4gdHJhbnNwaWxlT2JqUmV0dXJuKHRoaXMsIGN4KSB9LFxuXHRPYmpTaW1wbGUoKSB7XG5cdFx0cmV0dXJuIE9iamVjdEV4cHJlc3Npb24odGhpcy5wYWlycy5tYXAocGFpciA9PlxuXHRcdFx0cHJvcGVydHkoJ2luaXQnLCBwcm9wZXJ0eUlkT3JMaXRlcmFsQ2FjaGVkKHBhaXIua2V5KSwgdDAocGFpci52YWx1ZSkpKSlcblx0fSxcblx0RW5kTG9vcCgpIHsgcmV0dXJuIEJyZWFrU3RhdGVtZW50KGxvb3BJZCh2ci5lbmRMb29wVG9Mb29wLmdldCh0aGlzKSkpIH0sXG5cdEZ1bigpIHtcblx0XHRjb25zdCBvbGRJbkdlbmVyYXRvciA9IGlzSW5HZW5lcmF0b3Jcblx0XHRpc0luR2VuZXJhdG9yID0gdGhpcy5pc0dlbmVyYXRvclxuXG5cdFx0Ly8gVE9ETzpFUzYgdXNlIGAuLi5gXG5cdFx0Y29uc3QgbkFyZ3MgPSBMaXRlcmFsKHRoaXMuYXJncy5sZW5ndGgpXG5cdFx0Y29uc3Qgb3BEZWNsYXJlUmVzdCA9IHRoaXMub3BSZXN0QXJnLm1hcChyZXN0ID0+XG5cdFx0XHRkZWNsYXJlKHJlc3QsIENhbGxFeHByZXNzaW9uKElkQXJyYXlTbGljZUNhbGwsIFtJZEFyZ3VtZW50cywgbkFyZ3NdKSkpXG5cdFx0Y29uc3QgYXJnQ2hlY2tzID0gZmxhdE1hcCh0aGlzLmFyZ3MsIGFyZyA9PiBvcExvY2FsQ2hlY2soY3gsIGFyZywgYXJnLmlzTGF6eSkpXG5cdFx0Y29uc3QgX2luID0gZmxhdE1hcCh0aGlzLm9wSW4sIGkgPT4gdG9TdGF0ZW1lbnRzKHQwKGkpKSlcblx0XHRjb25zdCBsZWFkID0gb3BEZWNsYXJlUmVzdC5jb25jYXQoYXJnQ2hlY2tzLCBfaW4pXG5cblx0XHRjb25zdCBfb3V0ID0gZmxhdE1hcCh0aGlzLm9wT3V0LCBvID0+IHRvU3RhdGVtZW50cyh0MChvKSkpXG5cdFx0Y29uc3QgYm9keSA9IHQzKHRoaXMuYmxvY2ssIGxlYWQsIHRoaXMub3BSZXNEZWNsYXJlLCBfb3V0KVxuXHRcdGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKHQwKVxuXHRcdGNvbnN0IHJlcyA9IGZ1bmN0aW9uRXhwcmVzc2lvblBsYWluKGFyZ3MsIGJvZHksIHRoaXMuaXNHZW5lcmF0b3IpXG5cblx0XHRpc0luR2VuZXJhdG9yID0gb2xkSW5HZW5lcmF0b3Jcblx0XHRyZXR1cm4gcmVzXG5cdH0sXG5cdExhenkoKSB7IHJldHVybiBsYXp5V3JhcCh0MCh0aGlzLnZhbHVlKSkgfSxcblx0TGlzdFJldHVybigpIHtcblx0XHRjb25zdCBsZW5ndGggPSB2ci5saXN0TWFwTGVuZ3RoKHRoaXMpXG5cdFx0YXNzZXJ0KGxlbmd0aCA+PSAwKVxuXHRcdHJldHVybiBBcnJheUV4cHJlc3Npb24ocmFuZ2UoMCwgbGVuZ3RoKS5tYXAoaSA9PiBpZENhY2hlZChgXyR7aX1gKSkpXG5cdH0sXG5cdExpc3RTaW1wbGUoKSB7IHJldHVybiBBcnJheUV4cHJlc3Npb24odGhpcy5wYXJ0cy5tYXAodDApKSB9LFxuXHRMaXN0RW50cnkoKSB7IHJldHVybiBkZWNsYXJlU3BlY2lhbChgXyR7dnIubGlzdE1hcEVudHJ5SW5kZXgodGhpcyl9YCwgdDAodGhpcy52YWx1ZSkpIH0sXG5cdE51bWJlckxpdGVyYWwoKSB7XG5cdFx0Ly8gTmVnYXRpdmUgbnVtYmVycyBhcmUgbm90IHBhcnQgb2YgRVMgc3BlYy5cblx0XHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtNy44LjNcblx0XHRjb25zdCBsaXQgPSBMaXRlcmFsKE1hdGguYWJzKHRoaXMudmFsdWUpKVxuXHRcdHJldHVybiBpc1Bvc2l0aXZlKHRoaXMudmFsdWUpID8gbGl0IDogdW5hcnlFeHByZXNzaW9uTmVnYXRlKGxpdClcblx0fSxcblx0R2xvYmFsQWNjZXNzKCkgeyByZXR1cm4gSWRlbnRpZmllcih0aGlzLm5hbWUpIH0sXG5cdExvY2FsQWNjZXNzKCkgeyByZXR1cm4gYWNjZXNzTG9jYWwodGhpcywgdnIpIH0sXG5cdExvY2FsRGVjbGFyZSgpIHsgcmV0dXJuIGlkRm9yRGVjbGFyZUNhY2hlZCh0aGlzKSB9LFxuXHQvLyBUT0RPOiBEb24ndCBhbHdheXMgbGFiZWwhXG5cdExvb3AoKSB7XG5cdFx0cmV0dXJuIExhYmVsZWRTdGF0ZW1lbnQobG9vcElkKHRoaXMpLCB3aGlsZVN0YXRlbWVudEluZmluaXRlKHQwKHRoaXMuYmxvY2spKSlcblx0fSxcblx0TWFwRW50cnkoKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB2ci5saXN0TWFwRW50cnlJbmRleCh0aGlzKVxuXHRcdGNvbnN0IGsgPSBgX2ske2luZGV4fWBcblx0XHRjb25zdCB2ID0gYF92JHtpbmRleH1gXG5cdFx0cmV0dXJuIHZhcmlhYmxlRGVjbGFyYXRpb25Db25zdChbXG5cdFx0XHRWYXJpYWJsZURlY2xhcmF0b3IoaWRDYWNoZWQoayksIHQwKHRoaXMua2V5KSksXG5cdFx0XHRWYXJpYWJsZURlY2xhcmF0b3IoaWRDYWNoZWQodiksIHQwKHRoaXMudmFsKSlcblx0XHRdKVxuXHR9LFxuXHRNYXBSZXR1cm4oKSB7XG5cdFx0Y29uc3QgbGVuZ3RoID0gdnIubGlzdE1hcExlbmd0aCh0aGlzKVxuXHRcdHJldHVybiBtc01hcCguLi5mbGF0TWFwKHJhbmdlKDAsIGxlbmd0aCksIGkgPT5cblx0XHRcdFsgaWRDYWNoZWQoYF9rJHtpfWApLCBpZENhY2hlZChgX3Yke2l9YCkgXSkpXG5cdH0sXG5cdE1lbWJlcigpIHtcblx0XHRyZXR1cm4gbWVtYmVyKHQwKHRoaXMub2JqZWN0KSwgdGhpcy5uYW1lKVxuXHR9LFxuXHRNb2R1bGUoKSB7IHJldHVybiB0cmFuc3BpbGVNb2R1bGUodGhpcywgY3gpIH0sXG5cdC8vIFRPRE86RVM2IFVzZSBgZXhwb3J0IGRlZmF1bHRgXG5cdE1vZHVsZURlZmF1bHRFeHBvcnQoKSB7XG5cdFx0Y29uc3QgbSA9IG1lbWJlcihJZEV4cG9ydHMsICdkZWZhdWx0Jylcblx0XHRyZXR1cm4gQXNzaWdubWVudEV4cHJlc3Npb24oJz0nLCBtLCB0MCh0aGlzLnZhbHVlKSlcblx0fSxcblx0UXVvdGUoKSB7XG5cdFx0Ly8gVE9ETzpFUzYgdXNlIHRlbXBsYXRlIHN0cmluZ3Ncblx0XHRjb25zdCBwYXJ0MCA9IHRoaXMucGFydHNbMF1cblx0XHRjb25zdCBbIGZpcnN0LCByZXN0UGFydHMgXSA9XG5cdFx0XHR0eXBlb2YgcGFydDAgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0WyBMaXRlcmFsKHBhcnQwKSwgdGFpbCh0aGlzLnBhcnRzKSBdIDpcblx0XHRcdFx0WyBMaXRFbXB0eVN0cmluZywgdGhpcy5wYXJ0cyBdXG5cdFx0cmV0dXJuIHJlc3RQYXJ0cy5yZWR1Y2UoXG5cdFx0XHQoZXgsIF8pID0+XG5cdFx0XHRcdGJpbmFyeUV4cHJlc3Npb25QbHVzKGV4LCB0eXBlb2YgXyA9PT0gJ3N0cmluZycgPyBMaXRlcmFsKF8pIDogbXNTaG93KHQwKF8pKSksXG5cdFx0XHRmaXJzdClcblx0fSxcblx0U3BlY2lhbCgpIHtcblx0XHQvLyBNYWtlIG5ldyBvYmplY3RzIGJlY2F1c2Ugd2Ugd2lsbCBhc3NpZ24gYGxvY2AgdG8gdGhlbS5cblx0XHRzd2l0Y2ggKHRoaXMuaykge1xuXHRcdFx0Y2FzZSBTUF9Db250YWluczogcmV0dXJuIG1lbWJlcihJZE1zLCAnY29udGFpbnMnKVxuXHRcdFx0Y2FzZSBTUF9EZWJ1Z2dlcjogcmV0dXJuIERlYnVnZ2VyU3RhdGVtZW50KClcblx0XHRcdGNhc2UgU1BfU3ViOiByZXR1cm4gbWVtYmVyKElkTXMsICdzdWInKVxuXHRcdFx0Y2FzZSBTUF9UaGlzOiByZXR1cm4gXHRUaGlzRXhwcmVzc2lvbigpXG5cdFx0XHRjYXNlIFNQX1RoaXNNb2R1bGVEaXJlY3Rvcnk6IHJldHVybiBJZGVudGlmaWVyKCdfX2Rpcm5hbWUnKVxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKHRoaXMuaylcblx0XHR9XG5cdH0sXG5cdFNwbGF0KCkgeyBjeC5mYWlsKHRoaXMubG9jLCAnU3BsYXQgbXVzdCBhcHBlYXIgYXMgYXJndW1lbnQgdG8gYSBjYWxsLicpIH0sXG5cdFlpZWxkKCkgeyByZXR1cm4geWllbGRFeHByZXNzaW9uTm9EZWxlZ2F0ZSh0MCh0aGlzLnlpZWxkZWQpKSB9LFxuXHRZaWVsZFRvKCkgeyByZXR1cm4geWllbGRFeHByZXNzaW9uRGVsZWdhdGUodDAodGhpcy55aWVsZGVkVG8pKSB9XG59KVxuXG5jb25zdFxuXHRhcnJheUV4dHJhY3QgPSBsb2NhbHMgPT5cblx0XHR2YXJpYWJsZURlY2xhcmF0aW9uQ29uc3QobG9jYWxzLm1hcCgobCwgaW5kZXgpID0+XG5cdFx0XHRWYXJpYWJsZURlY2xhcmF0b3IoXG5cdFx0XHRcdGlkRm9yRGVjbGFyZUNhY2hlZChsKSxcblx0XHRcdFx0bWVtYmVyRXhwcmVzc2lvbihFeHRyYWN0VmFyLCBMaXRlcmFsKGluZGV4KSkpKSksXG5cblx0YmxvY2tXcmFwID0gKF8sIGJsb2NrKSA9PiB7XG5cdFx0Y29uc3QgaW52b2tlID0gY2FsbEV4cHJlc3Npb25UaHVuayhmdW5jdGlvbkV4cHJlc3Npb25UaHVuayhibG9jaywgaXNJbkdlbmVyYXRvcikpXG5cdFx0cmV0dXJuIGlzSW5HZW5lcmF0b3IgPyB5aWVsZEV4cHJlc3Npb25EZWxlZ2F0ZShpbnZva2UpIDogaW52b2tlXG5cdH0sXG5cblx0Y2FzZUJvZHkgPSAocGFydHMsIG9wRWxzZSkgPT4ge1xuXHRcdGxldCBhY2MgPSBpZkVsc2Uob3BFbHNlLCB0MCwgKCkgPT4gdGhyb3dFcnJvcignTm8gYnJhbmNoIG9mIGBjYXNlYCBtYXRjaGVzLicpKVxuXHRcdGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGkgPSBpIC0gMSlcblx0XHRcdGFjYyA9IHQxKHBhcnRzW2ldLCBhY2MpXG5cdFx0cmV0dXJuIGFjY1xuXHR9LFxuXG5cdGxvb3BJZCA9IGxvb3AgPT4gaWRDYWNoZWQoYGxvb3Ake2xvb3AubG9jLnN0YXJ0LmxpbmV9YClcbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9