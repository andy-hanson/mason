{"version":3,"sources":["meta/compile/private/parse/parseCase.js"],"names":[],"mappings":";;;;;;SAagB,SAAS,GAAT,SAAS;;;;KAbhB,MAAM,eAAN,MAAM;KAAE,SAAS,eAAT,SAAS;KAAE,MAAM,eAAN,MAAM;KAAE,OAAO,eAAP,OAAO;KAC1C,UAAU,eAAV,UAAU;KAAE,WAAW,eAAX,WAAW;KAAE,YAAY,eAAZ,YAAY;KAC7B,YAAY,SAAZ,YAAY;KACZ,OAAO,UAAP,OAAO;KACP,MAAM,QAAN,MAAM;KAAE,IAAI,QAAJ,IAAI;KAAE,IAAI,QAAJ,IAAI;KAAE,IAAI,QAAJ,IAAI;;KAC1B,IAAI;;KACF,IAAI,UAAJ,IAAI;;KACN,EAAE;;;KAEG,EAAE;KACF,SAAS;;AAGd,UAAS,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,YAAY,EAAE;AAC9C,MAAI,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,YAAY,EAAE,YAAY,EAAE,OAAO,CAAC,CAAA;AACpD,QAAM,KAAK,GAAG,CAAC,KAAK,MAAM,CAAA;;kCAEA,EAAE,CAAC,qBAAqB,CAAC,EAAE,CAAC;;QAA9C,MAAM,6BAAN,MAAM;QAAE,KAAK,6BAAL,KAAK;;AAErB,QAAM,OAAO,GAAG,CAAC,YAAM;AACtB,OAAI,YAAY,EAAE;AACjB,MAAE,CAAC,UAAU,CAAC,MAAM,EACnB,0EAA4E,CAAC,CAAA;AAC9E,WAAO,IAAI,CAAA;IACX,MACI,OAAO,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE;WACnC,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE;YAAM,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;KAAA,CAAC;IAAA,CAAC,CAAA;GACjE,CAAA,EAAG,CAAA;;AAEJ,QAAM,CAAC,GAAG,KAAK,CAAC,IAAI,EAAE,CAAA;;aACQ,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,GAAG;AAC9D,YAAS,EAAE,KAAK,CAAC,KAAK,EAAE;AACxB,SAAM,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,GAAG,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,WAAW,CAAC,CAAC;GAC7E,GAAG;AACH,YAAS,EAAE,KAAK;AAChB,SAAM,EAAE,IAAI;GACZ;;QANM,SAAS,QAAT,SAAS;QAAE,MAAM,QAAN,MAAM;;AAQzB,QAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,UAAA,IAAI,EAAI;eAElC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,EAAE,CAAC,mBAAmB,GAAG,EAAE,CAAC,kBAAkB,CAAC;;SADlE,MAAM,SAAN,MAAM;SAAE,KAAK,SAAL,KAAK;;AAErB,SAAM,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,OAAO,CAAC,CAAA;AAC5C,UAAO,CAAC,KAAK,GAAG,WAAW,GAAG,UAAU,CAAA,CAAE,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAA;GAChE,CAAC,CAAA;;AAEF,SAAO,CAAC,KAAK,GAAG,OAAO,GAAG,MAAM,CAAA,CAAE,EAAE,CAAC,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAA;EACjE","file":"meta/compile/private/parse/parseCase.js","sourcesContent":["import { Assign, BlockWrap, CaseDo, CaseVal,\n\tCaseDoPart, CaseValPart, LocalDeclare } from '../../Expression'\nimport { CaseKeywords } from '../Lang'\nimport { Keyword } from '../Token'\nimport { ifElse, None, opIf, some } from '../U/Op'\nimport type from '../U/type'\nimport { lazy } from '../U/util'\nimport Px from './Px'\n// TODO:ES6\nimport * as PB from './parseBlock'\nimport * as ParseExpr from './parseExpr'\n\n// Don't use export default because that causes circular dependency problems.\nexport function parseCase(px, k, casedFromFun) {\n\ttype(px, Px, k, CaseKeywords, casedFromFun, Boolean)\n\tconst isVal = k === 'case'\n\n\tconst { before, lines } = PB.takeBlockLinesFromEnd(px)\n\n\tconst opCased = (() => {\n\t\tif (casedFromFun) {\n\t\t\tpx.checkEmpty(before,\n\t\t\t\t'Can\\'t give focus to case - it is the function\\'s implicit first argument.')\n\t\t\treturn None\n\t\t}\n\t\telse return opIf(!before.isEmpty(), () =>\n\t\t\tpx.w(before, () => Assign.focus(px.loc, ParseExpr.default(px))))\n\t})()\n\n\tconst l = lines.last()\n\tconst { partLines, opElse } = Keyword.isElse(l.tokens.head()) ? {\n\t\t\tpartLines: lines.rtail(),\n\t\t\topElse: some(px.w(l.tokens.tail(), isVal ? PB.justBlockVal : PB.justBlockDo))\n\t\t} : {\n\t\t\tpartLines: lines,\n\t\t\topElse: None\n\t\t}\n\n\tconst parts = partLines.map(line => {\n\t\tconst { before, block } =\n\t\t\tpx.w(line.tokens, isVal ? PB.takeBlockValFromEnd : PB.takeBlockDoFromEnd)\n\t\tconst test = px.w(before, ParseExpr.default)\n\t\treturn (isVal ? CaseValPart : CaseDoPart)(line.loc, test, block)\n\t})\n\n\treturn (isVal ? CaseVal : CaseDo)(px.loc, opCased, parts, opElse)\n}\n"],"sourceRoot":"/src"}