{"version":3,"sources":["meta/compile/private/parse/parseCase.js"],"names":[],"mappings":";;;;;;;;SASgB,SAAS,GAAT,SAAS;;AAAlB,UAAS,SAAS,CAAC,CAAC,EAAE,YAAY,EAAE;AAC1C,QAAM,KAAK,GAAG,CAAC,KAAK,MAAM,CAAA;;+BAEA,YATS,qBAAqB,EASP;;QAAzC,MAAM,0BAAN,MAAM;QAAE,KAAK,0BAAL,KAAK;;AAErB,QAAM,OAAO,GAAG,CAAC,YAAM;AACtB,OAAI,YAAY,EAAE;AACjB,UAVM,UAAU,CAUL,MAAM,EAChB,4EAA4E,CAAC,CAAA;AAC9E,gBAhBM,IAAI,CAgBC;IACX,MACI,OAAO,KAlBC,IAAI,CAkBA,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE;WACnC,MAfuB,CAAC,CAetB,MAAM,EAAE;YAAM,YArBV,MAAM,CAqBW,KAAK,OAfV,GAAG,EAea,WAhB5B,SAAS,EAgB8B,CAAC;KAAA,CAAC;IAAA,CAAC,CAAA;GACjD,CAAA,EAAG,CAAA;;AAEJ,QAAM,CAAC,GAAG,KAAK,CAAC,IAAI,EAAE,CAAA;;aACQ,OAxBtB,OAAO,CAwBuB,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,GAAG;AAC9D,YAAS,EAAE,KAAK,CAAC,KAAK,EAAE;AACxB,SAAM,EAAE,KAzBU,IAAI,CAyBT,MArBU,CAAC,CAqBT,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,eAxB/B,YAAY,eAAE,WAAW,AAwBmC,CAAC,CAAC;GACpE,GAAG;AACH,YAAS,EAAE,KAAK;AAChB,SAAM,OA5BA,IAAI,AA4BE;GACZ;;QANM,SAAS,QAAT,SAAS;QAAE,MAAM,QAAN,MAAM;;AAQzB,QAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,UAAA,IAAI,EAAI;YAElC,MA7BuB,CAAC,CA6BtB,IAAI,CAAC,MAAM,EAAE,KAAK,eA/BtB,mBAAmB,eAAE,kBAAkB,AA+B0B,CAAC;;SADzD,MAAM,MAAN,MAAM;SAAE,KAAK,MAAL,KAAK;;AAErB,SAAM,IAAI,GAAG,MA9BW,CAAC,CA8BV,MAAM,aA/Bd,SAAS,CA+BiB,CAAA;AACjC,UAAO,CAAC,KAAK,eArC+B,WAAW,eAAvB,UAAU,CAqCF,CAAE,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAA;GAChE,CAAC,CAAA;;AAEF,SAAO,CAAC,KAAK,eAxCW,OAAO,eAAf,MAAM,CAwCU,OAlCZ,GAAG,EAkCgB,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAA;EAC9D","file":"meta/compile/private/parse/parseCase.js","sourcesContent":["import { Assign, CaseDo, CaseVal, CaseDoPart, CaseValPart } from '../../Expression'\nimport { Keyword } from '../Token'\nimport { None, opIf, some } from '../U/Op'\nimport { justBlockVal, justBlockDo, takeBlockLinesFromEnd,\n\ttakeBlockValFromEnd, takeBlockDoFromEnd } from './parseBlock'\nimport { parseExpr } from './parseExpr'\nimport { checkEmpty, loc, w } from './vars'\n\n// Don't use export default because that causes circular dependency problems.\nexport function parseCase(k, casedFromFun) {\n\tconst isVal = k === 'case'\n\n\tconst { before, lines } = takeBlockLinesFromEnd()\n\n\tconst opCased = (() => {\n\t\tif (casedFromFun) {\n\t\t\tcheckEmpty(before,\n\t\t\t\t'Can\\'t give focus to case - it is the function\\'s implicit first argument.')\n\t\t\treturn None\n\t\t}\n\t\telse return opIf(!before.isEmpty(), () =>\n\t\t\tw(before, () => Assign.focus(loc, parseExpr())))\n\t})()\n\n\tconst l = lines.last()\n\tconst { partLines, opElse } = Keyword.isElse(l.tokens.head()) ? {\n\t\t\tpartLines: lines.rtail(),\n\t\t\topElse: some(w(l.tokens.tail(), isVal ? justBlockVal : justBlockDo))\n\t\t} : {\n\t\t\tpartLines: lines,\n\t\t\topElse: None\n\t\t}\n\n\tconst parts = partLines.map(line => {\n\t\tconst { before, block } =\n\t\t\tw(line.tokens, isVal ? takeBlockValFromEnd : takeBlockDoFromEnd)\n\t\tconst test = w(before, parseExpr)\n\t\treturn (isVal ? CaseValPart : CaseDoPart)(line.loc, test, block)\n\t})\n\n\treturn (isVal ? CaseVal : CaseDo)(loc, opCased, parts, opElse)\n}\n"],"sourceRoot":"/src"}