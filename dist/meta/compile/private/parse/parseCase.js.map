{"version":3,"sources":["meta/compile/private/parse/parseCase.js"],"names":[],"mappings":";;;;;;;;;;SAWgB,SAAS,GAAT,SAAS;;;;;;AAAlB,UAAS,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,YAAY,EAAE;AAC9C,QAAK,EAAE,QAAM,CAAC,QAXN,YAAY,EAWU,YAAY,EAAE,OAAO,CAAC,CAAA;AACpD,QAAM,KAAK,GAAG,CAAC,KAAK,MAAM,CAAA;;kCAEA,YAAG,qBAAqB,CAAC,EAAE,CAAC;;QAA9C,MAAM,6BAAN,MAAM;QAAE,KAAK,6BAAL,KAAK;;AAErB,QAAM,OAAO,GAAG,CAAC,YAAM;AACtB,OAAI,YAAY,EAAE;AACjB,MAAE,CAAC,UAAU,CAAC,MAAM,EACnB,4EAA4E,CAAC,CAAA;AAC9E,gBAlBM,IAAI,CAkBC;IACX,MACI,OAAO,KApBC,IAAI,CAoBA,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE;WACnC,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE;YAAM,YAxBb,MAAM,CAwBc,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,WAAU,OAAO,CAAC,EAAE,CAAC,CAAC;KAAA,CAAC;IAAA,CAAC,CAAA;GACjE,CAAA,EAAG,CAAA;;AAEJ,QAAM,CAAC,GAAG,KAAK,CAAC,IAAI,EAAE,CAAA;;aACQ,OA1BtB,OAAO,CA0BuB,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,GAAG;AAC9D,YAAS,EAAE,KAAK,CAAC,KAAK,EAAE;AACxB,SAAM,EAAE,KA3BU,IAAI,CA2BT,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,GAAG,YAAG,YAAY,GAAG,YAAG,WAAW,CAAC,CAAC;GAC7E,GAAG;AACH,YAAS,EAAE,KAAK;AAChB,SAAM,OA9BA,IAAI,AA8BE;GACZ;;QANM,SAAS,QAAT,SAAS;QAAE,MAAM,QAAN,MAAM;;AAQzB,QAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,UAAA,IAAI,EAAI;eAElC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,YAAG,mBAAmB,GAAG,YAAG,kBAAkB,CAAC;;SADlE,MAAM,SAAN,MAAM;SAAE,KAAK,SAAL,KAAK;;AAErB,SAAM,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,WAAU,OAAO,CAAC,CAAA;AAC5C,UAAO,CAAC,KAAK,eAxC+B,WAAW,eAAvB,UAAU,CAwCF,CAAE,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAA;GAChE,CAAC,CAAA;;AAEF,SAAO,CAAC,KAAK,eA3CW,OAAO,eAAf,MAAM,CA2CU,CAAE,EAAE,CAAC,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAA;EACjE","file":"meta/compile/private/parse/parseCase.js","sourcesContent":["import { Assign, CaseDo, CaseVal, CaseDoPart, CaseValPart } from '../../Expression'\nimport { CaseKeywords } from '../Lang'\nimport { Keyword } from '../Token'\nimport { None, opIf, some } from '../U/Op'\nimport type from '../U/type'\nimport Px from './Px'\n// TODO:ES6\nimport * as PB from './parseBlock'\nimport * as ParseExpr from './parseExpr'\n\n// Don't use export default because that causes circular dependency problems.\nexport function parseCase(px, k, casedFromFun) {\n\ttype(px, Px, k, CaseKeywords, casedFromFun, Boolean)\n\tconst isVal = k === 'case'\n\n\tconst { before, lines } = PB.takeBlockLinesFromEnd(px)\n\n\tconst opCased = (() => {\n\t\tif (casedFromFun) {\n\t\t\tpx.checkEmpty(before,\n\t\t\t\t'Can\\'t give focus to case - it is the function\\'s implicit first argument.')\n\t\t\treturn None\n\t\t}\n\t\telse return opIf(!before.isEmpty(), () =>\n\t\t\tpx.w(before, () => Assign.focus(px.loc, ParseExpr.default(px))))\n\t})()\n\n\tconst l = lines.last()\n\tconst { partLines, opElse } = Keyword.isElse(l.tokens.head()) ? {\n\t\t\tpartLines: lines.rtail(),\n\t\t\topElse: some(px.w(l.tokens.tail(), isVal ? PB.justBlockVal : PB.justBlockDo))\n\t\t} : {\n\t\t\tpartLines: lines,\n\t\t\topElse: None\n\t\t}\n\n\tconst parts = partLines.map(line => {\n\t\tconst { before, block } =\n\t\t\tpx.w(line.tokens, isVal ? PB.takeBlockValFromEnd : PB.takeBlockDoFromEnd)\n\t\tconst test = px.w(before, ParseExpr.default)\n\t\treturn (isVal ? CaseValPart : CaseDoPart)(line.loc, test, block)\n\t})\n\n\treturn (isVal ? CaseVal : CaseDo)(px.loc, opCased, parts, opElse)\n}\n"],"sourceRoot":"/src"}