{"version":3,"sources":["meta/compile/private/parse/parseBlock.js"],"names":[],"mappings":"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","file":"meta/compile/private/parse/parseBlock.js","sourcesContent":["import { Assign, BlockDo, BlockVal, BlockWrap, Debug, ObjReturn, ListEntry, ListReturn,\n\tMapReturn, MapEntry, ModuleDefaultExport, Val } from '../../Expression'\nimport { Group } from '../Token'\nimport { cat, isEmpty, last, rtail } from '../U/Bag'\nimport { ifElse, None, some } from '../U/Op'\nimport { assert } from '../U/util'\nimport parseLine, { parseLineOrLines } from './parseLine'\nimport { check, cx, loc, tokens, w } from './vars'\n\nexport const\n\ttakeBlockLinesFromEnd = () => {\n\t\tcheck(!tokens.isEmpty(), 'Expected an indented block')\n\t\tconst l = tokens.last()\n\t\tcx.check(Group.isBlock(l), l.loc, 'Expected an indented block at the end')\n\t\treturn { before: tokens.rtail(), lines: l.tokens }\n\t},\n\n\tblockWrap = () => BlockWrap(loc, parseBody('val')),\n\n\tjustBlockDo = () => {\n\t\tconst { before, block } = takeBlockDoFromEnd()\n\t\tcheck(before.isEmpty(), 'Expected just a block.')\n\t\treturn block\n\t},\n\tjustBlockVal = () => {\n\t\tconst { before, block } = takeBlockValFromEnd()\n\t\tcheck(before.isEmpty(), 'Expected just a block.')\n\t\treturn block\n\t},\n\n\ttakeBlockDoFromEnd = () => {\n\t\tconst{ before, lines } = takeBlockLinesFromEnd()\n\t\tconst block = w(lines, parseBodyDo)\n\t\treturn { before, block }\n\t},\n\ttakeBlockValFromEnd = () => {\n\t\tconst { before, lines } = takeBlockLinesFromEnd()\n\t\tconst block = w(lines, parseBody, 'val')\n\t\treturn { before, block }\n\t},\n\n\t// TODO: Just have module return a value and use a normal block.\n\tparseModuleBody = () => parseBody('module'),\n\n\tparseBlockFromLines = () => parseBody('any'),\n\n\t// Gets lines in a region or Debug.\n\tparseLinesFromBlock = () => {\n\t\tconst h = tokens.head()\n\t\tcx.check(tokens.size() > 1, h.loc, () => `Expected indented block after ${h}`)\n\t\tconst block = tokens.second()\n\t\tassert(tokens.size() === 2 && Group.isBlock(block))\n\t\treturn block.tokens.flatMap(line => w(line.tokens, parseLineOrLines))\n\t}\n\nconst\n\tparseBodyDo = () => {\n\t\tconst { eLines, kReturn } = parseBlockLines()\n\t\tcheck(kReturn === 'plain', `Can not make ${kReturn} in statement context.`)\n\t\treturn BlockDo(loc, eLines)\n\t},\n\n\tparseBody = k => {\n\t\tassert(k === 'val' || k === 'module' || k === 'any')\n\n\t\t// keys only matter if kReturn === 'obj'\n\t\tconst { eLines, kReturn, listLength, mapLength, objKeys, debugKeys } = parseBlockLines()\n\n\t\tconst { doLines, opReturn } = (() => {\n\t\t\tif (kReturn === 'bag')\n\t\t\t\treturn {\n\t\t\t\t\tdoLines: eLines,\n\t\t\t\t\topReturn: some(ListReturn(loc, listLength))\n\t\t\t\t}\n\t\t\tif (kReturn === 'map')\n\t\t\t\treturn {\n\t\t\t\t\tdoLines: eLines,\n\t\t\t\t\topReturn: some(MapReturn(loc, mapLength))\n\t\t\t\t}\n\n\t\t\tconst lastReturn = !isEmpty(eLines) && last(eLines) instanceof Val\n\t\t\tif (kReturn === 'obj' && k !== 'module')\n\t\t\t\treturn lastReturn ?\n\t\t\t\t\t{\n\t\t\t\t\t\tdoLines: rtail(eLines),\n\t\t\t\t\t\topReturn: some(ObjReturn(\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tobjKeys,\n\t\t\t\t\t\t\tdebugKeys,\n\t\t\t\t\t\t\tsome(last(eLines)),\n\t\t\t\t\t\t\t// displayName is filled in by parseAssign.\n\t\t\t\t\t\t\tNone))\n\t\t\t\t\t} : {\n\t\t\t\t\t\tdoLines: eLines,\n\t\t\t\t\t\topReturn: some(ObjReturn(\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tobjKeys,\n\t\t\t\t\t\t\tdebugKeys,\n\t\t\t\t\t\t\tNone,\n\t\t\t\t\t\t\t// displayName is filled in by parseAssign.\n\t\t\t\t\t\t\tNone))\n\t\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn lastReturn ?\n\t\t\t\t{ doLines: rtail(eLines), opReturn: some(last(eLines)) } :\n\t\t\t\t{ doLines: eLines, opReturn: None }\n\t\t})()\n\n\t\tswitch (k) {\n\t\t\tcase 'val':\n\t\t\t\treturn ifElse(opReturn,\n\t\t\t\t\treturned => BlockVal(loc, doLines, returned),\n\t\t\t\t\t() => cx.fail('Expected a value block.'))\n\t\t\tcase 'any':\n\t\t\t\treturn ifElse(opReturn,\n\t\t\t\t\treturned => BlockVal(loc, doLines, returned),\n\t\t\t\t\t() => BlockDo(loc, doLines))\n\t\t\tcase 'module': {\n\t\t\t\t// TODO: Handle debug-only exports\n\t\t\t\tconst lines =\n\t\t\t\t\t// Turn Obj assigns into exports.\n\t\t\t\t\tcat(\n\t\t\t\t\t\tdoLines.map(line => {\n\t\t\t\t\t\t\tif (line instanceof Assign && line.k === '. ')\n\t\t\t\t\t\t\t\tline.k = 'export'\n\t\t\t\t\t\t\treturn line\n\t\t\t\t\t\t}),\n\t\t\t\t\t\topReturn.map(ret => ModuleDefaultExport(ret.loc, ret)))\n\t\t\t\treturn BlockDo(loc, lines)\n\t\t\t}\n\t\t\tdefault: throw new Error(k)\n\t\t}\n\t},\n\n\tparseBlockLines = () => {\n\t\tconst lines = tokens\n\t\tconst objKeys = [], debugKeys = []\n\t\tlet listLength = 0, mapLength = 0\n\t\tconst eLines = []\n\t\tconst addLine = (ln, inDebug) => {\n\t\t\tif (ln instanceof Array)\n\t\t\t\tln.forEach(_ => addLine(_, inDebug))\n\t\t\telse {\n\t\t\t\tif (ln instanceof Debug)\n\t\t\t\t\tln.lines.forEach(_ => addLine(_, true))\n\t\t\t\telse if (ln instanceof ListEntry) {\n\t\t\t\t\tassert(!inDebug, 'Not supported: debug list entries')\n\t\t\t\t\t// When ListEntries are first created they have no index.\n\t\t\t\t\tassert(ln.index === -1)\n\t\t\t\t\tln.index = listLength\n\t\t\t\t\tlistLength = listLength + 1\n\t\t\t\t}\n\t\t\t\telse if (ln instanceof MapEntry) {\n\t\t\t\t\tassert(!inDebug, 'Not supported: debug map entries')\n\t\t\t\t\tassert(ln.index === -1)\n\t\t\t\t\tln.index = mapLength\n\t\t\t\t\tmapLength = mapLength + 1\n\t\t\t\t}\n\t\t\t\telse if (ln instanceof Assign && ln.k === '. ')\n\t\t\t\t\t(inDebug ? debugKeys : objKeys).push(ln.assignee)\n\n\t\t\t\tif (!inDebug)\n\t\t\t\t\t// Else we are adding the Debug as a single line.\n\t\t\t\t\teLines.push(ln)\n\t\t\t}\n\t\t}\n\t\tlines.each(line => addLine(w(line.tokens, parseLine, listLength)))\n\n\t\tconst isObj = !(isEmpty(objKeys) && isEmpty(debugKeys))\n\t\t// TODO\n\t\t// if (isEmpty(objKeys))\n\t\t//\tcx.check(isEmpty(debugKeys), loc, 'Block can't have only debug keys')\n\t\tconst isBag = listLength > 0\n\t\tconst isMap = mapLength > 0\n\t\tcheck(!(isObj && isBag), 'Block has both Bag and Obj lines.')\n\t\tcheck(!(isObj && isMap), 'Block has both Obj and Map lines.')\n\t\tcheck(!(isBag && isMap), 'Block has both Bag and Map lines.')\n\n\t\tconst kReturn = isObj ? 'obj' : isBag ? 'bag' : isMap ? 'map' : 'plain'\n\t\treturn { eLines, kReturn, listLength, mapLength, objKeys, debugKeys }\n\t}\n"],"sourceRoot":"/src"}