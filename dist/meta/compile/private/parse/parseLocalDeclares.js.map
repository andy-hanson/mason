{"version":3,"sources":["meta/compile/private/parse/parseLocalDeclares.js"],"names":[],"mappings":";;;;;;SAWgB,iBAAiB,GAAjB,iBAAiB;;mBAFlB;SAAM,MAFI,MAAM,CAEH,GAAG,CAAC,UAAA,CAAC;UAAI,MAFD,EAAE,CAEE,CAAC,EAAE,iBAAiB,CAAC;GAAA,CAAC;EAAA;;AAEvD,UAAS,iBAAiB,GAAG;AACnC,MAAI,IAAI,CAAA;AACR,MAAI,MAAM,QATF,IAAI,AASK,CAAA;AACjB,MAAI,MAAM,GAAG,KAAK,CAAA;;AAElB,SAXQ,MAAM,CAWP,MATiB,MAAM,CAShB,IAAI,EAAE,KAAK,CAAC,CAAC,CAAA;AAC3B,QAAM,CAAC,GAAG,MAVc,MAAM,CAUb,IAAI,EAAE,CAAA;;AAEvB,MAAI,OAhBI,KAAK,CAgBH,QAAQ,CAAC,CAAC,CAAC,EAAE;AACtB,SAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAA;AACvB,OAAI,IAAI,GAAG,MAAM,CAAA;AACjB,OAAI,OAnBU,OAAO,CAmBT,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE;AACnC,UAAM,GAAG,IAAI,CAAA;AACb,QAAI,GAAG,MAAM,CAAC,IAAI,EAAE,CAAA;IACpB;AACD,OAAI,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA;AAClC,SAAM,KAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;AACzB,OAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE;AACrB,UAAM,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAA;AAC1B,UAvBa,EAAE,CAuBZ,KAAK,CAAC,OA3BI,OAAO,CA2BH,OAAO,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE;0BAAkB,cA9BxD,IAAI,CA8ByD,GAAG,CAAC;KAAE,CAAC,CAAA;AAC1E,UAxBM,KAAK,CAwBL,KAAK,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;0CAAkC,KAAK;KAAE,CAAC,CAAA;AAClE,UAAM,UAAU,GAAG,KAAK,CAAC,IAAI,EAAE,CAAA;AAC/B,UAAM,GAAG,KA7BG,IAAI,CA6BF,MA1BgB,CAAC,CA0Bf,UAAU,eA3BpB,WAAW,CA2BuB,CAAC,CAAA;IACzC;GACD,MAEA,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAA;;AAEzB,SAAO,YAtCC,YAAY,OAMD,GAAG,EAgCG,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;EACrD;;AAED,OAAM,cAAc,GAAG,UAAC,CAAC,EAAK;AAC7B,MAAI,OAxCW,OAAO,CAwCV,OAAO,CAAC,CAAC,CAAC,EACrB,OAAO,GAAG,CAAA,KACN;AACJ,SAvCc,EAAE,CAuCb,KAAK,CAAC,CAAC,mBA3Ca,IAAI,AA2CD,EAAE,CAAC,CAAC,GAAG,EAAE;2CAAoC,CAAC;IAAE,CAAC,CAAA;;AAE3E,SAzCc,EAAE,CAyCb,KAAK,CAAC,CAAC,MA9CH,SAAS,CA8CI,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE;sCAA+B,cAhDhE,IAAI,CAgDiE,CAAC,CAAC,IAAI,CAAC;IAAE,CAAC,CAAA;AACtF,UAAO,CAAC,CAAC,IAAI,CAAA;GACb;EACD,CAAA","file":"meta/compile/private/parse/parseLocalDeclares.js","sourcesContent":["import { code } from '../../CompileError'\nimport { LocalDeclare } from '../../Expression'\nimport { JsGlobals } from '../Lang'\nimport { Group, Keyword, Name } from '../Token'\nimport { None, some } from '../U/Op'\nimport { assert } from '../U/util'\nimport { parseSpaced } from './parseSpaced'\nimport { check, cx, loc, tokens, w, wt } from './vars'\n\nexport default () => tokens.map(t => wt(t, parseLocalDeclare))\n\nexport function parseLocalDeclare() {\n\tlet name\n\tlet opType = None\n\tlet isLazy = false\n\n\tassert(tokens.size() === 1)\n\tconst t = tokens.head()\n\n\tif (Group.isSpaced(t)) {\n\t\tconst tokens = t.tokens\n\t\tlet rest = tokens\n\t\tif (Keyword.isTilde(tokens.head())) {\n\t\t\tisLazy = true\n\t\t\trest = tokens.tail()\n\t\t}\n\t\tname = parseLocalName(rest.head())\n\t\tconst rest2 = rest.tail()\n\t\tif (!rest2.isEmpty()) {\n\t\t\tconst colon = rest2.head()\n\t\t\tcx.check(Keyword.isColon(colon), colon.loc, () => `Expected ${code(':')}`)\n\t\t\tcheck(rest2.size() > 1, () => `Expected something after ${colon}`)\n\t\t\tconst tokensType = rest2.tail()\n\t\t\topType = some(w(tokensType, parseSpaced))\n\t\t}\n\t}\n\telse\n\t\tname = parseLocalName(t)\n\n\treturn LocalDeclare(loc, name, opType, isLazy, false)\n}\n\nconst parseLocalName = (t) => {\n\tif (Keyword.isFocus(t))\n\t\treturn '_'\n\telse {\n\t\tcx.check(t instanceof Name, t.loc, () => `Expected a local name, not ${t}`)\n\t\t// TODO: Allow this?\n\t\tcx.check(!JsGlobals.has(t.name), t.loc, () => `Can not shadow global ${code(t.name)}`)\n\t\treturn t.name\n\t}\n}\n"],"sourceRoot":"/src"}