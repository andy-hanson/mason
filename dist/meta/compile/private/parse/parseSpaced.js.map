{"version":3,"sources":["meta/compile/private/parse/parseSpaced.js"],"names":[],"mappings":";;;;;;;;SAUgB,WAAW,GAAX,WAAW;;;;;;;;AAApB,UAAS,WAAW,CAAC,EAAE,EAAE;AAC/B,QAAK,EAAE,OAAK,CAAA;AACZ,QAAM,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,EAAE;QAAE,IAAI,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,EAAE,CAAA;AACnD,UAAQ,IAAI;AACX,QAAK,CAAC,mBAZiB,OAAO,AAYL;AACxB,QAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAChB,OAAE,CAAC,KAAK,CAAC,CAAC,OAdW,OAAO,CAcV,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE;sBAAa,CAAC;MAAW,CAAC,CAAA;AACzE,WAAM,KAAK,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,WAAW,CAAC,CAAA;AACrC,WAAM,KAAK,GAAG,YAjBG,WAAW,CAiBF,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;AACtC,YAAO,YAlBF,IAAI,CAkBG,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,CAAA;KACzC,MAAM,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EACrB,OAAO,YApBI,IAAI,CAoBH,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,CAAA;AAAA,AAC7C;AAAS;AACR,WAAM,iBAAiB,GAAG,UAAA,EAAE;aAAI,UAAC,CAAC,EAAE,CAAC,EAAK;AACzC,aAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAA;AACjB,WAAI,CAAC,mBAvBA,OAAO,AAuBY,EAAE;AACzB,UAAE,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE,GAAG,EAAE,gBAAgB,CAAC,CAAA;AAC9C,eAAO,YA1BsB,MAAM,CA0BrB,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;QAC7B,MAAM,IAAI,CAAC,mBA1BE,KAAK,AA0BU,EAAE;AAC9B,YAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EACd,OAAO,YA7BJ,IAAI,CA6BK,GAAG,CAAC,GAAG,EAClB,MA5BE,OAAO,CA4BD,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,WAAG,cAAc,CAAC,CAAC,CAAC,CAAA;AAChD,YAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAChB,WAAE,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,GAAG,EAC/B;0BAAa,cAlCX,IAAI,CAkCY,OAAO,CAAC,cAAS,cAlCjC,IAAI,CAkCkC,MAAM,CAAC;UAAE,CAAC,CAAA;AACnD,gBAAO,YAlCJ,IAAI,CAkCK,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CAAA;SACvB;QACD,MAAM,EAAE,CAAC,IAAI,CAAC,GAAG,mCAAiC,CAAC,CAAG,CAAA;OACvD;MAAA,CAAA;AACD,YAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,gBAAc,CAAC,CAAA;KAChE;AAAA,GACD;EACD","file":"meta/compile/private/parse/parseSpaced.js","sourcesContent":["import { code } from '../../CompileError'\nimport { Call, Lazy, LocalAccess, Member } from '../../Expression'\nimport { DotName, Group, Keyword } from '../Token'\nimport { unshift } from '../U/Bag'\nimport type from '../U/type'\nimport Px from './Px'\nimport parseSingle from './parseSingle'\n// TODO:ES6\nimport * as PE from './parseExpr'\n\nexport function parseSpaced(px) {\n\ttype(px, Px)\n\tconst h = px.tokens.head(), rest = px.tokens.tail()\n\tswitch (true) {\n\t\tcase h instanceof Keyword:\n\t\t\tif (h.k === ':') {\n\t\t\t\tpx.check(!Keyword.isColon(rest.head()), h.loc, () => `Two ${h} in a row`)\n\t\t\t\tconst eType = px.w(rest, parseSpaced)\n\t\t\t\tconst focus = LocalAccess.focus(h.loc)\n\t\t\t\treturn Call.contains(h.loc, eType, focus)\n\t\t\t} else if (h.k === '~')\n\t\t\t\treturn Lazy(h.loc, px.w(rest, parseSpaced))\n\t\tdefault: {\n\t\t\tconst memberOrSubscript = px => (e, t) => {\n\t\t\t\tconst loc = t.loc\n\t\t\t\tif (t instanceof DotName) {\n\t\t\t\t\tpx.check(t.nDots === 1, loc, 'Too many dots!')\n\t\t\t\t\treturn Member(loc, e, t.name)\n\t\t\t\t} else if (t instanceof Group) {\n\t\t\t\t\tif (t.k === '[')\n\t\t\t\t\t\treturn Call.sub(loc,\n\t\t\t\t\t\t\tunshift(e, px.w(t.tokens, PE.parseExprParts)))\n\t\t\t\t\tif (t.k === '(') {\n\t\t\t\t\t\tpx.check(t.tokens.isEmpty(), loc,\n\t\t\t\t\t\t\t() => `Use ${code('(a b)')}, not ${code('a(b)')}`)\n\t\t\t\t\t\treturn Call(loc, e, [])\n\t\t\t\t\t}\n\t\t\t\t} else px.fail(loc, `Expected member or sub, not ${t}`)\n\t\t\t}\n\t\t\treturn rest.reduce(memberOrSubscript(px), px.wt(h, parseSingle))\n\t\t}\n\t}\n}\n"],"sourceRoot":"/src"}