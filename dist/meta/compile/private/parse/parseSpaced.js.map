{"version":3,"sources":["meta/compile/private/parse/parseSpaced.js"],"names":[],"mappings":";;;;;;;;SAQgB,WAAW,GAAX,WAAW;;;;AAApB,UAAS,WAAW,GAAG;AAC7B,QAAM,CAAC,GAAG,MAHE,MAAM,CAGD,IAAI,EAAE;QAAE,IAAI,GAAG,MAHpB,MAAM,CAGqB,IAAI,EAAE,CAAA;AAC7C,UAAQ,IAAI;AACX,QAAK,CAAC,mBATiB,OAAO,AASL;AACxB,QAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAChB,WAPK,EAAE,CAOJ,KAAK,CAAC,CAAC,OAXW,OAAO,CAWV,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE;sBAAa,CAAC;MAAW,CAAC,CAAA;AACzE,WAAM,KAAK,GAAG,MARG,CAAC,CAQF,IAAI,EAAE,WAAW,CAAC,CAAA;AAClC,WAAM,KAAK,GAAG,YAdG,WAAW,CAcF,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;AACtC,YAAO,YAfF,IAAI,CAeG,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,CAAA;KACzC,MAAM,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EACrB,OAAO,YAjBI,IAAI,CAiBH,CAAC,CAAC,GAAG,EAAE,MAZF,CAAC,CAYG,IAAI,EAAE,WAAW,CAAC,CAAC,CAAA;AAAA,AAC1C;AAAS;AACR,WAAM,iBAAiB,GAAG,UAAC,CAAC,EAAE,CAAC,EAAK;AACnC,YAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAA;AACjB,UAAI,CAAC,mBApBA,OAAO,AAoBY,EAAE;AACzB,aAjBI,EAAE,CAiBH,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE,GAAG,EAAE,gBAAgB,CAAC,CAAA;AAC9C,cAAO,YAvBsB,MAAM,CAuBrB,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;OAC7B,MAAM,IAAI,CAAC,mBAvBE,KAAK,AAuBU,EAAE;AAC9B,WAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EACd,OAAO,YA1BJ,IAAI,CA0BK,GAAG,CAAC,GAAG,EAClB,MAzBE,OAAO,CAyBD,CAAC,EAAE,MAtBG,CAAC,CAsBF,CAAC,CAAC,MAAM,aAxBnB,cAAc,CAwBsB,CAAC,CAAC,CAAA;AAC1C,WAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAChB,cAxBG,EAAE,CAwBF,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,GAAG,EAC/B;yBAAa,cA/BX,IAAI,CA+BY,OAAO,CAAC,cAAS,cA/BjC,IAAI,CA+BkC,MAAM,CAAC;SAAE,CAAC,CAAA;AACnD,eAAO,YA/BJ,IAAI,CA+BK,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CAAA;QACvB;OACD,MAAM,MA5BF,EAAE,CA4BG,IAAI,CAAC,GAAG,mCAAiC,CAAC,CAAG,CAAA;MACvD,CAAA;AACD,YAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE,MA9BjB,EAAE,CA8BkB,CAAC,gBAAc,CAAC,CAAA;KACzD;AAAA,GACD;EACD","file":"meta/compile/private/parse/parseSpaced.js","sourcesContent":["import { code } from '../../CompileError'\nimport { Call, Lazy, LocalAccess, Member } from '../../Expression'\nimport { DotName, Group, Keyword } from '../Token'\nimport { unshift } from '../U/Bag'\nimport { parseExprParts } from './parseExpr'\nimport parseSingle from './parseSingle'\nimport { cx, tokens, w, wt } from './vars'\n\nexport function parseSpaced() {\n\tconst h = tokens.head(), rest = tokens.tail()\n\tswitch (true) {\n\t\tcase h instanceof Keyword:\n\t\t\tif (h.k === ':') {\n\t\t\t\tcx.check(!Keyword.isColon(rest.head()), h.loc, () => `Two ${h} in a row`)\n\t\t\t\tconst eType = w(rest, parseSpaced)\n\t\t\t\tconst focus = LocalAccess.focus(h.loc)\n\t\t\t\treturn Call.contains(h.loc, eType, focus)\n\t\t\t} else if (h.k === '~')\n\t\t\t\treturn Lazy(h.loc, w(rest, parseSpaced))\n\t\tdefault: {\n\t\t\tconst memberOrSubscript = (e, t) => {\n\t\t\t\tconst loc = t.loc\n\t\t\t\tif (t instanceof DotName) {\n\t\t\t\t\tcx.check(t.nDots === 1, loc, 'Too many dots!')\n\t\t\t\t\treturn Member(loc, e, t.name)\n\t\t\t\t} else if (t instanceof Group) {\n\t\t\t\t\tif (t.k === '[')\n\t\t\t\t\t\treturn Call.sub(loc,\n\t\t\t\t\t\t\tunshift(e, w(t.tokens, parseExprParts)))\n\t\t\t\t\tif (t.k === '(') {\n\t\t\t\t\t\tcx.check(t.tokens.isEmpty(), loc,\n\t\t\t\t\t\t\t() => `Use ${code('(a b)')}, not ${code('a(b)')}`)\n\t\t\t\t\t\treturn Call(loc, e, [])\n\t\t\t\t\t}\n\t\t\t\t} else cx.fail(loc, `Expected member or sub, not ${t}`)\n\t\t\t}\n\t\t\treturn rest.reduce(memberOrSubscript, wt(h, parseSingle))\n\t\t}\n\t}\n}\n"],"sourceRoot":"/src"}