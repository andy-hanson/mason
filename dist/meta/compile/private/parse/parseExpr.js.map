{"version":3,"sources":["meta/compile/private/parse/parseExpr.js"],"names":[],"mappings":"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","file":"meta/compile/private/parse/parseExpr.js","sourcesContent":["import { Call, GlobalAccess, ObjSimple, Yield, YieldTo } from '../../Expression'\nimport { Keyword } from '../Token'\nimport { assert } from '../U/util'\nimport { ifElse } from '../U/Op'\nimport { head, isEmpty, last, push, tail } from '../U/Bag'\nimport parseFun from './parseFun'\nimport { parseLocalDeclare } from './parseLocalDeclares'\nimport parseSingle from './parseSingle'\nimport { parseCase } from './parseCase'\nimport { cx, loc, tokens, w, wt } from './vars'\n\nexport const parseExpr = () => {\n\treturn ifElse(tokens.opSplitManyWhere(Keyword.isObjAssign),\n\t\tsplits => {\n\t\t\t// Short object form, such as (a. 1, b. 2)\n\t\t\tconst first = splits[0].before\n\t\t\tconst tokensCaller = first.rtail()\n\n\t\t\tconst keysVals = {}\n\t\t\tfor (let i = 0; i < splits.length - 1; i = i + 1) {\n\t\t\t\tconst local = wt(splits[i].before.last(), parseLocalDeclare)\n\t\t\t\t// Can't have got a type because there's only one token.\n\t\t\t\tassert(isEmpty(local.opType))\n\t\t\t\tconst tokensValue = i === splits.length - 2 ?\n\t\t\t\t\tsplits[i + 1].before :\n\t\t\t\t\tsplits[i + 1].before.rtail()\n\t\t\t\tconst value = w(tokensValue, parseExprPlain)\n\t\t\t\tcx.check(!Object.prototype.hasOwnProperty.call(keysVals, local.name),\n\t\t\t\t\tlocal.loc, () => `Duplicate property ${local}.`)\n\t\t\t\tObject.defineProperty(keysVals, local.name, { value })\n\t\t\t}\n\t\t\tassert(last(splits).at === undefined)\n\t\t\tconst val = ObjSimple(loc, keysVals)\n\t\t\tif (tokensCaller.isEmpty())\n\t\t\t\treturn val\n\t\t\telse {\n\t\t\t\tconst parts = w(tokensCaller, parseExprParts)\n\t\t\t\tassert(!isEmpty(parts))\n\t\t\t\treturn Call(loc, head(parts), push(tail(parts), val))\n\t\t\t}\n\t\t},\n\t\t() => parseExprPlain()\n\t)\n}\n\nexport const parseExprParts = () => {\n\tconst out = []\n\tconst end = tokens.end\n\tfor (let i = tokens.start; i < end; i = i + 1) {\n\t\tconst here = tokens.data[i]\n\t\tif (here instanceof Keyword) {\n\t\t\tconst rest = () => tokens._new(i + 1, end)\n\t\t\tswitch (here.k) {\n\t\t\t\tcase '|': case '~|':\n\t\t\t\t\treturn push(out, w(rest(), parseFun, here.k))\n\t\t\t\tcase 'case':\n\t\t\t\t\treturn push(out, w(rest(), parseCase, 'case', false))\n\t\t\t\tcase '<~':\n\t\t\t\t\treturn push(out, Yield(loc, w(rest(), parseExpr)))\n\t\t\t\tcase '<~~':\n\t\t\t\t\treturn push(out, YieldTo(loc, w(rest(), parseExpr)))\n\t\t\t\tdefault:\n\t\t\t\t\t// fallthrough\n\t\t\t}\n\t\t}\n\t\tout.push(wt(here, parseSingle))\n\t}\n\treturn out\n}\n\nexport const parseExprPlain = () => {\n\tconst parts = parseExprParts()\n\tswitch (parts.length) {\n\t\tcase 0:\n\t\t\treturn GlobalAccess.null(loc)\n\t\tcase 1:\n\t\t\treturn head(parts)\n\t\tdefault:\n\t\t\treturn Call(loc, head(parts), tail(parts))\n\t}\n}\n"],"sourceRoot":"/src"}