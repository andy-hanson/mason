{"version":3,"sources":["meta/compile/private/parse/parseLine.js"],"names":[],"mappings":"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","file":"meta/compile/private/parse/parseLine.js","sourcesContent":["import E, { Assign, AssignDestructure, BlockWrap, Call, Debug, GlobalAccess, ObjReturn,\n\tFun, EndLoop, ListEntry, Loop, MapEntry, Special, Yield, YieldTo } from '../../Expression'\nimport { Group, Keyword } from '../Token'\nimport { head, isEmpty, last } from '../U/Bag'\nimport { ifElse, some } from '../U/Op'\nimport type from '../U/type'\nimport { parseCase } from './parseCase'\nimport { parseExpr } from './parseExpr'\nimport parseLocalDeclares from './parseLocalDeclares'\nimport { parseLinesFromBlock, justBlockDo } from './parseBlock'\nimport { check, checkEmpty, cx, loc, tokens, w } from './vars'\n\n// Returns line or sq of lines\nexport default function parseLine() {\n\tconst h = tokens.head()\n\tconst rest = tokens.tail()\n\n\t// We only deal with mutable expressions here, otherwise we fall back to parseExpr.\n\tif (h instanceof Keyword)\n\t\tswitch (h.k) {\n\t\t\tcase '. ':\n\t\t\t\t// Index is set by parseBlock.\n\t\t\t\treturn ListEntry(loc, w(rest, parseExpr), -1)\n\t\t\tcase 'case!':\n\t\t\t\treturn w(rest, parseCase, 'case!', false)\n\t\t\tcase 'debug':\n\t\t\t\treturn Group.isBlock(tokens.second()) ?\n\t\t\t\t\t// `debug`, then indented block\n\t\t\t\t\tDebug(loc, parseLinesFromBlock()) :\n\t\t\t\t\t// `debug`, then single line\n\t\t\t\t\tDebug(loc, w(rest, parseLineOrLines))\n\t\t\tcase 'debugger':\n\t\t\t\tcheckEmpty(rest, () => `Did not expect anything after ${h}`)\n\t\t\t\treturn Special.debugger(loc)\n\t\t\tcase 'end-loop!':\n\t\t\t\tcheckEmpty(rest, () => `Did not expect anything after ${h}`)\n\t\t\t\treturn EndLoop(loc)\n\t\t\tcase 'loop!':\n\t\t\t\treturn Loop(loc, w(rest, justBlockDo))\n\t\t\tcase 'region':\n\t\t\t\treturn parseLinesFromBlock()\n\t\t\tdefault:\n\t\t\t\t// fall through\n\t\t}\n\n\treturn ifElse(tokens.opSplitOnceWhere(Keyword.isLineSplit),\n\t\t({ before, at, after }) => {\n\t\t\treturn at.k === '->' ?\n\t\t\t\tparseMapEntry(before, after) :\n\t\t\t\tparseAssign(before, at, after)\n\t\t},\n\t\t() => parseExpr())\n}\n\nexport const parseLineOrLines = () => {\n\tconst _ = parseLine()\n\treturn _ instanceof Array ? _ : [ _ ]\n}\n\nconst\n\tparseAssign = (assigned, assigner, value) => {\n\t\tlet locals = w(assigned, parseLocalDeclares)\n\t\tconst k = assigner.k\n\t\tconst eValuePre = value.isEmpty() ? GlobalAccess.true(loc) : w(value, parseExpr)\n\n\t\tlet eValueNamed\n\t\tif (locals.length === 1) {\n\t\t\tconst name = head(locals).name\n\t\t\tif (name === 'doc') {\n\t\t\t\tif (eValuePre instanceof Fun)\n\t\t\t\t\t// KLUDGE: `doc` for module can be a Fun signature.\n\t\t\t\t\t// TODO: Something better...\n\t\t\t\t\teValuePre.args.forEach(arg => { arg.okToNotUse = true })\n\t\t\t\teValueNamed = eValuePre\n\t\t\t}\n\t\t\telse\n\t\t\t\teValueNamed = tryAddDisplayName(eValuePre, name)\n\t\t}\n\t\telse\n\t\t\teValueNamed = eValuePre\n\n\t\tconst isYield = k === '<~' || k === '<~~'\n\n\t\tconst eValue = valueFromAssign(eValueNamed, k)\n\n\t\tif (isEmpty(locals)) {\n\t\t\tcheck(isYield, 'Assignment to nothing')\n\t\t\treturn eValue\n\t\t}\n\n\t\tif (isYield)\n\t\t\tlocals.forEach(_ => cx.check(_.k !== 'lazy', _.loc, 'Can not yield to lazy variable.'))\n\n\t\tif (k === '. ')\n\t\t\tlocals.forEach(l => { l.okToNotUse = true })\n\n\t\tif (locals.length === 1) {\n\t\t\tconst assign = Assign(loc, locals[0], k, eValue)\n\t\t\tconst isTest = assign.assignee.name.endsWith('test')\n\t\t\treturn isTest && k === '. ' ? Debug(loc, [ assign ]) : assign\n\t\t}\n\t\telse {\n\t\t\tconst isLazy = locals.some(l => l.isLazy)\n\t\t\tif (isLazy)\n\t\t\t\tlocals.forEach(_ => cx.check(_.isLazy, _.loc,\n\t\t\t\t\t'If any part of destructuring assign is lazy, all must be.'))\n\t\t\treturn AssignDestructure(loc, locals, k, eValue, isLazy)\n\t\t}\n\t},\n\n\tvalueFromAssign = (valuePre, kAssign) => {\n\t\tswitch (kAssign) {\n\t\t\tcase '<~':\n\t\t\t\treturn Yield(valuePre.loc, valuePre)\n\t\t\tcase '<~~':\n\t\t\t\treturn YieldTo(valuePre.loc, valuePre)\n\t\t\tdefault:\n\t\t\t\treturn valuePre\n\t\t}\n\t},\n\n\t// We give it a displayName if:\n\t// . It's a block\n\t// . It's a function\n\t// . It's one of those at the end of a block\n\t// . It's one of those as the end member of a call.\n\ttryAddDisplayName = (eValuePre, displayName) => {\n\t\ttype(eValuePre, E, displayName, String)\n\t\tswitch (true) {\n\t\t\tcase eValuePre instanceof Call && eValuePre.args.length > 0:\n\t\t\t\t// TODO: Immutable\n\t\t\t\teValuePre.args[eValuePre.args.length - 1] =\n\t\t\t\t\ttryAddDisplayName(last(eValuePre.args), displayName)\n\t\t\t\treturn eValuePre\n\n\t\t\tcase eValuePre instanceof Fun:\n\t\t\t\treturn ObjReturn(eValuePre.loc, [], [], some(eValuePre), some(displayName))\n\n\t\t\tcase eValuePre instanceof ObjReturn &&\n\t\t\t\t!eValuePre.keys.some(key => key.name === 'displayName'):\n\t\t\t\teValuePre.opDisplayName = some(displayName)\n\t\t\t\treturn eValuePre\n\n\t\t\tcase eValuePre instanceof BlockWrap: {\n\t\t\t\tconst block = eValuePre.block\n\t\t\t\tblock.returned = tryAddDisplayName(block.returned, displayName)\n\t\t\t\treturn eValuePre\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\treturn eValuePre\n\t\t}\n\t},\n\n\tparseMapEntry = (before, after) =>\n\t\t// TODO: index Filled in by ???\n\t\tMapEntry(loc, w(before, parseExpr), w(after, parseExpr), -1)\n"],"sourceRoot":"/src"}