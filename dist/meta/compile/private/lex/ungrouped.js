if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../Lang', '../Token', '../U/util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _Lang, _Token, _UUtil, _GroupPre, _char) {
	'use strict';

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	const cc = function (ch) {
		return ch.charCodeAt(0);
	};
	const N0 = cc('0'),
	      N1 = cc('1'),
	      N2 = cc('2'),
	      N3 = cc('3'),
	      N4 = cc('4'),
	      N5 = cc('5'),
	      N6 = cc('6'),
	      N7 = cc('7'),
	      N8 = cc('8'),
	      N9 = cc('9'),
	      OpParen = cc('('),
	      OpBracket = cc('['),
	      OpBrace = cc('{'),
	      ClParen = cc(')'),
	      ClBracket = cc(']'),
	      ClBrace = cc('}'),
	      Ampersand = cc('&'),
	      Backslash = cc('\\'),
	      Backtick = cc('`'),
	      Bar = cc('|'),
	      Caret = cc('^'),
	      Colon = cc(':'),
	      Comma = cc(','),
	      Dot = cc('.'),
	      Hash = cc('#'),
	      Hyphen = cc('-'),
	      LetterN = cc('n'),
	      LetterT = cc('t'),
	      Newline = cc('\n'),
	      Percent = cc('%'),
	      Quote = cc('"'),
	      Semicolon = cc(';'),
	      Space = cc(' '),
	      Tab = cc('\t'),
	      Tilde = cc('~'),
	      Underscore = cc('_');

	module.exports = function (cx, str) {
		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		// Use these for debugging pos.
		/*
  const
  	checkPos = () => {
  		const p = getCorrectPos()
  		if (p.line !== line || p.column !== column)
  			throw new Error(`index: ${index}, wrong: ${Pos(line, column)}, right: ${p}`)
  	},
  	indexToPos = new Map(),
  	getCorrectPos = () => {
  		if (index === 0)
  			return Pos(StartLine, StartColumn)
  			let oldPos, oldIndex
  		for (oldIndex = index - 1; oldIndex > 0; oldIndex = oldIndex - 1) {
  			oldPos = indexToPos.get(oldIndex)
  			if (oldPos)
  				break
  		}
  		if (oldPos === undefined) {
  			assert(oldIndex === 0)
  			oldPos = Pos(StartLine, StartColumn)
  		}
  		let newLine = oldPos.line, newColumn = oldPos.column
  		for (; oldIndex < index; oldIndex = oldIndex + 1)
  			if (str.charCodeAt(oldIndex) === Newline) {
  				newLine = newLine + 1
  				newColumn = StartColumn
  			} else
  				newColumn = newColumn + 1
  			const p = Pos(newLine, newColumn)
  		indexToPos.set(index, p)
  		return p
  	}
  */

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return (0, _esastDistLoc.Pos)(line, column);
		},
		      loc = function () {
			return (0, _esastDistLoc.singleCharLoc)(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			return _skipWhile(function (_) {
				return _ !== Newline;
			});
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startColumn;
			const loc = function () {
				return (0, _Loc)((0, _esastDistLoc.Pos)(line, startColumn), pos());
			},
			      keyword = function (k) {
				return (0, _Token.Keyword)(loc(), k);
			},
			      gp = function (k) {
				return o((0, _GroupPre2)(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + (0, _CompileError.code)(lit);
				});
				return (0, _Token.TokenNumberLiteral)(loc(), num);
			};

			while (index !== str.length) {
				startColumn = column;
				ch = eat();
				switch (ch) {
					case N0:case N1:case N2:case N3:case N4:
					case N5:case N6:case N7:case N8:case N9:
						o(eatNumber());
						break;
					case OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + (0, _char.showChar)(ch);
						});
						return;
					case Space:
						cx.warnIf(peek() === Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case Dot:
						{
							const p = peek();
							if (p === Space || p === Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword(_Token.KW_ObjAssign));
								gp(_GroupPre.GP_Space);
							} else o((0, _Token.DotName)(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case Colon:
						o(keyword(_Token.KW_Type));
						break;
					case Tilde:
						if (tryEat(Bar)) {
							o(keyword(_Token.KW_GenFun));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword(_Token.KW_Lazy));
							break;
						}
						break;
					case Bar:
						o(keyword(_Token.KW_Fun));
						// First arg in its own spaced group
						gp(_GroupPre.GP_Space);
						break;
					case Underscore:
						o(keyword(_Token.KW_Focus));
						break;
					case Hash:
						if (!(tryEat(Space) || tryEat(Tab))) cx.fail(loc, function () {
							return '' + (0, _CompileError.code)('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(Tab);
							cx.check(peek() !== Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case Quote:
						lexQuote(indent);
						break;
					case Ampersand:case Backslash:case Backtick:case Caret:
					case Comma:case Percent:case Semicolon:
						cx.fail(loc, 'Reserved character ' + (0, _char.showChar)(ch));
					case Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
					case Hyphen:
						if ((0, _char.isDigit)(peek())) {
							o(eatNumber());
							break;
						}
					// else fallthrough
					default:
						{
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);
							const k = (0, _Token.keywordKFromName)(name);
							if (k !== undefined) {
								if (k === _Token.KW_Region) skipRestOfLine();
								o(keyword(k));
							} else if (tryEat(Underscore)) o((0, _Token.CallOnFocus)(loc(), name));else {
								cx.check(!(0, _Lang.isReservedName)(name), pos, function () {
									return 'Reserved name ' + (0, _CompileError.code)(name);
								});
								o((0, _Token.Name)(loc(), name));
							}
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o((0, _GroupPre2)(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o((0, _GroupPre2)((0, _esastDistLoc.singleCharLoc)(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case Newline:
						{
							cx.check(prev !== Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							// Allow extra blank lines.
							const numNewlines = skipNewlines() + 1;
							const newIndent = skipWhileEquals(Tab);
							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, numNewlines + newIndent);
								(0, _UUtil.assert)(peek() === Newline);
								break eatChars;
							} else read = read + '\n'.repeat(numNewlines) + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case OpBrace:
					return '{';
				case LetterN:
					return '\n';
				case LetterT:
					return '\t';
				case Quote:
					return '"';
				case Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + (0, _char.showChar)(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBV0EsT0FBTSxFQUFFLEdBQUcsVUFBQSxFQUFFO1NBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFBQSxDQUFBO0FBQ2pDLE9BQ0MsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNwRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ3BFLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUN6RCxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDekQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbkIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7T0FDcEIsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbEIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDYixLQUFLLEdBQUcs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Q0FBQTtBQUFBLEFBQ3hCLFNBQUssT0FBTztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDekIsU0FBSyxPQUFPO0FBQUUsWUFBTyxJQUFJLENBQUE7QUFBQSxBQUN6QixTQUFLLEtBQUs7QUFBRSxZQUFPLEdBQUcsQ0FBQTtBQUFBLEFBQ3RCLFNBQUssU0FBUztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDM0I7QUFBUyxPQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcseUJBQXVCLFVBdldyQyxRQUFRLEVBdVdzQyxFQUFFLENBQUMsQ0FBRyxDQUFBO0FBQUEsSUFDMUQ7R0FDRCxDQUFBOztBQUVELFdBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNoQixTQUFPLEdBQUcsQ0FBQTtFQUNWIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9jLCB7IFBvcywgU3RhcnRMaW5lLCBTdGFydENvbHVtbiwgc2luZ2xlQ2hhckxvYyB9IGZyb20gJ2VzYXN0L2Rpc3QvTG9jJ1xuaW1wb3J0IHsgY29kZSB9IGZyb20gJy4uLy4uL0NvbXBpbGVFcnJvcidcbmltcG9ydCB7IGlzUmVzZXJ2ZWROYW1lIH0gZnJvbSAnLi4vTGFuZydcbmltcG9ydCB7IENhbGxPbkZvY3VzLCBEb3ROYW1lLCBLZXl3b3JkLCBUb2tlbk51bWJlckxpdGVyYWwsIE5hbWUsXG5cdGtleXdvcmRLRnJvbU5hbWUsXG5cdEtXX0ZvY3VzLCBLV19GdW4sIEtXX0dlbkZ1biwgS1dfTGF6eSwgS1dfT2JqQXNzaWduLCBLV19SZWdpb24sIEtXX1R5cGUgfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCBHcm91cFByZSwgeyBHUF9PcGVuUGFyZW4sIEdQX09wZW5CcmFja2V0LCBHUF9PcGVuQmxvY2ssIEdQX09wZW5RdW90ZSwgR1BfTGluZSxcblx0R1BfU3BhY2UsIEdQX0Nsb3NlUGFyZW4sIEdQX0Nsb3NlQnJhY2tldCwgR1BfQ2xvc2VCbG9jaywgR1BfQ2xvc2VRdW90ZX0gZnJvbSAnLi9Hcm91cFByZSdcbmltcG9ydCB7IHNob3dDaGFyLCBpc0RpZ2l0LCBpc05hbWVDaGFyYWN0ZXIsIGlzTnVtYmVyQ2hhcmFjdGVyIH0gZnJvbSAnLi9jaGFyJ1xuXG5jb25zdCBjYyA9IGNoID0+IGNoLmNoYXJDb2RlQXQoMClcbmNvbnN0XG5cdE4wID0gY2MoJzAnKSwgTjEgPSBjYygnMScpLCBOMiA9IGNjKCcyJyksIE4zID0gY2MoJzMnKSwgTjQgPSBjYygnNCcpLFxuXHRONSA9IGNjKCc1JyksIE42ID0gY2MoJzYnKSwgTjcgPSBjYygnNycpLCBOOCA9IGNjKCc4JyksIE45ID0gY2MoJzknKSxcblx0T3BQYXJlbiA9IGNjKCcoJyksIE9wQnJhY2tldCA9IGNjKCdbJyksIE9wQnJhY2UgPSBjYygneycpLFxuXHRDbFBhcmVuID0gY2MoJyknKSwgQ2xCcmFja2V0ID0gY2MoJ10nKSwgQ2xCcmFjZSA9IGNjKCd9JyksXG5cdEFtcGVyc2FuZCA9IGNjKCcmJyksXG5cdEJhY2tzbGFzaCA9IGNjKCdcXFxcJyksXG5cdEJhY2t0aWNrID0gY2MoJ2AnKSxcblx0QmFyID0gY2MoJ3wnKSxcblx0Q2FyZXQgPSBjYygnXicpLFxuXHRDb2xvbiA9IGNjKCc6JyksXG5cdENvbW1hID0gY2MoJywnKSxcblx0RG90ID0gY2MoJy4nKSxcblx0SGFzaCA9IGNjKCcjJyksXG5cdEh5cGhlbiA9IGNjKCctJyksXG5cdExldHRlck4gPSBjYygnbicpLFxuXHRMZXR0ZXJUID0gY2MoJ3QnKSxcblx0TmV3bGluZSA9IGNjKCdcXG4nKSxcblx0UGVyY2VudCA9IGNjKCclJyksXG5cdFF1b3RlID0gY2MoJ1wiJyksXG5cdFNlbWljb2xvbiA9IGNjKCc7JyksXG5cdFNwYWNlID0gY2MoJyAnKSxcblx0VGFiID0gY2MoJ1xcdCcpLFxuXHRUaWxkZSA9IGNjKCd+JyksXG5cdFVuZGVyc2NvcmUgPSBjYygnXycpXG5cbmV4cG9ydCBkZWZhdWx0IChjeCwgc3RyKSA9PiB7XG5cdGNvbnN0IHJlcyA9IFsgXVxuXHRsZXQgbGluZSA9IFN0YXJ0TGluZVxuXHRsZXQgY29sdW1uID0gU3RhcnRDb2x1bW5cblx0bGV0IGluZGV4ID0gMFxuXG5cdC8vIFVzZSB0aGVzZSBmb3IgZGVidWdnaW5nIHBvcy5cblx0Lypcblx0Y29uc3Rcblx0XHRjaGVja1BvcyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHAgPSBnZXRDb3JyZWN0UG9zKClcblx0XHRcdGlmIChwLmxpbmUgIT09IGxpbmUgfHwgcC5jb2x1bW4gIT09IGNvbHVtbilcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBpbmRleDogJHtpbmRleH0sIHdyb25nOiAke1BvcyhsaW5lLCBjb2x1bW4pfSwgcmlnaHQ6ICR7cH1gKVxuXHRcdH0sXG5cdFx0aW5kZXhUb1BvcyA9IG5ldyBNYXAoKSxcblx0XHRnZXRDb3JyZWN0UG9zID0gKCkgPT4ge1xuXHRcdFx0aWYgKGluZGV4ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gUG9zKFN0YXJ0TGluZSwgU3RhcnRDb2x1bW4pXG5cblx0XHRcdGxldCBvbGRQb3MsIG9sZEluZGV4XG5cdFx0XHRmb3IgKG9sZEluZGV4ID0gaW5kZXggLSAxOyBvbGRJbmRleCA+IDA7IG9sZEluZGV4ID0gb2xkSW5kZXggLSAxKSB7XG5cdFx0XHRcdG9sZFBvcyA9IGluZGV4VG9Qb3MuZ2V0KG9sZEluZGV4KVxuXHRcdFx0XHRpZiAob2xkUG9zKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkUG9zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YXNzZXJ0KG9sZEluZGV4ID09PSAwKVxuXHRcdFx0XHRvbGRQb3MgPSBQb3MoU3RhcnRMaW5lLCBTdGFydENvbHVtbilcblx0XHRcdH1cblx0XHRcdGxldCBuZXdMaW5lID0gb2xkUG9zLmxpbmUsIG5ld0NvbHVtbiA9IG9sZFBvcy5jb2x1bW5cblx0XHRcdGZvciAoOyBvbGRJbmRleCA8IGluZGV4OyBvbGRJbmRleCA9IG9sZEluZGV4ICsgMSlcblx0XHRcdFx0aWYgKHN0ci5jaGFyQ29kZUF0KG9sZEluZGV4KSA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRcdG5ld0xpbmUgPSBuZXdMaW5lICsgMVxuXHRcdFx0XHRcdG5ld0NvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdG5ld0NvbHVtbiA9IG5ld0NvbHVtbiArIDFcblxuXHRcdFx0Y29uc3QgcCA9IFBvcyhuZXdMaW5lLCBuZXdDb2x1bW4pXG5cdFx0XHRpbmRleFRvUG9zLnNldChpbmRleCwgcClcblx0XHRcdHJldHVybiBwXG5cdFx0fVxuXHQqL1xuXG5cdGNvbnN0XG5cdFx0byA9IHQgPT4geyByZXMucHVzaCh0KSB9LFxuXG5cdFx0cG9zID0gKCkgPT4gUG9zKGxpbmUsIGNvbHVtbiksXG5cdFx0bG9jID0gKCkgPT4gc2luZ2xlQ2hhckxvYyhwb3MoKSksXG5cblx0XHRwcmV2ID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXggLSAxKSxcblx0XHRwZWVrID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXgpLFxuXG5cdFx0ZWF0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2ggPSBzdHIuY2hhckNvZGVBdChpbmRleClcblx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyAxXG5cdFx0XHRyZXR1cm4gY2hcblx0XHR9LFxuXHRcdHRyeUVhdCA9IGNoID0+IHtcblx0XHRcdGNvbnN0IGNhbkVhdCA9IHBlZWsoKSA9PT0gY2hcblx0XHRcdGlmIChjYW5FYXQpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0Y29sdW1uID0gY29sdW1uICsgMVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbkVhdFxuXHRcdH0sXG5cdFx0dHJ5RWF0TmV3bGluZSA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGNhbkVhdCA9IHBlZWsoKSA9PT0gTmV3bGluZVxuXHRcdFx0aWYgKGNhbkVhdCkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdFx0Y29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdH1cblx0XHRcdHJldHVybiBjYW5FYXRcblx0XHR9LFxuXG5cdFx0Ly8gQ2FsbGVyIG11c3QgZW5zdXJlIHRoYXQgYmFja2luZyB1cCBuQ2hhcnNUb0JhY2tVcCBjaGFyYWN0ZXJzIGJyaW5ncyB1cyB0byBvbGRQb3MuXG5cdFx0c3RlcEJhY2tNYW55ID0gKG9sZFBvcywgbkNoYXJzVG9CYWNrVXApID0+IHtcblx0XHRcdGluZGV4ID0gaW5kZXggLSBuQ2hhcnNUb0JhY2tVcFxuXHRcdFx0bGluZSA9IG9sZFBvcy5saW5lXG5cdFx0XHRjb2x1bW4gPSBvbGRQb3MuY29sdW1uXG5cdFx0fSxcblxuXHRcdF9za2lwV2hpbGUgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0d2hpbGUgKHByZWQocGVlaygpKSlcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdGNvbnN0IGRpZmYgPSBpbmRleCAtIHN0YXJ0SW5kZXhcblx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIGRpZmZcblx0XHRcdHJldHVybiBkaWZmXG5cdFx0fSxcblx0XHR0YWtlV2hpbGVXaXRoUHJldiA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHRfc2tpcFdoaWxlKHByZWQpXG5cdFx0XHRyZXR1cm4gc3RyLnNsaWNlKHN0YXJ0SW5kZXggLSAxLCBpbmRleClcblx0XHR9LFxuXHRcdHRha2VXaGlsZSA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHRfc2tpcFdoaWxlKHByZWQpXG5cdFx0XHRyZXR1cm4gc3RyLnNsaWNlKHN0YXJ0SW5kZXgsIGluZGV4KVxuXHRcdH0sXG5cdFx0c2tpcFdoaWxlRXF1YWxzID0gY2ggPT4gX3NraXBXaGlsZShfID0+IF8gPT09IGNoKSxcblxuXHRcdC8vIENhbGxlZCBhZnRlciBzZWVpbmcgdGhlIGZpcnN0IG5ld2xpbmUuXG5cdFx0c2tpcE5ld2xpbmVzID0gKCkgPT4ge1xuXHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHRjb25zdCBzdGFydExpbmUgPSBsaW5lXG5cdFx0XHR3aGlsZSAocGVlaygpID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0fVxuXHRcdFx0Y29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdHJldHVybiBsaW5lIC0gc3RhcnRMaW5lXG5cdFx0fSxcblxuXHRcdHNraXBSZXN0T2ZMaW5lID0gKCkgPT5cblx0XHRcdF9za2lwV2hpbGUoXyA9PiBfICE9PSBOZXdsaW5lKVxuXG5cdGNvbnN0IHVuZ3JvdXBlZCA9IGlzSW5RdW90ZSA9PiB7XG5cdFx0bGV0IGluZGVudCA9IDBcblxuXHRcdGxldCBjaCwgc3RhcnRDb2x1bW5cblx0XHRjb25zdFxuXHRcdFx0bG9jID0gKCkgPT4gTG9jKFBvcyhsaW5lLCBzdGFydENvbHVtbiksIHBvcygpKSxcblx0XHRcdGtleXdvcmQgPSBrID0+IEtleXdvcmQobG9jKCksIGspLFxuXHRcdFx0Z3AgPSBrID0+IG8oR3JvdXBQcmUobG9jKCksIGspKSxcblx0XHRcdGVhdE51bWJlciA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgbGl0ID0gdGFrZVdoaWxlV2l0aFByZXYoaXNOdW1iZXJDaGFyYWN0ZXIpXG5cdFx0XHRcdGNvbnN0IG51bSA9IE51bWJlcihsaXQpXG5cdFx0XHRcdGN4LmNoZWNrKCFOdW1iZXIuaXNOYU4obnVtKSwgcG9zLCAoKSA9PlxuXHRcdFx0XHRcdGBJbnZhbGlkIG51bWJlciBsaXRlcmFsICR7Y29kZShsaXQpfWApXG5cdFx0XHRcdHJldHVybiBUb2tlbk51bWJlckxpdGVyYWwobG9jKCksIG51bSlcblx0XHRcdH1cblxuXHRcdHdoaWxlIChpbmRleCAhPT0gc3RyLmxlbmd0aCkge1xuXHRcdFx0c3RhcnRDb2x1bW4gPSBjb2x1bW5cblx0XHRcdGNoID0gZWF0KClcblx0XHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdFx0Y2FzZSBOMDogY2FzZSBOMTogY2FzZSBOMjogY2FzZSBOMzogY2FzZSBONDpcblx0XHRcdFx0Y2FzZSBONTogY2FzZSBONjogY2FzZSBONzogY2FzZSBOODogY2FzZSBOOTpcblx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgT3BQYXJlbjpcblx0XHRcdFx0XHRncChHUF9PcGVuUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBPcEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfT3BlbkJyYWNrZXQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbFBhcmVuOlxuXHRcdFx0XHRcdGdwKEdQX0Nsb3NlUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfQ2xvc2VCcmFja2V0KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xCcmFjZTpcblx0XHRcdFx0XHRjeC5jaGVjayhpc0luUXVvdGUsIGxvYywgKCkgPT4gYFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRjYXNlIFNwYWNlOlxuXHRcdFx0XHRcdGN4Lndhcm5JZihwZWVrKCkgPT09IFNwYWNlLCBsb2MsICdNdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cnKVxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgRG90OiB7XG5cdFx0XHRcdFx0Y29uc3QgcCA9IHBlZWsoKVxuXHRcdFx0XHRcdGlmIChwID09PSBTcGFjZSB8fCBwID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdFx0XHQvLyBPYmpMaXQgYXNzaWduIGluIGl0cyBvd24gc3BhY2VkIGdyb3VwLlxuXHRcdFx0XHRcdFx0Ly8gV2UgY2FuJ3QganVzdCBjcmVhdGUgYSBuZXcgR3JvdXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG9cblx0XHRcdFx0XHRcdC8vIGVuc3VyZSBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBwcmVjZWRpbmcgb3IgZm9sbG93aW5nIHNwYWNlZCBncm91cC5cblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX09iakFzc2lnbikpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdG8oRG90TmFtZShcblx0XHRcdFx0XHRcdFx0bG9jKCksXG5cdFx0XHRcdFx0XHRcdC8vICsxIGZvciB0aGUgZG90IHdlIGp1c3Qgc2tpcHBlZC5cblx0XHRcdFx0XHRcdFx0c2tpcFdoaWxlRXF1YWxzKERvdCkgKyAxLFxuXHRcdFx0XHRcdFx0XHR0YWtlV2hpbGUoaXNOYW1lQ2hhcmFjdGVyKSkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIENvbG9uOlxuXHRcdFx0XHRcdG8oa2V5d29yZChLV19UeXBlKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFRpbGRlOlxuXHRcdFx0XHRcdGlmICh0cnlFYXQoQmFyKSkge1xuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX0dlbkZ1bikpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19MYXp5KSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQmFyOlxuXHRcdFx0XHRcdG8oa2V5d29yZChLV19GdW4pKVxuXHRcdFx0XHRcdC8vIEZpcnN0IGFyZyBpbiBpdHMgb3duIHNwYWNlZCBncm91cFxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgVW5kZXJzY29yZTpcblx0XHRcdFx0XHRvKGtleXdvcmQoS1dfRm9jdXMpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgSGFzaDpcblx0XHRcdFx0XHRpZiAoISh0cnlFYXQoU3BhY2UpIHx8IHRyeUVhdChUYWIpKSlcblx0XHRcdFx0XHRcdGN4LmZhaWwobG9jLCAoKSA9PiBgJHtjb2RlKCcjJyl9IG11c3QgYmUgZm9sbG93ZWQgYnkgc3BhY2Ugb3IgdGFiLn1gKVxuXHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayghaXNJblF1b3RlLCBsb2MsICdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYoKSAhPT0gU3BhY2UsIGxvYywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblxuXHRcdFx0XHRcdC8vIFNraXAgYW55IGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdHNraXBOZXdsaW5lcygpXG5cdFx0XHRcdFx0Y29uc3Qgb2xkSW5kZW50ID0gaW5kZW50XG5cdFx0XHRcdFx0aW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRjeC5jaGVjayhwZWVrKCkgIT09IFNwYWNlLCBwb3MsICdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRpZiAoaW5kZW50IDw9IG9sZEluZGVudCkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGluZGVudDsgaSA8IG9sZEluZGVudDsgaSA9IGkgKyAxKVxuXHRcdFx0XHRcdFx0XHRncChHUF9DbG9zZUJsb2NrKVxuXHRcdFx0XHRcdFx0Z3AoR1BfTGluZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soaW5kZW50ID09PSBvbGRJbmRlbnQgKyAxLCBsb2MsICdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlJylcblx0XHRcdFx0XHRcdGdwKEdQX09wZW5CbG9jaylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGxleFF1b3RlKGluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEFtcGVyc2FuZDogY2FzZSBCYWNrc2xhc2g6IGNhc2UgQmFja3RpY2s6IGNhc2UgQ2FyZXQ6XG5cdFx0XHRcdGNhc2UgQ29tbWE6IGNhc2UgUGVyY2VudDogY2FzZSBTZW1pY29sb246XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MsIGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0Y2FzZSBUYWI6XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MoKSwgJ1RhYiBtYXkgb25seSBiZSB1c2VkIHRvIGluZGVudCcpXG5cdFx0XHRcdGNhc2UgSHlwaGVuOlxuXHRcdFx0XHRcdGlmIChpc0RpZ2l0KHBlZWsoKSkpIHtcblx0XHRcdFx0XHRcdG8oZWF0TnVtYmVyKCkpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbHNlIGZhbGx0aHJvdWdoXG5cdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHQvLyBBbGwgb3RoZXIgY2hhcmFjdGVycyBzaG91bGQgYmUgaGFuZGxlZCBpbiBhIGNhc2UgYWJvdmUuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTmFtZUNoYXJhY3Rlcilcblx0XHRcdFx0XHRjb25zdCBrID0ga2V5d29yZEtGcm9tTmFtZShuYW1lKVxuXHRcdFx0XHRcdGlmIChrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSBLV19SZWdpb24pXG5cdFx0XHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRcdG8oa2V5d29yZChrKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRyeUVhdChVbmRlcnNjb3JlKSlcblx0XHRcdFx0XHRcdG8oQ2FsbE9uRm9jdXMobG9jKCksIG5hbWUpKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soIWlzUmVzZXJ2ZWROYW1lKG5hbWUpLCBwb3MsICgpID0+IGBSZXNlcnZlZCBuYW1lICR7Y29kZShuYW1lKX1gKVxuXHRcdFx0XHRcdFx0byhOYW1lKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBsZXhRdW90ZSA9IGluZGVudCA9PiB7XG5cdFx0Y29uc3QgcXVvdGVJbmRlbnQgPSBpbmRlbnQgKyAxXG5cblx0XHRjb25zdCBpc0luZGVudGVkID0gdHJ5RWF0TmV3bGluZSgpXG5cdFx0aWYgKGlzSW5kZW50ZWQpIHtcblx0XHRcdGNvbnN0IGFjdHVhbEluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRjeC5jaGVjayhhY3R1YWxJbmRlbnQgPT09IHF1b3RlSW5kZW50LCBwb3MsXG5cdFx0XHRcdCdJbmRlbnRlZCBxdW90ZSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbW9yZSBpbmRlbnQgdGhhbiBwcmV2aW91cyBsaW5lLicpXG5cdFx0fVxuXG5cdFx0bGV0IHJlYWQgPSAnJ1xuXG5cdFx0Y29uc3QgeWllbGRSZWFkID0gKCkgPT4ge1xuXHRcdFx0aWYgKHJlYWQgIT09ICcnKSB7XG5cdFx0XHRcdG8ocmVhZClcblx0XHRcdFx0cmVhZCA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfT3BlblF1b3RlKSlcblxuXHRcdGVhdENoYXJzOiB3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hQb3MgPSBwb3MoKVxuXHRcdFx0Y29uc3QgY2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIEJhY2tzbGFzaDoge1xuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgcXVvdGVFc2NhcGUoZWF0KCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE9wQnJhY2U6IHtcblx0XHRcdFx0XHR5aWVsZFJlYWQoKVxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IGNyZWF0ZSBhIEdyb3VwIG5vdyBiZWNhdXNlIHRoZXJlIG1heSBiZSBvdGhlciBHcm91cFByZV9zIGluc2lkZS5cblx0XHRcdFx0XHRvKEdyb3VwUHJlKHNpbmdsZUNoYXJMb2MoY2hQb3MpLCBHUF9PcGVuUGFyZW4pKVxuXHRcdFx0XHRcdHVuZ3JvdXBlZCh0cnVlKVxuXHRcdFx0XHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUGFyZW4pKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2socHJldiAhPT0gU3BhY2UsIGNoUG9zLCAnTGluZSBlbmRzIGluIGEgc3BhY2UnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5kZW50ZWQsIGNoUG9zLCAnVW5jbG9zZWQgcXVvdGUuJylcblx0XHRcdFx0XHQvLyBBbGxvdyBleHRyYSBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRjb25zdCBudW1OZXdsaW5lcyA9IHNraXBOZXdsaW5lcygpICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0luZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRcdFx0aWYgKG5ld0luZGVudCA8IHF1b3RlSW5kZW50KSB7XG5cdFx0XHRcdFx0XHQvLyBJbmRlbnRlZCBxdW90ZSBzZWN0aW9uIGlzIG92ZXIuXG5cdFx0XHRcdFx0XHQvLyBVbmRvIHJlYWRpbmcgdGhlIHRhYnMgYW5kIG5ld2xpbmUuXG5cdFx0XHRcdFx0XHRzdGVwQmFja01hbnkoY2hQb3MsIG51bU5ld2xpbmVzICsgbmV3SW5kZW50KVxuXHRcdFx0XHRcdFx0YXNzZXJ0KHBlZWsoKSA9PT0gTmV3bGluZSlcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRyZWFkID0gcmVhZCArXG5cdFx0XHRcdFx0XHRcdCdcXG4nLnJlcGVhdChudW1OZXdsaW5lcykgKyAnXFx0Jy5yZXBlYXQobmV3SW5kZW50IC0gcXVvdGVJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGlmICghaXNJbmRlbnRlZClcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR5aWVsZFJlYWQoKVxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUXVvdGUpKVxuXHR9XG5cblx0Y29uc3QgcXVvdGVFc2NhcGUgPSBjaCA9PiB7XG5cdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0Y2FzZSBPcEJyYWNlOiByZXR1cm4gJ3snXG5cdFx0XHRjYXNlIExldHRlck46IHJldHVybiAnXFxuJ1xuXHRcdFx0Y2FzZSBMZXR0ZXJUOiByZXR1cm4gJ1xcdCdcblx0XHRcdGNhc2UgUXVvdGU6IHJldHVybiAnXCInXG5cdFx0XHRjYXNlIEJhY2tzbGFzaDogcmV0dXJuICdcXFxcJ1xuXHRcdFx0ZGVmYXVsdDogY3guZmFpbChwb3MsIGBObyBuZWVkIHRvIGVzY2FwZSAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdH1cblx0fVxuXG5cdHVuZ3JvdXBlZChmYWxzZSlcblx0cmV0dXJuIHJlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=