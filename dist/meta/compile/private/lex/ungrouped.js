if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../Lang', '../Token', '../U/util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _Lang, _Token, _UUtil, _GroupPre, _char) {
	'use strict';

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	module.exports = function (cx, str) {
		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		// Use these for debugging pos.
		/*
  const
  	checkPos = () => {
  		const p = getCorrectPos()
  		if (p.line !== line || p.column !== column)
  			throw new Error(`index: ${index}, wrong: ${Pos(line, column)}, right: ${p}`)
  	},
  	indexToPos = new Map(),
  	getCorrectPos = () => {
  		if (index === 0)
  			return Pos(StartLine, StartColumn)
  			let oldPos, oldIndex
  		for (oldIndex = index - 1; oldIndex > 0; oldIndex = oldIndex - 1) {
  			oldPos = indexToPos.get(oldIndex)
  			if (oldPos)
  				break
  		}
  		if (oldPos === undefined) {
  			assert(oldIndex === 0)
  			oldPos = Pos(StartLine, StartColumn)
  		}
  		let newLine = oldPos.line, newColumn = oldPos.column
  		for (; oldIndex < index; oldIndex = oldIndex + 1)
  			if (str.charCodeAt(oldIndex) === Newline) {
  				newLine = newLine + 1
  				newColumn = StartColumn
  			} else
  				newColumn = newColumn + 1
  			const p = Pos(newLine, newColumn)
  		indexToPos.set(index, p)
  		return p
  	}
  */

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return _esastDistLoc.Pos(line, column);
		},
		      loc = function () {
			return _esastDistLoc.singleCharLoc(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === _char.Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === _char.Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			return _skipWhile(function (_) {
				return _ !== _char.Newline;
			});
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startLine, startColumn;
			const loc = function () {
				return _Loc(_esastDistLoc.Pos(startLine, startColumn), pos());
			},
			      keyword = function (k) {
				return _Token.Keyword(loc(), k);
			},
			      gp = function (k) {
				return o(_GroupPre2(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + _CompileError.code(lit);
				});
				return _Token.TokenNumberLiteral(loc(), num);
			};

			while (index !== str.length) {
				startLine = line;
				startColumn = column;

				ch = eat();
				switch (ch) {
					case _char.N0:case _char.N1:case _char.N2:case _char.N3:case _char.N4:
					case _char.N5:case _char.N6:case _char.N7:case _char.N8:case _char.N9:
						o(eatNumber());
						break;
					case _char.OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case _char.OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case _char.ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case _char.ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case _char.ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + _char.showChar(ch);
						});
						return;
					case _char.Space:
						cx.warnIf(peek() === _char.Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case _char.Dot:
						{
							const p = peek();
							if (p === _char.Space || p === _char.Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword('. '));
								gp(_GroupPre.GP_Space);
							} else o(_Token.DotName(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(_char.Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case _char.Colon:
						o(keyword(':'));
						break;
					case _char.Tilde:
						if (tryEat(_char.Bar)) {
							o(keyword('~|'));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword('~'));
							break;
						}
						break;
					case _char.Bar:
						// First arg in its own spaced group
						o(keyword('|'));
						gp(_GroupPre.GP_Space);
						break;
					case _char.Underscore:
						o(keyword('_'));
						break;
					case _char.Hash:
						if (!(tryEat(_char.Space) || tryEat(_char.Tab))) cx.fail(loc, function () {
							return '' + _CompileError.code('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case _char.Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== _char.Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(_char.Tab);
							cx.check(peek() !== _char.Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case _char.Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
						break;
					case _char.Quote:
						lexQuote(indent);
						break;
					case _char.Hyphen:
						if (_char.isDigit(peek())) {
							o(eatNumber());
							break;
						}
					// Else fallthrough
					default:
						{
							cx.check(!_char.isReservedCharacter(ch), loc, function () {
								return 'Reserved character ' + _char.showChar(ch);
							});
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);

							if (_Lang.NonNames.has(name)) if (name === 'region') {
								// Rest of line is a comment.
								skipRestOfLine();
								o(keyword('region'));
							} else if (_Lang.AllKeywords.has(name)) o(keyword(name));else cx.fail(loc, 'Reserved word ' + _CompileError.code(name));else if (tryEat(_char.Underscore)) o(_Token.CallOnFocus(loc(), name));else o(_Token.Name(loc(), name));
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(_char.Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o(_GroupPre2(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case _char.Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case _char.OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o(_GroupPre2(_esastDistLoc.singleCharLoc(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o(_GroupPre2(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case _char.Newline:
						{
							cx.check(prev !== _char.Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							// Allow extra blank lines.
							const numNewlines = skipNewlines() + 1;
							const newIndent = skipWhileEquals(_char.Tab);
							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, numNewlines + newIndent);
								_UUtil.assert(peek() === _char.Newline);
								break eatChars;
							} else read = read + '\n'.repeat(numNewlines) + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case _char.Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o(_GroupPre2(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case _char.OpBrace:
					return '{';
				case _char.LetterN:
					return '\n';
				case _char.LetterT:
					return '\t';
				case _char.Quote:
					return '"';
				case _char.Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + _char.showChar(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O2tCQVllLFVBQUMsRUFBRSxFQUFFLEdBQUcsRUFBSztBQUMzQixRQUFNLEdBQUcsR0FBRyxFQUFHLENBQUE7QUFDZixNQUFJLElBQUksaUJBZFUsU0FBUyxBQWNQLENBQUE7QUFDcEIsTUFBSSxNQUFNLGlCQWZtQixXQUFXLEFBZWhCLENBQUE7QUFDeEIsTUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNiLFFBQ0MsQ0FBQyxHQUFHLFVBQUEsQ0FBQyxFQUFJO0FBQUUsTUFBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUFFO1FBRXhCLEdBQUcsR0FBRztVQUFNLGNBMURBLEdBQUcsQ0EwREMsSUFBSSxFQUFFLE1BQU0sQ0FBQztHQUFBO1FBQzdCLEdBQUcsR0FBRztVQUFNLGNBM0Q2QixhQUFhLENBMkQ1QixHQUFHLEVBQUUsQ0FBQztHQUFBO1FBRWhDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztHQUFBO1FBQ3RDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO0dBQUE7UUFFbEMsR0FBRyxHQUFHLFlBQU07QUFDWCxTQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ2hDLFFBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0FBQ2pCLFNBQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ25CLFVBQU8sRUFBRSxDQUFBO0dBQ1Q7UUFDRCxNQUFNLEdBQUcsVUFBQSxFQUFFLEVBQUk7QUFDZCxTQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDNUIsT0FBSSxNQUFNLEVBQUU7QUFD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Q0FBQyxDQUFBO0FBQ2hCLFNBQU8sR0FBRyxDQUFBO0VBQ1YiLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvbGV4L3VuZ3JvdXBlZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2MsIHsgUG9zLCBTdGFydExpbmUsIFN0YXJ0Q29sdW1uLCBzaW5nbGVDaGFyTG9jIH0gZnJvbSAnZXNhc3QvZGlzdC9Mb2MnXG5pbXBvcnQgeyBjb2RlIH0gZnJvbSAnLi4vLi4vQ29tcGlsZUVycm9yJ1xuaW1wb3J0IHsgQWxsS2V5d29yZHMsIE5vbk5hbWVzIH0gZnJvbSAnLi4vTGFuZydcbmltcG9ydCB7IENhbGxPbkZvY3VzLCBEb3ROYW1lLCBLZXl3b3JkLCBUb2tlbk51bWJlckxpdGVyYWwsIE5hbWUgfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCBHcm91cFByZSwgeyBHUF9PcGVuUGFyZW4sIEdQX09wZW5CcmFja2V0LCBHUF9PcGVuQmxvY2ssIEdQX09wZW5RdW90ZSwgR1BfTGluZSxcblx0R1BfU3BhY2UsIEdQX0Nsb3NlUGFyZW4sIEdQX0Nsb3NlQnJhY2tldCwgR1BfQ2xvc2VCbG9jaywgR1BfQ2xvc2VRdW90ZX0gZnJvbSAnLi9Hcm91cFByZSdcbmltcG9ydCB7IHNob3dDaGFyLCBOMCwgTjEsIE4yLCBOMywgTjQsIE41LCBONiwgTjcsIE44LCBOOSxcblx0T3BQYXJlbiwgT3BCcmFja2V0LCBPcEJyYWNlLCBDbFBhcmVuLCBDbEJyYWNrZXQsIENsQnJhY2UsIFNwYWNlLCBEb3QsIENvbG9uLCBUaWxkZSwgQmFyLFxuXHRVbmRlcnNjb3JlLCBCYWNrc2xhc2gsIEhhc2gsIE5ld2xpbmUsIFF1b3RlLCBUYWIsIEh5cGhlbiwgTGV0dGVyTiwgTGV0dGVyVCxcblx0aXNEaWdpdCwgaXNOYW1lQ2hhcmFjdGVyLCBpc051bWJlckNoYXJhY3RlciwgaXNSZXNlcnZlZENoYXJhY3RlciB9IGZyb20gJy4vY2hhcidcblxuZXhwb3J0IGRlZmF1bHQgKGN4LCBzdHIpID0+IHtcblx0Y29uc3QgcmVzID0gWyBdXG5cdGxldCBsaW5lID0gU3RhcnRMaW5lXG5cdGxldCBjb2x1bW4gPSBTdGFydENvbHVtblxuXHRsZXQgaW5kZXggPSAwXG5cblx0Ly8gVXNlIHRoZXNlIGZvciBkZWJ1Z2dpbmcgcG9zLlxuXHQvKlxuXHRjb25zdFxuXHRcdGNoZWNrUG9zID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgcCA9IGdldENvcnJlY3RQb3MoKVxuXHRcdFx0aWYgKHAubGluZSAhPT0gbGluZSB8fCBwLmNvbHVtbiAhPT0gY29sdW1uKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGluZGV4OiAke2luZGV4fSwgd3Jvbmc6ICR7UG9zKGxpbmUsIGNvbHVtbil9LCByaWdodDogJHtwfWApXG5cdFx0fSxcblx0XHRpbmRleFRvUG9zID0gbmV3IE1hcCgpLFxuXHRcdGdldENvcnJlY3RQb3MgPSAoKSA9PiB7XG5cdFx0XHRpZiAoaW5kZXggPT09IDApXG5cdFx0XHRcdHJldHVybiBQb3MoU3RhcnRMaW5lLCBTdGFydENvbHVtbilcblxuXHRcdFx0bGV0IG9sZFBvcywgb2xkSW5kZXhcblx0XHRcdGZvciAob2xkSW5kZXggPSBpbmRleCAtIDE7IG9sZEluZGV4ID4gMDsgb2xkSW5kZXggPSBvbGRJbmRleCAtIDEpIHtcblx0XHRcdFx0b2xkUG9zID0gaW5kZXhUb1Bvcy5nZXQob2xkSW5kZXgpXG5cdFx0XHRcdGlmIChvbGRQb3MpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGlmIChvbGRQb3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhc3NlcnQob2xkSW5kZXggPT09IDApXG5cdFx0XHRcdG9sZFBvcyA9IFBvcyhTdGFydExpbmUsIFN0YXJ0Q29sdW1uKVxuXHRcdFx0fVxuXHRcdFx0bGV0IG5ld0xpbmUgPSBvbGRQb3MubGluZSwgbmV3Q29sdW1uID0gb2xkUG9zLmNvbHVtblxuXHRcdFx0Zm9yICg7IG9sZEluZGV4IDwgaW5kZXg7IG9sZEluZGV4ID0gb2xkSW5kZXggKyAxKVxuXHRcdFx0XHRpZiAoc3RyLmNoYXJDb2RlQXQob2xkSW5kZXgpID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdFx0bmV3TGluZSA9IG5ld0xpbmUgKyAxXG5cdFx0XHRcdFx0bmV3Q29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0bmV3Q29sdW1uID0gbmV3Q29sdW1uICsgMVxuXG5cdFx0XHRjb25zdCBwID0gUG9zKG5ld0xpbmUsIG5ld0NvbHVtbilcblx0XHRcdGluZGV4VG9Qb3Muc2V0KGluZGV4LCBwKVxuXHRcdFx0cmV0dXJuIHBcblx0XHR9XG5cdCovXG5cblx0Y29uc3Rcblx0XHRvID0gdCA9PiB7IHJlcy5wdXNoKHQpIH0sXG5cblx0XHRwb3MgPSAoKSA9PiBQb3MobGluZSwgY29sdW1uKSxcblx0XHRsb2MgPSAoKSA9PiBzaW5nbGVDaGFyTG9jKHBvcygpKSxcblxuXHRcdHByZXYgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCAtIDEpLFxuXHRcdHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCksXG5cblx0XHRlYXQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBjaCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KVxuXHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIDFcblx0XHRcdHJldHVybiBjaFxuXHRcdH0sXG5cdFx0dHJ5RWF0ID0gY2ggPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBjaFxuXHRcdFx0aWYgKGNhbkVhdCkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyAxXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FuRWF0XG5cdFx0fSxcblx0XHR0cnlFYXROZXdsaW5lID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBOZXdsaW5lXG5cdFx0XHRpZiAoY2FuRWF0KSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbkVhdFxuXHRcdH0sXG5cblx0XHQvLyBDYWxsZXIgbXVzdCBlbnN1cmUgdGhhdCBiYWNraW5nIHVwIG5DaGFyc1RvQmFja1VwIGNoYXJhY3RlcnMgYnJpbmdzIHVzIHRvIG9sZFBvcy5cblx0XHRzdGVwQmFja01hbnkgPSAob2xkUG9zLCBuQ2hhcnNUb0JhY2tVcCkgPT4ge1xuXHRcdFx0aW5kZXggPSBpbmRleCAtIG5DaGFyc1RvQmFja1VwXG5cdFx0XHRsaW5lID0gb2xkUG9zLmxpbmVcblx0XHRcdGNvbHVtbiA9IG9sZFBvcy5jb2x1bW5cblx0XHR9LFxuXG5cdFx0X3NraXBXaGlsZSA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHR3aGlsZSAocHJlZChwZWVrKCkpKVxuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0Y29uc3QgZGlmZiA9IGluZGV4IC0gc3RhcnRJbmRleFxuXHRcdFx0Y29sdW1uID0gY29sdW1uICsgZGlmZlxuXHRcdFx0cmV0dXJuIGRpZmZcblx0XHR9LFxuXHRcdHRha2VXaGlsZVdpdGhQcmV2ID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCAtIDEsIGluZGV4KVxuXHRcdH0sXG5cdFx0dGFrZVdoaWxlID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCwgaW5kZXgpXG5cdFx0fSxcblx0XHRza2lwV2hpbGVFcXVhbHMgPSBjaCA9PiBfc2tpcFdoaWxlKF8gPT4gXyA9PT0gY2gpLFxuXG5cdFx0Ly8gQ2FsbGVkIGFmdGVyIHNlZWluZyB0aGUgZmlyc3QgbmV3bGluZS5cblx0XHRza2lwTmV3bGluZXMgPSAoKSA9PiB7XG5cdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdGNvbnN0IHN0YXJ0TGluZSA9IGxpbmVcblx0XHRcdHdoaWxlIChwZWVrKCkgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHR9XG5cdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0cmV0dXJuIGxpbmUgLSBzdGFydExpbmVcblx0XHR9LFxuXG5cdFx0c2tpcFJlc3RPZkxpbmUgPSAoKSA9PlxuXHRcdFx0X3NraXBXaGlsZShfID0+IF8gIT09IE5ld2xpbmUpXG5cblx0Y29uc3QgdW5ncm91cGVkID0gaXNJblF1b3RlID0+IHtcblx0XHRsZXQgaW5kZW50ID0gMFxuXG5cdFx0bGV0IGNoLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uXG5cdFx0Y29uc3Rcblx0XHRcdGxvYyA9ICgpID0+IExvYyhQb3Moc3RhcnRMaW5lLCBzdGFydENvbHVtbiksIHBvcygpKSxcblx0XHRcdGtleXdvcmQgPSBrID0+IEtleXdvcmQobG9jKCksIGspLFxuXHRcdFx0Z3AgPSBrID0+IG8oR3JvdXBQcmUobG9jKCksIGspKSxcblx0XHRcdGVhdE51bWJlciA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgbGl0ID0gdGFrZVdoaWxlV2l0aFByZXYoaXNOdW1iZXJDaGFyYWN0ZXIpXG5cdFx0XHRcdGNvbnN0IG51bSA9IE51bWJlcihsaXQpXG5cdFx0XHRcdGN4LmNoZWNrKCFOdW1iZXIuaXNOYU4obnVtKSwgcG9zLCAoKSA9PlxuXHRcdFx0XHRcdGBJbnZhbGlkIG51bWJlciBsaXRlcmFsICR7Y29kZShsaXQpfWApXG5cdFx0XHRcdHJldHVybiBUb2tlbk51bWJlckxpdGVyYWwobG9jKCksIG51bSlcblx0XHRcdH1cblxuXHRcdHdoaWxlIChpbmRleCAhPT0gc3RyLmxlbmd0aCkge1xuXHRcdFx0c3RhcnRMaW5lID0gbGluZVxuXHRcdFx0c3RhcnRDb2x1bW4gPSBjb2x1bW5cblxuXHRcdFx0Y2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIE4wOiBjYXNlIE4xOiBjYXNlIE4yOiBjYXNlIE4zOiBjYXNlIE40OlxuXHRcdFx0XHRjYXNlIE41OiBjYXNlIE42OiBjYXNlIE43OiBjYXNlIE44OiBjYXNlIE45OlxuXHRcdFx0XHRcdG8oZWF0TnVtYmVyKCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBPcFBhcmVuOlxuXHRcdFx0XHRcdGdwKEdQX09wZW5QYXJlbilcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE9wQnJhY2tldDpcblx0XHRcdFx0XHRncChHUF9PcGVuQnJhY2tldClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsUGFyZW46XG5cdFx0XHRcdFx0Z3AoR1BfQ2xvc2VQYXJlbilcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsQnJhY2tldDpcblx0XHRcdFx0XHRncChHUF9DbG9zZUJyYWNrZXQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbEJyYWNlOlxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5RdW90ZSwgbG9jLCAoKSA9PiBgUmVzZXJ2ZWQgY2hhcmFjdGVyICR7c2hvd0NoYXIoY2gpfWApXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGNhc2UgU3BhY2U6XG5cdFx0XHRcdFx0Y3gud2FybklmKHBlZWsoKSA9PT0gU3BhY2UsIGxvYywgJ011bHRpcGxlIHNwYWNlcyBpbiBhIHJvdycpXG5cdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBEb3Q6IHtcblx0XHRcdFx0XHRjb25zdCBwID0gcGVlaygpXG5cdFx0XHRcdFx0aWYgKHAgPT09IFNwYWNlIHx8IHAgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0XHRcdC8vIE9iakxpdCBhc3NpZ24gaW4gaXRzIG93biBzcGFjZWQgZ3JvdXAuXG5cdFx0XHRcdFx0XHQvLyBXZSBjYW4ndCBqdXN0IGNyZWF0ZSBhIG5ldyBHcm91cCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0b1xuXHRcdFx0XHRcdFx0Ly8gZW5zdXJlIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHByZWNlZGluZyBvciBmb2xsb3dpbmcgc3BhY2VkIGdyb3VwLlxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoJy4gJykpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdG8oRG90TmFtZShcblx0XHRcdFx0XHRcdFx0bG9jKCksXG5cdFx0XHRcdFx0XHRcdC8vICsxIGZvciB0aGUgZG90IHdlIGp1c3Qgc2tpcHBlZC5cblx0XHRcdFx0XHRcdFx0c2tpcFdoaWxlRXF1YWxzKERvdCkgKyAxLFxuXHRcdFx0XHRcdFx0XHR0YWtlV2hpbGUoaXNOYW1lQ2hhcmFjdGVyKSkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIENvbG9uOlxuXHRcdFx0XHRcdG8oa2V5d29yZCgnOicpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgVGlsZGU6XG5cdFx0XHRcdFx0aWYgKHRyeUVhdChCYXIpKSB7XG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoJ358JykpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZCgnficpKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBCYXI6XG5cdFx0XHRcdFx0Ly8gRmlyc3QgYXJnIGluIGl0cyBvd24gc3BhY2VkIGdyb3VwXG5cdFx0XHRcdFx0byhrZXl3b3JkKCd8JykpXG5cdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBVbmRlcnNjb3JlOlxuXHRcdFx0XHRcdG8oa2V5d29yZCgnXycpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgSGFzaDpcblx0XHRcdFx0XHRpZiAoISh0cnlFYXQoU3BhY2UpIHx8IHRyeUVhdChUYWIpKSlcblx0XHRcdFx0XHRcdGN4LmZhaWwobG9jLCAoKSA9PiBgJHtjb2RlKCcjJyl9IG11c3QgYmUgZm9sbG93ZWQgYnkgc3BhY2Ugb3IgdGFiLn1gKVxuXHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayghaXNJblF1b3RlLCBsb2MsICdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYoKSAhPT0gU3BhY2UsIGxvYywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblxuXHRcdFx0XHRcdC8vIFNraXAgYW55IGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdHNraXBOZXdsaW5lcygpXG5cdFx0XHRcdFx0Y29uc3Qgb2xkSW5kZW50ID0gaW5kZW50XG5cdFx0XHRcdFx0aW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRjeC5jaGVjayhwZWVrKCkgIT09IFNwYWNlLCBwb3MsICdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRpZiAoaW5kZW50IDw9IG9sZEluZGVudCkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGluZGVudDsgaSA8IG9sZEluZGVudDsgaSA9IGkgKyAxKVxuXHRcdFx0XHRcdFx0XHRncChHUF9DbG9zZUJsb2NrKVxuXHRcdFx0XHRcdFx0Z3AoR1BfTGluZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soaW5kZW50ID09PSBvbGRJbmRlbnQgKyAxLCBsb2MsICdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlJylcblx0XHRcdFx0XHRcdGdwKEdQX09wZW5CbG9jaylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFRhYjpcblx0XHRcdFx0XHRjeC5mYWlsKGxvYygpLCAnVGFiIG1heSBvbmx5IGJlIHVzZWQgdG8gaW5kZW50Jylcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGxleFF1b3RlKGluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEh5cGhlbjpcblx0XHRcdFx0XHRpZiAoaXNEaWdpdChwZWVrKCkpKSB7XG5cdFx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0Y3guY2hlY2soXG5cdFx0XHRcdFx0XHQhaXNSZXNlcnZlZENoYXJhY3RlcihjaCksIGxvYywgKCkgPT4gYFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdFx0XHRcdC8vIEFsbCBvdGhlciBjaGFyYWN0ZXJzIHNob3VsZCBiZSBoYW5kbGVkIGluIGEgY2FzZSBhYm92ZS5cblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGFrZVdoaWxlV2l0aFByZXYoaXNOYW1lQ2hhcmFjdGVyKVxuXG5cdFx0XHRcdFx0aWYgKE5vbk5hbWVzLmhhcyhuYW1lKSlcblx0XHRcdFx0XHRcdGlmIChuYW1lID09PSAncmVnaW9uJykge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0IG9mIGxpbmUgaXMgYSBjb21tZW50LlxuXHRcdFx0XHRcdFx0XHRza2lwUmVzdE9mTGluZSgpXG5cdFx0XHRcdFx0XHRcdG8oa2V5d29yZCgncmVnaW9uJykpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKEFsbEtleXdvcmRzLmhhcyhuYW1lKSlcblx0XHRcdFx0XHRcdFx0byhrZXl3b3JkKG5hbWUpKVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRjeC5mYWlsKGxvYywgYFJlc2VydmVkIHdvcmQgJHtjb2RlKG5hbWUpfWApXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHJ5RWF0KFVuZGVyc2NvcmUpKVxuXHRcdFx0XHRcdFx0byhDYWxsT25Gb2N1cyhsb2MoKSwgbmFtZSkpXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0byhOYW1lKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGxleFF1b3RlID0gaW5kZW50ID0+IHtcblx0XHRjb25zdCBxdW90ZUluZGVudCA9IGluZGVudCArIDFcblxuXHRcdGNvbnN0IGlzSW5kZW50ZWQgPSB0cnlFYXROZXdsaW5lKClcblx0XHRpZiAoaXNJbmRlbnRlZCkge1xuXHRcdFx0Y29uc3QgYWN0dWFsSW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdGN4LmNoZWNrKGFjdHVhbEluZGVudCA9PT0gcXVvdGVJbmRlbnQsIHBvcyxcblx0XHRcdFx0J0luZGVudGVkIHF1b3RlIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBtb3JlIGluZGVudCB0aGFuIHByZXZpb3VzIGxpbmUuJylcblx0XHR9XG5cblx0XHRsZXQgcmVhZCA9ICcnXG5cblx0XHRjb25zdCB5aWVsZFJlYWQgPSAoKSA9PiB7XG5cdFx0XHRpZiAocmVhZCAhPT0gJycpIHtcblx0XHRcdFx0byhyZWFkKVxuXHRcdFx0XHRyZWFkID0gJydcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvKEdyb3VwUHJlKGxvYygpLCBHUF9PcGVuUXVvdGUpKVxuXG5cdFx0ZWF0Q2hhcnM6IHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb25zdCBjaFBvcyA9IHBvcygpXG5cdFx0XHRjb25zdCBjaCA9IGVhdCgpXG5cdFx0XHRzd2l0Y2ggKGNoKSB7XG5cdFx0XHRcdGNhc2UgQmFja3NsYXNoOiB7XG5cdFx0XHRcdFx0cmVhZCA9IHJlYWQgKyBxdW90ZUVzY2FwZShlYXQoKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgT3BCcmFjZToge1xuXHRcdFx0XHRcdHlpZWxkUmVhZCgpXG5cdFx0XHRcdFx0Ly8gV2UgY2FuJ3QgY3JlYXRlIGEgR3JvdXAgbm93IGJlY2F1c2UgdGhlcmUgbWF5IGJlIG90aGVyIEdyb3VwUHJlX3MgaW5zaWRlLlxuXHRcdFx0XHRcdG8oR3JvdXBQcmUoc2luZ2xlQ2hhckxvYyhjaFBvcyksIEdQX09wZW5QYXJlbikpXG5cdFx0XHRcdFx0dW5ncm91cGVkKHRydWUpXG5cdFx0XHRcdFx0byhHcm91cFByZShsb2MoKSwgR1BfQ2xvc2VQYXJlbikpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayhwcmV2ICE9PSBTcGFjZSwgY2hQb3MsICdMaW5lIGVuZHMgaW4gYSBzcGFjZScpXG5cdFx0XHRcdFx0Y3guY2hlY2soaXNJbmRlbnRlZCwgY2hQb3MsICdVbmNsb3NlZCBxdW90ZS4nKVxuXHRcdFx0XHRcdC8vIEFsbG93IGV4dHJhIGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdGNvbnN0IG51bU5ld2xpbmVzID0gc2tpcE5ld2xpbmVzKCkgKyAxXG5cdFx0XHRcdFx0Y29uc3QgbmV3SW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRpZiAobmV3SW5kZW50IDwgcXVvdGVJbmRlbnQpIHtcblx0XHRcdFx0XHRcdC8vIEluZGVudGVkIHF1b3RlIHNlY3Rpb24gaXMgb3Zlci5cblx0XHRcdFx0XHRcdC8vIFVuZG8gcmVhZGluZyB0aGUgdGFicyBhbmQgbmV3bGluZS5cblx0XHRcdFx0XHRcdHN0ZXBCYWNrTWFueShjaFBvcywgbnVtTmV3bGluZXMgKyBuZXdJbmRlbnQpXG5cdFx0XHRcdFx0XHRhc3NlcnQocGVlaygpID09PSBOZXdsaW5lKVxuXHRcdFx0XHRcdFx0YnJlYWsgZWF0Q2hhcnNcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHJlYWQgPSByZWFkICtcblx0XHRcdFx0XHRcdFx0J1xcbicucmVwZWF0KG51bU5ld2xpbmVzKSArICdcXHQnLnJlcGVhdChuZXdJbmRlbnQgLSBxdW90ZUluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgUXVvdGU6XG5cdFx0XHRcdFx0aWYgKCFpc0luZGVudGVkKVxuXHRcdFx0XHRcdFx0YnJlYWsgZWF0Q2hhcnNcblx0XHRcdFx0XHQvLyBFbHNlIGZhbGx0aHJvdWdoXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cmVhZCA9IHJlYWQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHlpZWxkUmVhZCgpXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfQ2xvc2VRdW90ZSkpXG5cdH1cblxuXHRjb25zdCBxdW90ZUVzY2FwZSA9IGNoID0+IHtcblx0XHRzd2l0Y2ggKGNoKSB7XG5cdFx0XHRjYXNlIE9wQnJhY2U6IHJldHVybiAneydcblx0XHRcdGNhc2UgTGV0dGVyTjogcmV0dXJuICdcXG4nXG5cdFx0XHRjYXNlIExldHRlclQ6IHJldHVybiAnXFx0J1xuXHRcdFx0Y2FzZSBRdW90ZTogcmV0dXJuICdcIidcblx0XHRcdGNhc2UgQmFja3NsYXNoOiByZXR1cm4gJ1xcXFwnXG5cdFx0XHRkZWZhdWx0OiBjeC5mYWlsKHBvcywgYE5vIG5lZWQgdG8gZXNjYXBlICR7c2hvd0NoYXIoY2gpfWApXG5cdFx0fVxuXHR9XG5cblx0dW5ncm91cGVkKGZhbHNlKVxuXHRyZXR1cm4gcmVzXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==