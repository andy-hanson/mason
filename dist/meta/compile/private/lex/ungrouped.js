if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../language', '../Token', '../util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _language, _Token, _util, _GroupPre, _char) {
	'use strict';

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	const cc = function (ch) {
		return ch.charCodeAt(0);
	};
	const N0 = cc('0'),
	      N1 = cc('1'),
	      N2 = cc('2'),
	      N3 = cc('3'),
	      N4 = cc('4'),
	      N5 = cc('5'),
	      N6 = cc('6'),
	      N7 = cc('7'),
	      N8 = cc('8'),
	      N9 = cc('9'),
	      OpParen = cc('('),
	      OpBracket = cc('['),
	      OpBrace = cc('{'),
	      ClParen = cc(')'),
	      ClBracket = cc(']'),
	      ClBrace = cc('}'),
	      Ampersand = cc('&'),
	      Backslash = cc('\\'),
	      Backtick = cc('`'),
	      Bar = cc('|'),
	      Caret = cc('^'),
	      Colon = cc(':'),
	      Comma = cc(','),
	      Dot = cc('.'),
	      Equal = cc('='),
	      Hash = cc('#'),
	      Hyphen = cc('-'),
	      LetterN = cc('n'),
	      LetterT = cc('t'),
	      Newline = cc('\n'),
	      Percent = cc('%'),
	      Quote = cc('"'),
	      Semicolon = cc(';'),
	      Space = cc(' '),
	      Tab = cc('\t'),
	      Tilde = cc('~'),
	      Underscore = cc('_'),
	      Zero = cc('\u0000');

	module.exports = function (cx, str) {
		// Lexing algorithm requires trailing newline.
		// Use a null-terminated string because it's faster than checking whether index === length.
		str = str + '\n\u0000';

		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		// Use these for debugging pos.
		/*
  const
  	checkPos = () => {
  		const p = getCorrectPos()
  		if (p.line !== line || p.column !== column)
  			throw new Error(`index: ${index}, wrong: ${Pos(line, column)}, right: ${p}`)
  	},
  	indexToPos = new Map(),
  	getCorrectPos = () => {
  		if (index === 0)
  			return Pos(StartLine, StartColumn)
  			let oldPos, oldIndex
  		for (oldIndex = index - 1; oldIndex > 0; oldIndex = oldIndex - 1) {
  			oldPos = indexToPos.get(oldIndex)
  			if (oldPos)
  				break
  		}
  		if (oldPos === undefined) {
  			assert(oldIndex === 0)
  			oldPos = Pos(StartLine, StartColumn)
  		}
  		let newLine = oldPos.line, newColumn = oldPos.column
  		for (; oldIndex < index; oldIndex = oldIndex + 1)
  			if (str.charCodeAt(oldIndex) === Newline) {
  				newLine = newLine + 1
  				newColumn = StartColumn
  			} else
  				newColumn = newColumn + 1
  			const p = Pos(newLine, newColumn)
  		indexToPos.set(index, p)
  		return p
  	}
  */

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return (0, _esastDistLoc.Pos)(line, column);
		},
		      loc = function () {
			return (0, _esastDistLoc.singleCharLoc)(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			return _skipWhile(function (_) {
				return _ !== Newline;
			});
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startColumn;
			const loc = function () {
				return (0, _Loc)((0, _esastDistLoc.Pos)(line, startColumn), pos());
			},
			      keyword = function (k) {
				return (0, _Token.Keyword)(loc(), k);
			},
			      gp = function (k) {
				return o((0, _GroupPre2)(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + (0, _CompileError.code)(lit);
				});
				return (0, _Token.TokenNumberLiteral)(loc(), num);
			};

			while (true) {
				startColumn = column;
				ch = eat();
				switch (ch) {
					case Zero:
						return;
					case N0:case N1:case N2:case N3:case N4:
					case N5:case N6:case N7:case N8:case N9:
						o(eatNumber());
						break;
					case OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + (0, _char.showChar)(ch);
						});
						return;
					case Space:
						cx.warnIf(peek() === Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case Dot:
						{
							const p = peek();
							if (p === Space || p === Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword(_Token.KW_ObjAssign));
								gp(_GroupPre.GP_Space);
							} else o((0, _Token.DotName)(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case Colon:
						if (tryEat(Colon)) {
							const eq = tryEat(Equal);
							cx.check(eq, loc, function () {
								return '' + (0, _CompileError.code)('::') + ' must be followed by ' + (0, _CompileError.code)('=');
							});
							o(keyword(_Token.KW_AssignMutable));
						} else if (tryEat(Equal)) o(keyword(_Token.KW_AssignMutate));else o(keyword(_Token.KW_Type));
						break;
					case Tilde:
						if (tryEat(Bar)) {
							o(keyword(_Token.KW_GenFun));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword(_Token.KW_Lazy));
							break;
						}
						break;
					case Bar:
						o(keyword(_Token.KW_Fun));
						// First arg in its own spaced group
						gp(_GroupPre.GP_Space);
						break;
					case Underscore:
						o(keyword(_Token.KW_Focus));
						break;
					case Hash:
						if (!(tryEat(Space) || tryEat(Tab))) cx.fail(loc, function () {
							return '' + (0, _CompileError.code)('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(Tab);
							cx.check(peek() !== Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case Quote:
						lexQuote(indent);
						break;
					case Ampersand:case Backslash:case Backtick:case Caret:
					case Comma:case Percent:case Semicolon:
						cx.fail(loc, 'Reserved character ' + (0, _char.showChar)(ch));
					case Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
					case Hyphen:
						if ((0, _char.isDigit)(peek())) {
							o(eatNumber());
							break;
						}
					// else fallthrough
					default:
						{
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);
							const k = (0, _Token.keywordKFromName)(name);
							if (k !== undefined) {
								if (k === _Token.KW_Region) skipRestOfLine();
								o(keyword(k));
							} else if (tryEat(Underscore)) o((0, _Token.CallOnFocus)(loc(), name));else {
								cx.check(!(0, _language.isReservedName)(name), pos, function () {
									return 'Reserved name ' + (0, _CompileError.code)(name);
								});
								o((0, _Token.Name)(loc(), name));
							}
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o((0, _GroupPre2)(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o((0, _GroupPre2)((0, _esastDistLoc.singleCharLoc)(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case Newline:
						{
							cx.check(prev !== Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							// Allow extra blank lines.
							const numNewlines = skipNewlines() + 1;
							const newIndent = skipWhileEquals(Tab);
							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, numNewlines + newIndent);
								(0, _util.assert)(peek() === Newline);
								break eatChars;
							} else read = read + '\n'.repeat(numNewlines) + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case OpBrace:
					return '{';
				case LetterN:
					return '\n';
				case LetterT:
					return '\t';
				case Quote:
					return '"';
				case Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + (0, _char.showChar)(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBV0EsT0FBTSxFQUFFLEdBQUcsVUFBQSxFQUFFO1NBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFBQSxDQUFBO0FBQ2pDLE9BQ0MsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNwRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ3BFLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUN6RCxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDekQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbkIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7T0FDcEIsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbEIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDYixLQUFLLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNmLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ2YsS0FBSyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDZixHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNiLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ2YsSUFBSSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDZCxNQUFNLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNoQixPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNqQixPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNqQixPQUFPLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztPQUNsQixPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNqQixLQUFLLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNmLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ25CLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ2YsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7T0FDZCxLQUFLLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNmLFVBQVUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ3BCLElBQUksR0FBRyxFQUFFLENBQUMsUUFBSSxDQUFDLENBQUE7O2tCQUVELFVBQUMsRUFBRSxFQUFFLEdBQUcsRUFBSzs7O0FBRzNCLEtBQUcsR0FBRyxHQUFHLEdBQUcsVUFBTSxDQUFBOztBQUVsQixRQUFNLEdBQUcsR0FBRyxFQUFHLENBQUE7QUFDZixNQUFJLElBQUksaUJBOUNVLFNBQVMsQUE4Q1AsQ0FBQTtBQUNwQixNQUFJLE1BQU0saUJBL0NtQixXQUFXLEFBK0NoQixDQUFBO0FBQ3hCLE1BQUksS0FBSyxHQUFHLENBQUMsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDYixRQUNDLENBQUMsR0FBRyxVQUFBLENBQUMsRUFBSTtBQUFFLE1BQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7R0FBRTtRQUV4QixHQUFHLEdBQUc7VUFBTSxrQkExRkEsR0FBRyxFQTBGQyxJQUFJLEVBQUUsTUFBTSxDQUFDO0dBQUE7UUFDN0IsR0FBRyxHQUFHO1VBQU0sa0JBM0Y2QixhQUFhLEVBMkY1QixHQUFHLEVBQUUsQ0FBQztHQUFBO1FBRWhDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztHQUFBO1FBQ3RDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO0dBQUE7UUFFbEMsR0FBRyxHQUFHLFlBQU07QUFDWCxTQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ2hDLFFBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0FBQ2pCLFNBQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ25CLFVBQU8sRUFBRSxDQUFBO0dBQ1Q7UUFDRCxNQUFNLEdBQUcsVUFBQSxFQUFFLEVBQUk7QUFDZCxTQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDNUIsT0FBSSxNQUFNLEVBQUU7QUFDWCxTQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtBQUNqQixVQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQTtJQUNuQjtBQUNELFVBQU8sTUFBTSxDQUFBO0dBQ2I7UUFDRCxhQUFhLEdBQUcsWUFBTTtBQUNyQixTQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsS0FBSyxPQUFPLENBQUE7QUFDakMsT0FBSSxNQUFNLEVBQUU7QUFDWCxTQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtBQUNqQixRQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQTtBQUNmLFVBQU0saUJBbkhvQixXQUFXLEFBbUhqQixDQUFBO0lBQ3BCO0FBQ0QsVUFBTyxNQUFNLENBQUE7R0FDYjs7OztBQUdELGNBQVksR0FBRyxVQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUs7QUFDMUMsUUFBSyxHQUFHLEtBQUssR0FBRyxjQUFjLENBQUE7QUFDOUIsT0FBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUE7QUFDbEIsU0FBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUE7R0FDdEI7UUFFRCxVQUFVLEdBQUcsVUFBQSxJQUFJLEVBQUk7QUFDcEIsU0FBTSxVQUFVLEdBQUcsS0FBSyxDQUFBO0FBQ3hCLFVBQU8sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQ2xCLEtBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0FBQ2xCLFNBQU0sSUFBSSxHQUFHLEtBQUssR0FBRyxVQUFVLENBQUE7QUFDL0IsU0FBTSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUE7QUFDdEIsVUFBTyxJQUFJLENBQUE7R0FDWDtRQUNELGlCQUFpQixHQUFHLFVBQUEsSUFBSSxFQUFJO0FBQzNCLFNBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQTtBQUN4QixhQUFVLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDaEIsVUFBTyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7R0FDdkM7UUFDRCxTQUFTLEdBQUcsVUFBQSxJQUFJLEVBQUk7QUFDbkIsU0FBTSxVQUFVLEdBQUcsS0FBSyxDQUFBO0FBQ3hCLGFBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUNoQixVQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFBO0dBQ25DO1FBQ0QsZUFBZSxHQUFHLFVBQUEsRUFBRTtVQUFJLFVBQVUsQ0FBQyxVQUFBLENBQUM7V0FBSSxDQUFDLEtBQUssRUFBRTtJQUFBLENBQUM7R0FBQTs7OztBQUdqRCxjQUFZLEdBQUcsWUFBTTtBQUNwQixPQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQTtBQUNmLFNBQU0sU0FBUyxHQUFHLElBQUksQ0FBQTtBQUN0QixVQUFPLElBQUksRUFBRSxLQUFLLE9BQU8sRUFBRTtBQUMxQixTQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtBQUNqQixRQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQTtJQUNmO0FBQ0QsU0FBTSxpQkEzSnFCLFdBQVcsQUEySmxCLENBQUE7QUFDcEIsVUFBTyxJQUFJLEdBQUcsU0FBUyxDQUFBO0dBQ3ZCO1FBRUQsY0FBYyxHQUFHO1VBQ2hCLFVBQVUsQ0FBQyxVQUFBLENBQUM7V0FBSSxDQUFDLEtBQUssT0FBTztJQUFBLENBQUM7R0FBQSxDQUFBOztBQUVoQyxRQUFNLFNBQVMsR0FBRyxVQUFBLFNBQVMsRUFBSTtBQUM5QixPQUFJLE1BQU0sR0FBRyxDQUFDLENBQUE7O0FBRWQsT0FBSSxFQUFFLEVBQUUsV0FBVyxDQUFBO0FBQ25CLFNBQ0MsR0FBRyxHQUFHO1dBQU0sVUFBSSxrQkF2S0wsR0FBRyxFQXVLTSxJQUFJLEVBQUUsV0FBVyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFBQTtTQUM5QyxPQUFPLEdBQUcsVUFBQSxDQUFDO1dBQUksV0FyS2EsT0FBTyxFQXFLWixHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFBQTtTQUNoQyxFQUFFLEdBQUcsVUFBQSxDQUFDO1dBQUksQ0FBQyxDQUFDLGdCQUFTLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQUE7U0FDL0IsU0FBUyxHQUFHLFlBQU07QUFDakIsVUFBTSxHQUFHLEdBQUcsaUJBQWlCLE9BbEtZLGlCQUFpQixDQWtLVixDQUFBO0FBQ2hELFVBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUN2QixNQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUU7d0NBQ1Asa0JBN0t0QixJQUFJLEVBNkt1QixHQUFHLENBQUM7S0FBRSxDQUFDLENBQUE7QUFDdkMsV0FBTyxXQTVLNkIsa0JBQWtCLEVBNEs1QixHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQTtJQUNyQyxDQUFBOztBQUVGLFVBQU8sSUFBSSxFQUFFO0FBQ1osZUFBVyxHQUFHLE1BQU0sQ0FBQTtBQUNwQixNQUFFLEdBQUcsR0FBRyxFQUFFLENBQUE7QUFDVixZQUFRLEVBQUU7QUFDVCxVQUFLLElBQUk7QUFDUixhQUFNO0FBQUEsQUFDUCxVQUFLLEVBQUUsQ0FBQyxBQUFDLEtBQUssRUFBRSxDQUFDLEFBQUMsS0FBSyxFQUFFLENBQUMsQUFBQyxLQUFLLEVBQUUsQ0FBQyxBQUFDLEtBQUssRUFBRSxDQUFDO0FBQzVDLFVBQUssRUFBRSxDQUFDLEFBQUMsS0FBSyxFQUFFLENBQUMsQUFBQyxLQUFLLEVBQUUsQ0FBQyxBQUFDLEtBQUssRUFBRSxDQUFDLEFBQUMsS0FBSyxFQUFFO0FBQzFDLE9BQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFBO0FBQ2QsWUFBSztBQUFBLEFBQ04sVUFBSyxPQUFPO0FBQ1gsUUFBRSxXQXRMWSxZQUFZLENBc0xWLENBQUE7QUFDaEIsWUFBSztBQUFBLEFBQ04sVUFBSyxTQUFTO0FBQ2IsUUFBRSxXQXpMMEIsY0FBYyxDQXlMeEIsQ0FBQTtBQUNsQixZQUFLO0FBQUEsQUFDTixVQUFLLE9BQU87QUFDWCxRQUFFLFdBM0xJLGFBQWEsQ0EyTEYsQ0FBQTtBQUNqQixZQUFLO0FBQUEsQUFDTixVQUFLLFNBQVM7QUFDYixRQUFFLFdBOUxtQixlQUFlLENBOExqQixDQUFBO0FBQ25CLFlBQUs7QUFBQSxBQUNOLFVBQUssT0FBTztBQUNYLFFBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRTtzQ0FBNEIsVUFoTWpELFFBQVEsRUFnTWtELEVBQUUsQ0FBQztPQUFFLENBQUMsQ0FBQTtBQUNwRSxhQUFNO0FBQUEsQUFDUCxVQUFLLEtBQUs7QUFDVCxRQUFFLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLEtBQUssRUFBRSxHQUFHLEVBQUUsMEJBQTBCLENBQUMsQ0FBQTtBQUM1RCxRQUFFLFdBck1OLFFBQVEsQ0FxTVEsQ0FBQTtBQUNaLFlBQUs7QUFBQSxBQUNOLFVBQUssR0FBRztBQUFFO0FBQ1QsYUFBTSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUE7QUFDaEIsV0FBSSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxPQUFPLEVBQUU7Ozs7QUFJakMsVUFBRSxXQTdNUCxRQUFRLENBNk1TLENBQUE7QUFDWixTQUFDLENBQUMsT0FBTyxRQWpOTCxZQUFZLENBaU5PLENBQUMsQ0FBQTtBQUN4QixVQUFFLFdBL01QLFFBQVEsQ0ErTVMsQ0FBQTtRQUNaLE1BQ0EsQ0FBQyxDQUFDLFdBdE5jLE9BQU8sRUF1TnRCLEdBQUcsRUFBRTs7QUFFTCxzQkFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFDeEIsU0FBUyxPQXBOWSxlQUFlLENBb05WLENBQUMsQ0FBQyxDQUFBO0FBQzlCLGFBQUs7T0FDTDtBQUFBLEFBQ0QsVUFBSyxLQUFLO0FBQ1QsVUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDbEIsYUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ3hCLFNBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRTtvQkFBUyxrQkFsT3hCLElBQUksRUFrT3lCLElBQUksQ0FBQyw2QkFBd0Isa0JBbE8xRCxJQUFJLEVBa08yRCxHQUFHLENBQUM7UUFBRSxDQUFDLENBQUE7QUFDekUsUUFBQyxDQUFDLE9BQU8sUUFoT2QsZ0JBQWdCLENBZ09nQixDQUFDLENBQUE7T0FDNUIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFDdkIsQ0FBQyxDQUFDLE9BQU8sUUFsT0ksZUFBZSxDQWtPRixDQUFDLENBQUEsS0FFM0IsQ0FBQyxDQUFDLE9BQU8sUUFuT29CLE9BQU8sQ0FtT2xCLENBQUMsQ0FBQTtBQUNwQixZQUFLO0FBQUEsQUFDTixVQUFLLEtBQUs7QUFDVCxVQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNoQixRQUFDLENBQUMsT0FBTyxRQXhPdUMsU0FBUyxDQXdPckMsQ0FBQyxDQUFBO0FBQ3JCLFNBQUUsV0FyT1AsUUFBUSxDQXFPUyxDQUFBO0FBQ1osYUFBSztPQUNMLE1BQU07QUFDTixRQUFDLENBQUMsT0FBTyxRQTNPZCxPQUFPLENBMk9nQixDQUFDLENBQUE7QUFDbkIsYUFBSztPQUNMO0FBQ0QsWUFBSztBQUFBLEFBQ04sVUFBSyxHQUFHO0FBQ1AsT0FBQyxDQUFDLE9BQU8sUUFqUGdDLE1BQU0sQ0FpUDlCLENBQUMsQ0FBQTs7QUFFbEIsUUFBRSxXQS9PTixRQUFRLENBK09RLENBQUE7QUFDWixZQUFLO0FBQUEsQUFDTixVQUFLLFVBQVU7QUFDZCxPQUFDLENBQUMsT0FBTyxRQXRQc0IsUUFBUSxDQXNQcEIsQ0FBQyxDQUFBO0FBQ3BCLFlBQUs7QUFBQSxBQUNOLFVBQUssSUFBSTtBQUNSLFVBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBLEFBQUMsRUFDbEMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7bUJBQVMsa0JBN1BuQixJQUFJLEVBNlBvQixHQUFHLENBQUM7T0FBcUMsQ0FBQyxDQUFBO0FBQ3RFLG9CQUFjLEVBQUUsQ0FBQTtBQUNoQixZQUFLO0FBQUEsQUFDTixVQUFLLE9BQU87QUFBRTtBQUNiLFNBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLDRDQUE0QyxDQUFDLENBQUE7QUFDdkUsU0FBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxLQUFLLEVBQUUsR0FBRyxFQUFFLHNCQUFzQixDQUFDLENBQUE7OztBQUd2RCxtQkFBWSxFQUFFLENBQUE7QUFDZCxhQUFNLFNBQVMsR0FBRyxNQUFNLENBQUE7QUFDeEIsYUFBTSxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUM3QixTQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLEtBQUssRUFBRSxHQUFHLEVBQUUsd0JBQXdCLENBQUMsQ0FBQTtBQUN6RCxXQUFJLE1BQU0sSUFBSSxTQUFTLEVBQUU7QUFDeEIsYUFBSyxJQUFJLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFDNUMsRUFBRSxXQXBRa0MsYUFBYSxDQW9RaEMsQ0FBQTtBQUNsQixVQUFFLFdBdFFxRSxPQUFPLENBc1FuRSxDQUFBO1FBQ1gsTUFBTTtBQUNOLFVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLFNBQVMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLGlDQUFpQyxDQUFDLENBQUE7QUFDMUUsVUFBRSxXQXpReUMsWUFBWSxDQXlRdkMsQ0FBQTtRQUNoQjtBQUNELGFBQUs7T0FDTDtBQUFBLEFBQ0QsVUFBSyxLQUFLO0FBQ1QsY0FBUSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQ2hCLFlBQUs7QUFBQSxBQUNOLFVBQUssU0FBUyxDQUFDLEFBQUMsS0FBSyxTQUFTLENBQUMsQUFBQyxLQUFLLFFBQVEsQ0FBQyxBQUFDLEtBQUssS0FBSyxDQUFDO0FBQzFELFVBQUssS0FBSyxDQUFDLEFBQUMsS0FBSyxPQUFPLENBQUMsQUFBQyxLQUFLLFNBQVM7QUFDdkMsUUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLDBCQUF3QixVQWhSL0IsUUFBUSxFQWdSZ0MsRUFBRSxDQUFDLENBQUcsQ0FBQTtBQUFBLEFBQ25ELFVBQUssR0FBRztBQUNQLFFBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQTtBQUFBLEFBQ2pELFVBQUssTUFBTTtBQUNWLFVBQUksVUFwUlUsT0FBTyxFQW9SVCxJQUFJLEVBQUUsQ0FBQyxFQUFFO0FBQ3BCLFFBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFBO0FBQ2QsYUFBSztPQUNMO0FBQUE7QUFFRjtBQUFTOztBQUVSLGFBQU0sSUFBSSxHQUFHLGlCQUFpQixPQTNSUCxlQUFlLENBMlJTLENBQUE7QUFDL0MsYUFBTSxDQUFDLEdBQUcsV0FsU21ELGdCQUFnQixFQWtTbEQsSUFBSSxDQUFDLENBQUE7QUFDaEMsV0FBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ3BCLFlBQUksQ0FBQyxZQWxTYSxTQUFTLEFBa1NSLEVBQ2xCLGNBQWMsRUFBRSxDQUFBO0FBQ2pCLFNBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUNiLE1BQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQzVCLENBQUMsQ0FBQyxXQXhTQyxXQUFXLEVBd1NBLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUEsS0FDdkI7QUFDSixVQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsY0EzU1AsY0FBYyxFQTJTUSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUU7bUNBQXVCLGtCQTVTekQsSUFBSSxFQTRTMEQsSUFBSSxDQUFDO1NBQUUsQ0FBQyxDQUFBO0FBQ3pFLFNBQUMsQ0FBQyxXQTNTb0QsSUFBSSxFQTJTbkQsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQTtRQUNwQjtPQUNEO0FBQUEsS0FDRDtJQUNEO0dBQ0QsQ0FBQTs7QUFFRCxRQUFNLFFBQVEsR0FBRyxVQUFBLE1BQU0sRUFBSTtBQUMxQixTQUFNLFdBQVcsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFBOztBQUU5QixTQUFNLFVBQVUsR0FBRyxhQUFhLEVBQUUsQ0FBQTtBQUNsQyxPQUFJLFVBQVUsRUFBRTtBQUNmLFVBQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUN6QyxNQUFFLENBQUMsS0FBSyxDQUFDLFlBQVksS0FBSyxXQUFXLEVBQUUsR0FBRyxFQUN6QyxzRUFBc0UsQ0FBQyxDQUFBO0lBQ3hFOztBQUVELE9BQUksSUFBSSxHQUFHLEVBQUUsQ0FBQTs7QUFFYixTQUFNLFNBQVMsR0FBRyxZQUFNO0FBQ3ZCLFFBQUksSUFBSSxLQUFLLEVBQUUsRUFBRTtBQUNoQixNQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDUCxTQUFJLEdBQUcsRUFBRSxDQUFBO0tBQ1Q7SUFDRCxDQUFBOztBQUVELElBQUMsQ0FBQyxnQkFBUyxHQUFHLEVBQUUsWUFqVTZDLFlBQVksQ0FpVTFDLENBQUMsQ0FBQTs7QUFFaEMsV0FBUSxFQUFFLE9BQU8sSUFBSSxFQUFFO0FBQ3RCLFVBQU0sS0FBSyxHQUFHLEdBQUcsRUFBRSxDQUFBO0FBQ25CLFVBQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFBO0FBQ2hCLFlBQVEsRUFBRTtBQUNULFVBQUssU0FBUztBQUFFO0FBQ2YsV0FBSSxHQUFHLElBQUksR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtBQUNoQyxhQUFLO09BQ0w7QUFBQSxBQUNELFVBQUssT0FBTztBQUFFO0FBQ2IsZ0JBQVMsRUFBRSxDQUFBOztBQUVYLFFBQUMsQ0FBQyxnQkFBUyxrQkFyVjJCLGFBQWEsRUFxVjFCLEtBQUssQ0FBQyxZQTlVakIsWUFBWSxDQThVb0IsQ0FBQyxDQUFBO0FBQy9DLGdCQUFTLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDZixRQUFDLENBQUMsZ0JBQVMsR0FBRyxFQUFFLFlBL1VWLGFBQWEsQ0ErVWEsQ0FBQyxDQUFBO0FBQ2pDLGFBQUs7T0FDTDtBQUFBLEFBQ0QsVUFBSyxPQUFPO0FBQUU7QUFDYixTQUFFLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLEVBQUUsS0FBSyxFQUFFLHNCQUFzQixDQUFDLENBQUE7QUFDdkQsU0FBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUE7O0FBRTlDLGFBQU0sV0FBVyxHQUFHLFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQTtBQUN0QyxhQUFNLFNBQVMsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDdEMsV0FBSSxTQUFTLEdBQUcsV0FBVyxFQUFFOzs7QUFHNUIsb0JBQVksQ0FBQyxLQUFLLEVBQUUsV0FBVyxHQUFHLFNBQVMsQ0FBQyxDQUFBO0FBQzVDLGtCQTlWRyxNQUFNLEVBOFZGLElBQUksRUFBRSxLQUFLLE9BQU8sQ0FBQyxDQUFBO0FBQzFCLGNBQU0sUUFBUSxDQUFBO1FBQ2QsTUFDQSxJQUFJLEdBQUcsSUFBSSxHQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLENBQUE7QUFDakUsYUFBSztPQUNMO0FBQUEsQUFDRCxVQUFLLEtBQUs7QUFDVCxVQUFJLENBQUMsVUFBVSxFQUNkLE1BQU0sUUFBUSxDQUFBO0FBQUE7QUFFaEI7QUFDQyxVQUFJLEdBQUcsSUFBSSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUE7QUFBQSxLQUN0QztJQUNEOztBQUVELFlBQVMsRUFBRSxDQUFBO0FBQ1gsSUFBQyxDQUFDLGdCQUFTLEdBQUcsRUFBRSxZQTdXd0MsYUFBYSxDQTZXckMsQ0FBQyxDQUFBO0dBQ2pDLENBQUE7O0FBRUQsUUFBTSxXQUFXLEdBQUcsVUFBQSxFQUFFLEVBQUk7QUFDekIsV0FBUSxFQUFFO0FBQ1QsU0FBSyxPQUFPO0FBQUUsWUFBTyxHQUFHLENBQUE7QUFBQSxBQUN4QixTQUFLLE9BQU87QUFBRSxZQUFPLElBQUksQ0FBQTtBQUFBLEFBQ3pCLFNBQUssT0FBTztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDekIsU0FBSyxLQUFLO0FBQUUsWUFBTyxHQUFHLENBQUE7QUFBQSxBQUN0QixTQUFLLFNBQVM7QUFBRSxZQUFPLElBQUksQ0FBQTtBQUFBLEFBQzNCO0FBQVMsT0FBRSxDQUFDLElBQUksQ0FBQyxHQUFHLHlCQUF1QixVQXRYckMsUUFBUSxFQXNYc0MsRUFBRSxDQUFDLENBQUcsQ0FBQTtBQUFBLElBQzFEO0dBQ0QsQ0FBQTs7QUFFRCxXQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDaEIsU0FBTyxHQUFHLENBQUE7RUFDViIsImZpbGUiOiJtZXRhL2NvbXBpbGUvcHJpdmF0ZS9sZXgvdW5ncm91cGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvYywgeyBQb3MsIFN0YXJ0TGluZSwgU3RhcnRDb2x1bW4sIHNpbmdsZUNoYXJMb2MgfSBmcm9tICdlc2FzdC9kaXN0L0xvYydcbmltcG9ydCB7IGNvZGUgfSBmcm9tICcuLi8uLi9Db21waWxlRXJyb3InXG5pbXBvcnQgeyBpc1Jlc2VydmVkTmFtZSB9IGZyb20gJy4uL2xhbmd1YWdlJ1xuaW1wb3J0IHsgQ2FsbE9uRm9jdXMsIERvdE5hbWUsIEtleXdvcmQsIFRva2VuTnVtYmVyTGl0ZXJhbCwgTmFtZSwga2V5d29yZEtGcm9tTmFtZSxcblx0S1dfQXNzaWduTXV0YWJsZSwgS1dfQXNzaWduTXV0YXRlLCBLV19Gb2N1cywgS1dfRnVuLCBLV19HZW5GdW4sXG5cdEtXX0xhenksIEtXX09iakFzc2lnbiwgS1dfUmVnaW9uLCBLV19UeXBlIH0gZnJvbSAnLi4vVG9rZW4nXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IEdyb3VwUHJlLCB7IEdQX09wZW5QYXJlbiwgR1BfT3BlbkJyYWNrZXQsIEdQX09wZW5CbG9jaywgR1BfT3BlblF1b3RlLCBHUF9MaW5lLFxuXHRHUF9TcGFjZSwgR1BfQ2xvc2VQYXJlbiwgR1BfQ2xvc2VCcmFja2V0LCBHUF9DbG9zZUJsb2NrLCBHUF9DbG9zZVF1b3RlfSBmcm9tICcuL0dyb3VwUHJlJ1xuaW1wb3J0IHsgc2hvd0NoYXIsIGlzRGlnaXQsIGlzTmFtZUNoYXJhY3RlciwgaXNOdW1iZXJDaGFyYWN0ZXIgfSBmcm9tICcuL2NoYXInXG5cbmNvbnN0IGNjID0gY2ggPT4gY2guY2hhckNvZGVBdCgwKVxuY29uc3Rcblx0TjAgPSBjYygnMCcpLCBOMSA9IGNjKCcxJyksIE4yID0gY2MoJzInKSwgTjMgPSBjYygnMycpLCBONCA9IGNjKCc0JyksXG5cdE41ID0gY2MoJzUnKSwgTjYgPSBjYygnNicpLCBONyA9IGNjKCc3JyksIE44ID0gY2MoJzgnKSwgTjkgPSBjYygnOScpLFxuXHRPcFBhcmVuID0gY2MoJygnKSwgT3BCcmFja2V0ID0gY2MoJ1snKSwgT3BCcmFjZSA9IGNjKCd7JyksXG5cdENsUGFyZW4gPSBjYygnKScpLCBDbEJyYWNrZXQgPSBjYygnXScpLCBDbEJyYWNlID0gY2MoJ30nKSxcblx0QW1wZXJzYW5kID0gY2MoJyYnKSxcblx0QmFja3NsYXNoID0gY2MoJ1xcXFwnKSxcblx0QmFja3RpY2sgPSBjYygnYCcpLFxuXHRCYXIgPSBjYygnfCcpLFxuXHRDYXJldCA9IGNjKCdeJyksXG5cdENvbG9uID0gY2MoJzonKSxcblx0Q29tbWEgPSBjYygnLCcpLFxuXHREb3QgPSBjYygnLicpLFxuXHRFcXVhbCA9IGNjKCc9JyksXG5cdEhhc2ggPSBjYygnIycpLFxuXHRIeXBoZW4gPSBjYygnLScpLFxuXHRMZXR0ZXJOID0gY2MoJ24nKSxcblx0TGV0dGVyVCA9IGNjKCd0JyksXG5cdE5ld2xpbmUgPSBjYygnXFxuJyksXG5cdFBlcmNlbnQgPSBjYygnJScpLFxuXHRRdW90ZSA9IGNjKCdcIicpLFxuXHRTZW1pY29sb24gPSBjYygnOycpLFxuXHRTcGFjZSA9IGNjKCcgJyksXG5cdFRhYiA9IGNjKCdcXHQnKSxcblx0VGlsZGUgPSBjYygnficpLFxuXHRVbmRlcnNjb3JlID0gY2MoJ18nKSxcblx0WmVybyA9IGNjKCdcXDAnKVxuXG5leHBvcnQgZGVmYXVsdCAoY3gsIHN0cikgPT4ge1xuXHQvLyBMZXhpbmcgYWxnb3JpdGhtIHJlcXVpcmVzIHRyYWlsaW5nIG5ld2xpbmUuXG5cdC8vIFVzZSBhIG51bGwtdGVybWluYXRlZCBzdHJpbmcgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGNoZWNraW5nIHdoZXRoZXIgaW5kZXggPT09IGxlbmd0aC5cblx0c3RyID0gc3RyICsgJ1xcblxcMCdcblxuXHRjb25zdCByZXMgPSBbIF1cblx0bGV0IGxpbmUgPSBTdGFydExpbmVcblx0bGV0IGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdGxldCBpbmRleCA9IDBcblxuXHQvLyBVc2UgdGhlc2UgZm9yIGRlYnVnZ2luZyBwb3MuXG5cdC8qXG5cdGNvbnN0XG5cdFx0Y2hlY2tQb3MgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBwID0gZ2V0Q29ycmVjdFBvcygpXG5cdFx0XHRpZiAocC5saW5lICE9PSBsaW5lIHx8IHAuY29sdW1uICE9PSBjb2x1bW4pXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgaW5kZXg6ICR7aW5kZXh9LCB3cm9uZzogJHtQb3MobGluZSwgY29sdW1uKX0sIHJpZ2h0OiAke3B9YClcblx0XHR9LFxuXHRcdGluZGV4VG9Qb3MgPSBuZXcgTWFwKCksXG5cdFx0Z2V0Q29ycmVjdFBvcyA9ICgpID0+IHtcblx0XHRcdGlmIChpbmRleCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFBvcyhTdGFydExpbmUsIFN0YXJ0Q29sdW1uKVxuXG5cdFx0XHRsZXQgb2xkUG9zLCBvbGRJbmRleFxuXHRcdFx0Zm9yIChvbGRJbmRleCA9IGluZGV4IC0gMTsgb2xkSW5kZXggPiAwOyBvbGRJbmRleCA9IG9sZEluZGV4IC0gMSkge1xuXHRcdFx0XHRvbGRQb3MgPSBpbmRleFRvUG9zLmdldChvbGRJbmRleClcblx0XHRcdFx0aWYgKG9sZFBvcylcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZFBvcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGFzc2VydChvbGRJbmRleCA9PT0gMClcblx0XHRcdFx0b2xkUG9zID0gUG9zKFN0YXJ0TGluZSwgU3RhcnRDb2x1bW4pXG5cdFx0XHR9XG5cdFx0XHRsZXQgbmV3TGluZSA9IG9sZFBvcy5saW5lLCBuZXdDb2x1bW4gPSBvbGRQb3MuY29sdW1uXG5cdFx0XHRmb3IgKDsgb2xkSW5kZXggPCBpbmRleDsgb2xkSW5kZXggPSBvbGRJbmRleCArIDEpXG5cdFx0XHRcdGlmIChzdHIuY2hhckNvZGVBdChvbGRJbmRleCkgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0XHRuZXdMaW5lID0gbmV3TGluZSArIDFcblx0XHRcdFx0XHRuZXdDb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRuZXdDb2x1bW4gPSBuZXdDb2x1bW4gKyAxXG5cblx0XHRcdGNvbnN0IHAgPSBQb3MobmV3TGluZSwgbmV3Q29sdW1uKVxuXHRcdFx0aW5kZXhUb1Bvcy5zZXQoaW5kZXgsIHApXG5cdFx0XHRyZXR1cm4gcFxuXHRcdH1cblx0Ki9cblxuXHRjb25zdFxuXHRcdG8gPSB0ID0+IHsgcmVzLnB1c2godCkgfSxcblxuXHRcdHBvcyA9ICgpID0+IFBvcyhsaW5lLCBjb2x1bW4pLFxuXHRcdGxvYyA9ICgpID0+IHNpbmdsZUNoYXJMb2MocG9zKCkpLFxuXG5cdFx0cHJldiA9ICgpID0+IHN0ci5jaGFyQ29kZUF0KGluZGV4IC0gMSksXG5cdFx0cGVlayA9ICgpID0+IHN0ci5jaGFyQ29kZUF0KGluZGV4KSxcblxuXHRcdGVhdCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGNoID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpXG5cdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0Y29sdW1uID0gY29sdW1uICsgMVxuXHRcdFx0cmV0dXJuIGNoXG5cdFx0fSxcblx0XHR0cnlFYXQgPSBjaCA9PiB7XG5cdFx0XHRjb25zdCBjYW5FYXQgPSBwZWVrKCkgPT09IGNoXG5cdFx0XHRpZiAoY2FuRWF0KSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIDFcblx0XHRcdH1cblx0XHRcdHJldHVybiBjYW5FYXRcblx0XHR9LFxuXHRcdHRyeUVhdE5ld2xpbmUgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBjYW5FYXQgPSBwZWVrKCkgPT09IE5ld2xpbmVcblx0XHRcdGlmIChjYW5FYXQpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHRcdGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FuRWF0XG5cdFx0fSxcblxuXHRcdC8vIENhbGxlciBtdXN0IGVuc3VyZSB0aGF0IGJhY2tpbmcgdXAgbkNoYXJzVG9CYWNrVXAgY2hhcmFjdGVycyBicmluZ3MgdXMgdG8gb2xkUG9zLlxuXHRcdHN0ZXBCYWNrTWFueSA9IChvbGRQb3MsIG5DaGFyc1RvQmFja1VwKSA9PiB7XG5cdFx0XHRpbmRleCA9IGluZGV4IC0gbkNoYXJzVG9CYWNrVXBcblx0XHRcdGxpbmUgPSBvbGRQb3MubGluZVxuXHRcdFx0Y29sdW1uID0gb2xkUG9zLmNvbHVtblxuXHRcdH0sXG5cblx0XHRfc2tpcFdoaWxlID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdHdoaWxlIChwcmVkKHBlZWsoKSkpXG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRjb25zdCBkaWZmID0gaW5kZXggLSBzdGFydEluZGV4XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyBkaWZmXG5cdFx0XHRyZXR1cm4gZGlmZlxuXHRcdH0sXG5cdFx0dGFrZVdoaWxlV2l0aFByZXYgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0X3NraXBXaGlsZShwcmVkKVxuXHRcdFx0cmV0dXJuIHN0ci5zbGljZShzdGFydEluZGV4IC0gMSwgaW5kZXgpXG5cdFx0fSxcblx0XHR0YWtlV2hpbGUgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0X3NraXBXaGlsZShwcmVkKVxuXHRcdFx0cmV0dXJuIHN0ci5zbGljZShzdGFydEluZGV4LCBpbmRleClcblx0XHR9LFxuXHRcdHNraXBXaGlsZUVxdWFscyA9IGNoID0+IF9za2lwV2hpbGUoXyA9PiBfID09PSBjaCksXG5cblx0XHQvLyBDYWxsZWQgYWZ0ZXIgc2VlaW5nIHRoZSBmaXJzdCBuZXdsaW5lLlxuXHRcdHNraXBOZXdsaW5lcyA9ICgpID0+IHtcblx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0Y29uc3Qgc3RhcnRMaW5lID0gbGluZVxuXHRcdFx0d2hpbGUgKHBlZWsoKSA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdH1cblx0XHRcdGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHRyZXR1cm4gbGluZSAtIHN0YXJ0TGluZVxuXHRcdH0sXG5cblx0XHRza2lwUmVzdE9mTGluZSA9ICgpID0+XG5cdFx0XHRfc2tpcFdoaWxlKF8gPT4gXyAhPT0gTmV3bGluZSlcblxuXHRjb25zdCB1bmdyb3VwZWQgPSBpc0luUXVvdGUgPT4ge1xuXHRcdGxldCBpbmRlbnQgPSAwXG5cblx0XHRsZXQgY2gsIHN0YXJ0Q29sdW1uXG5cdFx0Y29uc3Rcblx0XHRcdGxvYyA9ICgpID0+IExvYyhQb3MobGluZSwgc3RhcnRDb2x1bW4pLCBwb3MoKSksXG5cdFx0XHRrZXl3b3JkID0gayA9PiBLZXl3b3JkKGxvYygpLCBrKSxcblx0XHRcdGdwID0gayA9PiBvKEdyb3VwUHJlKGxvYygpLCBrKSksXG5cdFx0XHRlYXROdW1iZXIgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpdCA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTnVtYmVyQ2hhcmFjdGVyKVxuXHRcdFx0XHRjb25zdCBudW0gPSBOdW1iZXIobGl0KVxuXHRcdFx0XHRjeC5jaGVjayghTnVtYmVyLmlzTmFOKG51bSksIHBvcywgKCkgPT5cblx0XHRcdFx0XHRgSW52YWxpZCBudW1iZXIgbGl0ZXJhbCAke2NvZGUobGl0KX1gKVxuXHRcdFx0XHRyZXR1cm4gVG9rZW5OdW1iZXJMaXRlcmFsKGxvYygpLCBudW0pXG5cdFx0XHR9XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0c3RhcnRDb2x1bW4gPSBjb2x1bW5cblx0XHRcdGNoID0gZWF0KClcblx0XHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdFx0Y2FzZSBaZXJvOlxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRjYXNlIE4wOiBjYXNlIE4xOiBjYXNlIE4yOiBjYXNlIE4zOiBjYXNlIE40OlxuXHRcdFx0XHRjYXNlIE41OiBjYXNlIE42OiBjYXNlIE43OiBjYXNlIE44OiBjYXNlIE45OlxuXHRcdFx0XHRcdG8oZWF0TnVtYmVyKCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBPcFBhcmVuOlxuXHRcdFx0XHRcdGdwKEdQX09wZW5QYXJlbilcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE9wQnJhY2tldDpcblx0XHRcdFx0XHRncChHUF9PcGVuQnJhY2tldClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsUGFyZW46XG5cdFx0XHRcdFx0Z3AoR1BfQ2xvc2VQYXJlbilcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsQnJhY2tldDpcblx0XHRcdFx0XHRncChHUF9DbG9zZUJyYWNrZXQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbEJyYWNlOlxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5RdW90ZSwgbG9jLCAoKSA9PiBgUmVzZXJ2ZWQgY2hhcmFjdGVyICR7c2hvd0NoYXIoY2gpfWApXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGNhc2UgU3BhY2U6XG5cdFx0XHRcdFx0Y3gud2FybklmKHBlZWsoKSA9PT0gU3BhY2UsIGxvYywgJ011bHRpcGxlIHNwYWNlcyBpbiBhIHJvdycpXG5cdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBEb3Q6IHtcblx0XHRcdFx0XHRjb25zdCBwID0gcGVlaygpXG5cdFx0XHRcdFx0aWYgKHAgPT09IFNwYWNlIHx8IHAgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0XHRcdC8vIE9iakxpdCBhc3NpZ24gaW4gaXRzIG93biBzcGFjZWQgZ3JvdXAuXG5cdFx0XHRcdFx0XHQvLyBXZSBjYW4ndCBqdXN0IGNyZWF0ZSBhIG5ldyBHcm91cCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0b1xuXHRcdFx0XHRcdFx0Ly8gZW5zdXJlIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHByZWNlZGluZyBvciBmb2xsb3dpbmcgc3BhY2VkIGdyb3VwLlxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoS1dfT2JqQXNzaWduKSlcblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0byhEb3ROYW1lKFxuXHRcdFx0XHRcdFx0XHRsb2MoKSxcblx0XHRcdFx0XHRcdFx0Ly8gKzEgZm9yIHRoZSBkb3Qgd2UganVzdCBza2lwcGVkLlxuXHRcdFx0XHRcdFx0XHRza2lwV2hpbGVFcXVhbHMoRG90KSArIDEsXG5cdFx0XHRcdFx0XHRcdHRha2VXaGlsZShpc05hbWVDaGFyYWN0ZXIpKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgQ29sb246XG5cdFx0XHRcdFx0aWYgKHRyeUVhdChDb2xvbikpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGVxID0gdHJ5RWF0KEVxdWFsKVxuXHRcdFx0XHRcdFx0Y3guY2hlY2soZXEsIGxvYywgKCkgPT4gYCR7Y29kZSgnOjonKX0gbXVzdCBiZSBmb2xsb3dlZCBieSAke2NvZGUoJz0nKX1gKVxuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX0Fzc2lnbk11dGFibGUpKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHJ5RWF0KEVxdWFsKSlcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19Bc3NpZ25NdXRhdGUpKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19UeXBlKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFRpbGRlOlxuXHRcdFx0XHRcdGlmICh0cnlFYXQoQmFyKSkge1xuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX0dlbkZ1bikpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19MYXp5KSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQmFyOlxuXHRcdFx0XHRcdG8oa2V5d29yZChLV19GdW4pKVxuXHRcdFx0XHRcdC8vIEZpcnN0IGFyZyBpbiBpdHMgb3duIHNwYWNlZCBncm91cFxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgVW5kZXJzY29yZTpcblx0XHRcdFx0XHRvKGtleXdvcmQoS1dfRm9jdXMpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgSGFzaDpcblx0XHRcdFx0XHRpZiAoISh0cnlFYXQoU3BhY2UpIHx8IHRyeUVhdChUYWIpKSlcblx0XHRcdFx0XHRcdGN4LmZhaWwobG9jLCAoKSA9PiBgJHtjb2RlKCcjJyl9IG11c3QgYmUgZm9sbG93ZWQgYnkgc3BhY2Ugb3IgdGFiLn1gKVxuXHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayghaXNJblF1b3RlLCBsb2MsICdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYoKSAhPT0gU3BhY2UsIGxvYywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblxuXHRcdFx0XHRcdC8vIFNraXAgYW55IGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdHNraXBOZXdsaW5lcygpXG5cdFx0XHRcdFx0Y29uc3Qgb2xkSW5kZW50ID0gaW5kZW50XG5cdFx0XHRcdFx0aW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRjeC5jaGVjayhwZWVrKCkgIT09IFNwYWNlLCBwb3MsICdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRpZiAoaW5kZW50IDw9IG9sZEluZGVudCkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGluZGVudDsgaSA8IG9sZEluZGVudDsgaSA9IGkgKyAxKVxuXHRcdFx0XHRcdFx0XHRncChHUF9DbG9zZUJsb2NrKVxuXHRcdFx0XHRcdFx0Z3AoR1BfTGluZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soaW5kZW50ID09PSBvbGRJbmRlbnQgKyAxLCBsb2MsICdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlJylcblx0XHRcdFx0XHRcdGdwKEdQX09wZW5CbG9jaylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGxleFF1b3RlKGluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEFtcGVyc2FuZDogY2FzZSBCYWNrc2xhc2g6IGNhc2UgQmFja3RpY2s6IGNhc2UgQ2FyZXQ6XG5cdFx0XHRcdGNhc2UgQ29tbWE6IGNhc2UgUGVyY2VudDogY2FzZSBTZW1pY29sb246XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MsIGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0Y2FzZSBUYWI6XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MoKSwgJ1RhYiBtYXkgb25seSBiZSB1c2VkIHRvIGluZGVudCcpXG5cdFx0XHRcdGNhc2UgSHlwaGVuOlxuXHRcdFx0XHRcdGlmIChpc0RpZ2l0KHBlZWsoKSkpIHtcblx0XHRcdFx0XHRcdG8oZWF0TnVtYmVyKCkpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbHNlIGZhbGx0aHJvdWdoXG5cdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHQvLyBBbGwgb3RoZXIgY2hhcmFjdGVycyBzaG91bGQgYmUgaGFuZGxlZCBpbiBhIGNhc2UgYWJvdmUuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTmFtZUNoYXJhY3Rlcilcblx0XHRcdFx0XHRjb25zdCBrID0ga2V5d29yZEtGcm9tTmFtZShuYW1lKVxuXHRcdFx0XHRcdGlmIChrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSBLV19SZWdpb24pXG5cdFx0XHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRcdG8oa2V5d29yZChrKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRyeUVhdChVbmRlcnNjb3JlKSlcblx0XHRcdFx0XHRcdG8oQ2FsbE9uRm9jdXMobG9jKCksIG5hbWUpKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soIWlzUmVzZXJ2ZWROYW1lKG5hbWUpLCBwb3MsICgpID0+IGBSZXNlcnZlZCBuYW1lICR7Y29kZShuYW1lKX1gKVxuXHRcdFx0XHRcdFx0byhOYW1lKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBsZXhRdW90ZSA9IGluZGVudCA9PiB7XG5cdFx0Y29uc3QgcXVvdGVJbmRlbnQgPSBpbmRlbnQgKyAxXG5cblx0XHRjb25zdCBpc0luZGVudGVkID0gdHJ5RWF0TmV3bGluZSgpXG5cdFx0aWYgKGlzSW5kZW50ZWQpIHtcblx0XHRcdGNvbnN0IGFjdHVhbEluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRjeC5jaGVjayhhY3R1YWxJbmRlbnQgPT09IHF1b3RlSW5kZW50LCBwb3MsXG5cdFx0XHRcdCdJbmRlbnRlZCBxdW90ZSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbW9yZSBpbmRlbnQgdGhhbiBwcmV2aW91cyBsaW5lLicpXG5cdFx0fVxuXG5cdFx0bGV0IHJlYWQgPSAnJ1xuXG5cdFx0Y29uc3QgeWllbGRSZWFkID0gKCkgPT4ge1xuXHRcdFx0aWYgKHJlYWQgIT09ICcnKSB7XG5cdFx0XHRcdG8ocmVhZClcblx0XHRcdFx0cmVhZCA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfT3BlblF1b3RlKSlcblxuXHRcdGVhdENoYXJzOiB3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hQb3MgPSBwb3MoKVxuXHRcdFx0Y29uc3QgY2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIEJhY2tzbGFzaDoge1xuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgcXVvdGVFc2NhcGUoZWF0KCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE9wQnJhY2U6IHtcblx0XHRcdFx0XHR5aWVsZFJlYWQoKVxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IGNyZWF0ZSBhIEdyb3VwIG5vdyBiZWNhdXNlIHRoZXJlIG1heSBiZSBvdGhlciBHcm91cFByZV9zIGluc2lkZS5cblx0XHRcdFx0XHRvKEdyb3VwUHJlKHNpbmdsZUNoYXJMb2MoY2hQb3MpLCBHUF9PcGVuUGFyZW4pKVxuXHRcdFx0XHRcdHVuZ3JvdXBlZCh0cnVlKVxuXHRcdFx0XHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUGFyZW4pKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2socHJldiAhPT0gU3BhY2UsIGNoUG9zLCAnTGluZSBlbmRzIGluIGEgc3BhY2UnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5kZW50ZWQsIGNoUG9zLCAnVW5jbG9zZWQgcXVvdGUuJylcblx0XHRcdFx0XHQvLyBBbGxvdyBleHRyYSBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRjb25zdCBudW1OZXdsaW5lcyA9IHNraXBOZXdsaW5lcygpICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0luZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRcdFx0aWYgKG5ld0luZGVudCA8IHF1b3RlSW5kZW50KSB7XG5cdFx0XHRcdFx0XHQvLyBJbmRlbnRlZCBxdW90ZSBzZWN0aW9uIGlzIG92ZXIuXG5cdFx0XHRcdFx0XHQvLyBVbmRvIHJlYWRpbmcgdGhlIHRhYnMgYW5kIG5ld2xpbmUuXG5cdFx0XHRcdFx0XHRzdGVwQmFja01hbnkoY2hQb3MsIG51bU5ld2xpbmVzICsgbmV3SW5kZW50KVxuXHRcdFx0XHRcdFx0YXNzZXJ0KHBlZWsoKSA9PT0gTmV3bGluZSlcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRyZWFkID0gcmVhZCArXG5cdFx0XHRcdFx0XHRcdCdcXG4nLnJlcGVhdChudW1OZXdsaW5lcykgKyAnXFx0Jy5yZXBlYXQobmV3SW5kZW50IC0gcXVvdGVJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGlmICghaXNJbmRlbnRlZClcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR5aWVsZFJlYWQoKVxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUXVvdGUpKVxuXHR9XG5cblx0Y29uc3QgcXVvdGVFc2NhcGUgPSBjaCA9PiB7XG5cdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0Y2FzZSBPcEJyYWNlOiByZXR1cm4gJ3snXG5cdFx0XHRjYXNlIExldHRlck46IHJldHVybiAnXFxuJ1xuXHRcdFx0Y2FzZSBMZXR0ZXJUOiByZXR1cm4gJ1xcdCdcblx0XHRcdGNhc2UgUXVvdGU6IHJldHVybiAnXCInXG5cdFx0XHRjYXNlIEJhY2tzbGFzaDogcmV0dXJuICdcXFxcJ1xuXHRcdFx0ZGVmYXVsdDogY3guZmFpbChwb3MsIGBObyBuZWVkIHRvIGVzY2FwZSAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdH1cblx0fVxuXG5cdHVuZ3JvdXBlZChmYWxzZSlcblx0cmV0dXJuIHJlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=