if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../Lang', '../Token', '../U/util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _Lang, _Token, _UUtil, _GroupPre, _char) {
	'use strict';

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	module.exports = function (cx, str) {
		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return _esastDistLoc.Pos(line, column);
		},
		      loc = function () {
			return _esastDistLoc.singleCharLoc(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === _char.Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === _char.Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			while (peek() !== _char.Newline) index = index + 1;
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startLine, startColumn;
			const loc = function () {
				return _Loc(_esastDistLoc.Pos(startLine, startColumn), pos());
			},
			      keyword = function (k) {
				return _Token.Keyword(loc(), k);
			},
			      gp = function (k) {
				return o(_GroupPre2(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + _CompileError.code(lit);
				});
				return _Token.TokenNumberLiteral(loc(), num);
			};

			while (index !== str.length) {
				startLine = line;
				startColumn = column;

				ch = eat();
				switch (ch) {
					case _char.N0:case _char.N1:case _char.N2:case _char.N3:case _char.N4:
					case _char.N5:case _char.N6:case _char.N7:case _char.N8:case _char.N9:
						o(eatNumber());
						break;
					case _char.OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case _char.OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case _char.ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case _char.ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case _char.ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + _char.showChar(ch);
						});
						return;
					case _char.Space:
						cx.warnIf(peek() === _char.Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case _char.Dot:
						{
							const p = peek();
							if (p === _char.Space || p === _char.Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword('. '));
								gp(_GroupPre.GP_Space);
							} else o(_Token.DotName(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(_char.Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case _char.Colon:
						o(keyword(':'));
						break;
					case _char.Tilde:
						if (tryEat(_char.Bar)) {
							o(keyword('~|'));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword('~'));
							break;
						}
						break;
					case _char.Bar:
						// First arg in its own spaced group
						o(keyword('|'));
						gp(_GroupPre.GP_Space);
						break;
					case _char.Underscore:
						o(keyword('_'));
						break;
					case _char.Hash:
						if (!(tryEat(_char.Space) || tryEat(_char.Tab))) cx.fail(loc, function () {
							return '' + _CompileError.code('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case _char.Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== _char.Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(_char.Tab);
							cx.check(peek() !== _char.Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case _char.Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
						break;
					case _char.Quote:
						lexQuote(indent);
						break;
					case _char.Hyphen:
						if (_char.isDigit(peek())) {
							o(eatNumber());
							break;
						}
					// Else fallthrough
					default:
						{
							cx.check(!_char.isReservedCharacter(ch), loc, function () {
								return 'Reserved character ' + _char.showChar(ch);
							});
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);

							if (_Lang.NonNames.has(name)) if (name === 'region') {
								// Rest of line is a comment.
								skipRestOfLine();
								o(keyword('region'));
							} else if (_Lang.AllKeywords.has(name)) o(keyword(name));else cx.fail(loc, 'Reserved word ' + _CompileError.code(name));else if (tryEat(_char.Underscore)) o(_Token.CallOnFocus(loc(), name));else o(_Token.Name(loc(), name));
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(_char.Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o(_GroupPre2(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case _char.Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case _char.OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o(_GroupPre2(_esastDistLoc.singleCharLoc(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o(_GroupPre2(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case _char.Newline:
						{
							cx.check(prev !== _char.Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							let newIndent = skipWhileEquals(_char.Tab);

							let extraNewlines = '';
							// Allow blank lines.
							if (newIndent === 0) {
								extraNewlines = '\n'.repeat(skipNewlines());
								newIndent = skipWhileEquals(_char.Tab);
							}

							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, newIndent + 1);
								_UUtil.assert(peek() === _char.Newline);
								break eatChars;
							} else read = read + extraNewlines + '\n' + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case _char.Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o(_GroupPre2(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case _char.OpBrace:
					return '{';
				case _char.LetterN:
					return '\n';
				case _char.LetterT:
					return '\t';
				case _char.Quote:
					return '"';
				case _char.Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + _char.showChar(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O2tCQVllLFVBQUMsRUFBRSxFQUFFLEdBQUcsRUFBSztBQUMzQixRQUFNLEdBQUcsR0FBRyxFQUFHLENBQUE7QUFDZixNQUFJLElBQUksaUJBZFUsU0FBUyxBQWNQLENBQUE7QUFDcEIsTUFBSSxNQUFNLGlCQWZtQixXQUFXLEFBZWhCLENBQUE7QUFDeEIsTUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBOztBQUViLFFBQ0MsQ0FBQyxHQUFHLFVBQUEsQ0FBQyxFQUFJO0FBQUUsTUFBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUFFO1FBRXhCLEdBQUcsR0FBRztVQUFNLGNBckJBLEdBQUcsQ0FxQkMsSUFBSSxFQUFFLE1BQU0sQ0FBQztHQUFBO1FBQzdCLEdBQUcsR0FBRztVQUFNLGNBdEI2QixhQUFhLENBc0I1QixHQUFHLEVBQUUsQ0FBQztHQUFBO1FBRWhDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztHQUFBO1FBQ3RDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO0dBQUE7UUFFbEMsR0FBRyxHQUFHLFlBQU07QUFDWCxTQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ2hDLFFBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0FBQ2pCLFNBQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ25CLFVBQU8sRUFBRSxDQUFBO0dBQ1Q7UUFDRCxNQUFNLEdBQUcsVUFBQSxFQUFFLEVBQUk7QUFDZCxTQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDNUIsT0FBSSxNQUFNLEVBQUU7QUFDWCxTQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtBQUNq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LHlCQUF1QixNQXRUckMsUUFBUSxDQXNUc0MsRUFBRSxDQUFDLENBQUcsQ0FBQTtBQUFBLElBQzFEO0dBQ0QsQ0FBQTs7QUFFRCxXQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDaEIsU0FBTyxHQUFHLENBQUE7RUFDViIsImZpbGUiOiJtZXRhL2NvbXBpbGUvcHJpdmF0ZS9sZXgvdW5ncm91cGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvYywgeyBQb3MsIFN0YXJ0TGluZSwgU3RhcnRDb2x1bW4sIHNpbmdsZUNoYXJMb2MgfSBmcm9tICdlc2FzdC9kaXN0L0xvYydcbmltcG9ydCB7IGNvZGUgfSBmcm9tICcuLi8uLi9Db21waWxlRXJyb3InXG5pbXBvcnQgeyBBbGxLZXl3b3JkcywgTm9uTmFtZXMgfSBmcm9tICcuLi9MYW5nJ1xuaW1wb3J0IHsgQ2FsbE9uRm9jdXMsIERvdE5hbWUsIEtleXdvcmQsIFRva2VuTnVtYmVyTGl0ZXJhbCwgTmFtZSB9IGZyb20gJy4uL1Rva2VuJ1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vVS91dGlsJ1xuaW1wb3J0IEdyb3VwUHJlLCB7IEdQX09wZW5QYXJlbiwgR1BfT3BlbkJyYWNrZXQsIEdQX09wZW5CbG9jaywgR1BfT3BlblF1b3RlLCBHUF9MaW5lLFxuXHRHUF9TcGFjZSwgR1BfQ2xvc2VQYXJlbiwgR1BfQ2xvc2VCcmFja2V0LCBHUF9DbG9zZUJsb2NrLCBHUF9DbG9zZVF1b3RlfSBmcm9tICcuL0dyb3VwUHJlJ1xuaW1wb3J0IHsgc2hvd0NoYXIsIE4wLCBOMSwgTjIsIE4zLCBONCwgTjUsIE42LCBONywgTjgsIE45LFxuXHRPcFBhcmVuLCBPcEJyYWNrZXQsIE9wQnJhY2UsIENsUGFyZW4sIENsQnJhY2tldCwgQ2xCcmFjZSwgU3BhY2UsIERvdCwgQ29sb24sIFRpbGRlLCBCYXIsXG5cdFVuZGVyc2NvcmUsIEJhY2tzbGFzaCwgSGFzaCwgTmV3bGluZSwgUXVvdGUsIFRhYiwgSHlwaGVuLCBMZXR0ZXJOLCBMZXR0ZXJULFxuXHRpc0RpZ2l0LCBpc05hbWVDaGFyYWN0ZXIsIGlzTnVtYmVyQ2hhcmFjdGVyLCBpc1Jlc2VydmVkQ2hhcmFjdGVyIH0gZnJvbSAnLi9jaGFyJ1xuXG5leHBvcnQgZGVmYXVsdCAoY3gsIHN0cikgPT4ge1xuXHRjb25zdCByZXMgPSBbIF1cblx0bGV0IGxpbmUgPSBTdGFydExpbmVcblx0bGV0IGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdGxldCBpbmRleCA9IDBcblxuXHRjb25zdFxuXHRcdG8gPSB0ID0+IHsgcmVzLnB1c2godCkgfSxcblxuXHRcdHBvcyA9ICgpID0+IFBvcyhsaW5lLCBjb2x1bW4pLFxuXHRcdGxvYyA9ICgpID0+IHNpbmdsZUNoYXJMb2MocG9zKCkpLFxuXG5cdFx0cHJldiA9ICgpID0+IHN0ci5jaGFyQ29kZUF0KGluZGV4IC0gMSksXG5cdFx0cGVlayA9ICgpID0+IHN0ci5jaGFyQ29kZUF0KGluZGV4KSxcblxuXHRcdGVhdCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGNoID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpXG5cdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0Y29sdW1uID0gY29sdW1uICsgMVxuXHRcdFx0cmV0dXJuIGNoXG5cdFx0fSxcblx0XHR0cnlFYXQgPSBjaCA9PiB7XG5cdFx0XHRjb25zdCBjYW5FYXQgPSBwZWVrKCkgPT09IGNoXG5cdFx0XHRpZiAoY2FuRWF0KSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIDFcblx0XHRcdH1cblx0XHRcdHJldHVybiBjYW5FYXRcblx0XHR9LFxuXHRcdHRyeUVhdE5ld2xpbmUgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBjYW5FYXQgPSBwZWVrKCkgPT09IE5ld2xpbmVcblx0XHRcdGlmIChjYW5FYXQpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHRcdGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FuRWF0XG5cdFx0fSxcblxuXHRcdC8vIENhbGxlciBtdXN0IGVuc3VyZSB0aGF0IGJhY2tpbmcgdXAgbkNoYXJzVG9CYWNrVXAgY2hhcmFjdGVycyBicmluZ3MgdXMgdG8gb2xkUG9zLlxuXHRcdHN0ZXBCYWNrTWFueSA9IChvbGRQb3MsIG5DaGFyc1RvQmFja1VwKSA9PiB7XG5cdFx0XHRpbmRleCA9IGluZGV4IC0gbkNoYXJzVG9CYWNrVXBcblx0XHRcdGxpbmUgPSBvbGRQb3MubGluZVxuXHRcdFx0Y29sdW1uID0gb2xkUG9zLmNvbHVtblxuXHRcdH0sXG5cblx0XHRfc2tpcFdoaWxlID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdHdoaWxlIChwcmVkKHBlZWsoKSkpXG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRjb25zdCBkaWZmID0gaW5kZXggLSBzdGFydEluZGV4XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyBkaWZmXG5cdFx0XHRyZXR1cm4gZGlmZlxuXHRcdH0sXG5cdFx0dGFrZVdoaWxlV2l0aFByZXYgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0X3NraXBXaGlsZShwcmVkKVxuXHRcdFx0cmV0dXJuIHN0ci5zbGljZShzdGFydEluZGV4IC0gMSwgaW5kZXgpXG5cdFx0fSxcblx0XHR0YWtlV2hpbGUgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0X3NraXBXaGlsZShwcmVkKVxuXHRcdFx0cmV0dXJuIHN0ci5zbGljZShzdGFydEluZGV4LCBpbmRleClcblx0XHR9LFxuXHRcdHNraXBXaGlsZUVxdWFscyA9IGNoID0+IF9za2lwV2hpbGUoXyA9PiBfID09PSBjaCksXG5cblx0XHQvLyBDYWxsZWQgYWZ0ZXIgc2VlaW5nIHRoZSBmaXJzdCBuZXdsaW5lLlxuXHRcdHNraXBOZXdsaW5lcyA9ICgpID0+IHtcblx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0Y29uc3Qgc3RhcnRMaW5lID0gbGluZVxuXHRcdFx0d2hpbGUgKHBlZWsoKSA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdH1cblx0XHRcdGNvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHRyZXR1cm4gbGluZSAtIHN0YXJ0TGluZVxuXHRcdH0sXG5cblx0XHRza2lwUmVzdE9mTGluZSA9ICgpID0+IHtcblx0XHRcdHdoaWxlIChwZWVrKCkgIT09IE5ld2xpbmUpXG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0fVxuXG5cdGNvbnN0IHVuZ3JvdXBlZCA9IGlzSW5RdW90ZSA9PiB7XG5cdFx0bGV0IGluZGVudCA9IDBcblxuXHRcdGxldCBjaCwgc3RhcnRMaW5lLCBzdGFydENvbHVtblxuXHRcdGNvbnN0XG5cdFx0XHRsb2MgPSAoKSA9PiBMb2MoUG9zKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pLCBwb3MoKSksXG5cdFx0XHRrZXl3b3JkID0gayA9PiBLZXl3b3JkKGxvYygpLCBrKSxcblx0XHRcdGdwID0gayA9PiBvKEdyb3VwUHJlKGxvYygpLCBrKSksXG5cdFx0XHRlYXROdW1iZXIgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpdCA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTnVtYmVyQ2hhcmFjdGVyKVxuXHRcdFx0XHRjb25zdCBudW0gPSBOdW1iZXIobGl0KVxuXHRcdFx0XHRjeC5jaGVjayghTnVtYmVyLmlzTmFOKG51bSksIHBvcywgKCkgPT5cblx0XHRcdFx0XHRgSW52YWxpZCBudW1iZXIgbGl0ZXJhbCAke2NvZGUobGl0KX1gKVxuXHRcdFx0XHRyZXR1cm4gVG9rZW5OdW1iZXJMaXRlcmFsKGxvYygpLCBudW0pXG5cdFx0XHR9XG5cblx0XHR3aGlsZSAoaW5kZXggIT09IHN0ci5sZW5ndGgpIHtcblx0XHRcdHN0YXJ0TGluZSA9IGxpbmVcblx0XHRcdHN0YXJ0Q29sdW1uID0gY29sdW1uXG5cblx0XHRcdGNoID0gZWF0KClcblx0XHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdFx0Y2FzZSBOMDogY2FzZSBOMTogY2FzZSBOMjogY2FzZSBOMzogY2FzZSBONDpcblx0XHRcdFx0Y2FzZSBONTogY2FzZSBONjogY2FzZSBONzogY2FzZSBOODogY2FzZSBOOTpcblx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgT3BQYXJlbjpcblx0XHRcdFx0XHRncChHUF9PcGVuUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBPcEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfT3BlbkJyYWNrZXQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbFBhcmVuOlxuXHRcdFx0XHRcdGdwKEdQX0Nsb3NlUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfQ2xvc2VCcmFja2V0KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xCcmFjZTpcblx0XHRcdFx0XHRjeC5jaGVjayhpc0luUXVvdGUsIGxvYywgKCkgPT4gYFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRjYXNlIFNwYWNlOlxuXHRcdFx0XHRcdGN4Lndhcm5JZihwZWVrKCkgPT09IFNwYWNlLCBsb2MsICdNdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cnKVxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgRG90OiB7XG5cdFx0XHRcdFx0Y29uc3QgcCA9IHBlZWsoKVxuXHRcdFx0XHRcdGlmIChwID09PSBTcGFjZSB8fCBwID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdFx0XHQvLyBPYmpMaXQgYXNzaWduIGluIGl0cyBvd24gc3BhY2VkIGdyb3VwLlxuXHRcdFx0XHRcdFx0Ly8gV2UgY2FuJ3QganVzdCBjcmVhdGUgYSBuZXcgR3JvdXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG9cblx0XHRcdFx0XHRcdC8vIGVuc3VyZSBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBwcmVjZWRpbmcgb3IgZm9sbG93aW5nIHNwYWNlZCBncm91cC5cblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdFx0byhrZXl3b3JkKCcuICcpKVxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRvKERvdE5hbWUoXG5cdFx0XHRcdFx0XHRcdGxvYygpLFxuXHRcdFx0XHRcdFx0XHQvLyArMSBmb3IgdGhlIGRvdCB3ZSBqdXN0IHNraXBwZWQuXG5cdFx0XHRcdFx0XHRcdHNraXBXaGlsZUVxdWFscyhEb3QpICsgMSxcblx0XHRcdFx0XHRcdFx0dGFrZVdoaWxlKGlzTmFtZUNoYXJhY3RlcikpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBDb2xvbjpcblx0XHRcdFx0XHRvKGtleXdvcmQoJzonKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFRpbGRlOlxuXHRcdFx0XHRcdGlmICh0cnlFYXQoQmFyKSkge1xuXHRcdFx0XHRcdFx0byhrZXl3b3JkKCd+fCcpKVxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoJ34nKSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQmFyOlxuXHRcdFx0XHRcdC8vIEZpcnN0IGFyZyBpbiBpdHMgb3duIHNwYWNlZCBncm91cFxuXHRcdFx0XHRcdG8oa2V5d29yZCgnfCcpKVxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgVW5kZXJzY29yZTpcblx0XHRcdFx0XHRvKGtleXdvcmQoJ18nKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEhhc2g6XG5cdFx0XHRcdFx0aWYgKCEodHJ5RWF0KFNwYWNlKSB8fCB0cnlFYXQoVGFiKSkpXG5cdFx0XHRcdFx0XHRjeC5mYWlsKGxvYywgKCkgPT4gYCR7Y29kZSgnIycpfSBtdXN0IGJlIGZvbGxvd2VkIGJ5IHNwYWNlIG9yIHRhYi59YClcblx0XHRcdFx0XHRza2lwUmVzdE9mTGluZSgpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2soIWlzSW5RdW90ZSwgbG9jLCAnUXVvdGUgaW50ZXJwb2xhdGlvbiBjYW5ub3QgY29udGFpbiBuZXdsaW5lJylcblx0XHRcdFx0XHRjeC5jaGVjayhwcmV2KCkgIT09IFNwYWNlLCBsb2MsICdMaW5lIGVuZHMgaW4gYSBzcGFjZScpXG5cblx0XHRcdFx0XHQvLyBTa2lwIGFueSBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRza2lwTmV3bGluZXMoKVxuXHRcdFx0XHRcdGNvbnN0IG9sZEluZGVudCA9IGluZGVudFxuXHRcdFx0XHRcdGluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRcdFx0Y3guY2hlY2socGVlaygpICE9PSBTcGFjZSwgcG9zLCAnTGluZSBiZWdpbnMgaW4gYSBzcGFjZScpXG5cdFx0XHRcdFx0aWYgKGluZGVudCA8PSBvbGRJbmRlbnQpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBpbmRlbnQ7IGkgPCBvbGRJbmRlbnQ7IGkgPSBpICsgMSlcblx0XHRcdFx0XHRcdFx0Z3AoR1BfQ2xvc2VCbG9jaylcblx0XHRcdFx0XHRcdGdwKEdQX0xpbmUpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN4LmNoZWNrKGluZGVudCA9PT0gb2xkSW5kZW50ICsgMSwgbG9jLCAnTGluZSBpcyBpbmRlbnRlZCBtb3JlIHRoYW4gb25jZScpXG5cdFx0XHRcdFx0XHRncChHUF9PcGVuQmxvY2spXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBUYWI6XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MoKSwgJ1RhYiBtYXkgb25seSBiZSB1c2VkIHRvIGluZGVudCcpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBRdW90ZTpcblx0XHRcdFx0XHRsZXhRdW90ZShpbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBIeXBoZW46XG5cdFx0XHRcdFx0aWYgKGlzRGlnaXQocGVlaygpKSkge1xuXHRcdFx0XHRcdFx0byhlYXROdW1iZXIoKSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEVsc2UgZmFsbHRocm91Z2hcblx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdGN4LmNoZWNrKFxuXHRcdFx0XHRcdFx0IWlzUmVzZXJ2ZWRDaGFyYWN0ZXIoY2gpLCBsb2MsICgpID0+IGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0XHQvLyBBbGwgb3RoZXIgY2hhcmFjdGVycyBzaG91bGQgYmUgaGFuZGxlZCBpbiBhIGNhc2UgYWJvdmUuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTmFtZUNoYXJhY3RlcilcblxuXHRcdFx0XHRcdGlmIChOb25OYW1lcy5oYXMobmFtZSkpXG5cdFx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3JlZ2lvbicpIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdCBvZiBsaW5lIGlzIGEgY29tbWVudC5cblx0XHRcdFx0XHRcdFx0c2tpcFJlc3RPZkxpbmUoKVxuXHRcdFx0XHRcdFx0XHRvKGtleXdvcmQoJ3JlZ2lvbicpKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChBbGxLZXl3b3Jkcy5oYXMobmFtZSkpXG5cdFx0XHRcdFx0XHRcdG8oa2V5d29yZChuYW1lKSlcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0Y3guZmFpbChsb2MsIGBSZXNlcnZlZCB3b3JkICR7Y29kZShuYW1lKX1gKVxuXHRcdFx0XHRcdGVsc2UgaWYgKHRyeUVhdChVbmRlcnNjb3JlKSlcblx0XHRcdFx0XHRcdG8oQ2FsbE9uRm9jdXMobG9jKCksIG5hbWUpKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG8oTmFtZShsb2MoKSwgbmFtZSkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBsZXhRdW90ZSA9IGluZGVudCA9PiB7XG5cdFx0Y29uc3QgcXVvdGVJbmRlbnQgPSBpbmRlbnQgKyAxXG5cblx0XHRjb25zdCBpc0luZGVudGVkID0gdHJ5RWF0TmV3bGluZSgpXG5cdFx0aWYgKGlzSW5kZW50ZWQpIHtcblx0XHRcdGNvbnN0IGFjdHVhbEluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRjeC5jaGVjayhhY3R1YWxJbmRlbnQgPT09IHF1b3RlSW5kZW50LCBwb3MsXG5cdFx0XHRcdCdJbmRlbnRlZCBxdW90ZSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbW9yZSBpbmRlbnQgdGhhbiBwcmV2aW91cyBsaW5lLicpXG5cdFx0fVxuXG5cdFx0bGV0IHJlYWQgPSAnJ1xuXG5cdFx0Y29uc3QgeWllbGRSZWFkID0gKCkgPT4ge1xuXHRcdFx0aWYgKHJlYWQgIT09ICcnKSB7XG5cdFx0XHRcdG8ocmVhZClcblx0XHRcdFx0cmVhZCA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfT3BlblF1b3RlKSlcblxuXHRcdGVhdENoYXJzOiB3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hQb3MgPSBwb3MoKVxuXHRcdFx0Y29uc3QgY2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIEJhY2tzbGFzaDoge1xuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgcXVvdGVFc2NhcGUoZWF0KCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE9wQnJhY2U6IHtcblx0XHRcdFx0XHR5aWVsZFJlYWQoKVxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IGNyZWF0ZSBhIEdyb3VwIG5vdyBiZWNhdXNlIHRoZXJlIG1heSBiZSBvdGhlciBHcm91cFByZV9zIGluc2lkZS5cblx0XHRcdFx0XHRvKEdyb3VwUHJlKHNpbmdsZUNoYXJMb2MoY2hQb3MpLCBHUF9PcGVuUGFyZW4pKVxuXHRcdFx0XHRcdHVuZ3JvdXBlZCh0cnVlKVxuXHRcdFx0XHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUGFyZW4pKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2socHJldiAhPT0gU3BhY2UsIGNoUG9zLCAnTGluZSBlbmRzIGluIGEgc3BhY2UnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5kZW50ZWQsIGNoUG9zLCAnVW5jbG9zZWQgcXVvdGUuJylcblx0XHRcdFx0XHRsZXQgbmV3SW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblxuXHRcdFx0XHRcdGxldCBleHRyYU5ld2xpbmVzID0gJydcblx0XHRcdFx0XHQvLyBBbGxvdyBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRpZiAobmV3SW5kZW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRleHRyYU5ld2xpbmVzID0gJ1xcbicucmVwZWF0KHNraXBOZXdsaW5lcygpKVxuXHRcdFx0XHRcdFx0bmV3SW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobmV3SW5kZW50IDwgcXVvdGVJbmRlbnQpIHtcblx0XHRcdFx0XHRcdC8vIEluZGVudGVkIHF1b3RlIHNlY3Rpb24gaXMgb3Zlci5cblx0XHRcdFx0XHRcdC8vIFVuZG8gcmVhZGluZyB0aGUgdGFicyBhbmQgbmV3bGluZS5cblx0XHRcdFx0XHRcdHN0ZXBCYWNrTWFueShjaFBvcywgbmV3SW5kZW50ICsgMSlcblx0XHRcdFx0XHRcdGFzc2VydChwZWVrKCkgPT09IE5ld2xpbmUpXG5cdFx0XHRcdFx0XHRicmVhayBlYXRDaGFyc1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0cmVhZCA9IHJlYWQgKyBleHRyYU5ld2xpbmVzICsgJ1xcbicgKyAnXFx0Jy5yZXBlYXQobmV3SW5kZW50IC0gcXVvdGVJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGlmICghaXNJbmRlbnRlZClcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR5aWVsZFJlYWQoKVxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUXVvdGUpKVxuXHR9XG5cblx0Y29uc3QgcXVvdGVFc2NhcGUgPSBjaCA9PiB7XG5cdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0Y2FzZSBPcEJyYWNlOiByZXR1cm4gJ3snXG5cdFx0XHRjYXNlIExldHRlck46IHJldHVybiAnXFxuJ1xuXHRcdFx0Y2FzZSBMZXR0ZXJUOiByZXR1cm4gJ1xcdCdcblx0XHRcdGNhc2UgUXVvdGU6IHJldHVybiAnXCInXG5cdFx0XHRjYXNlIEJhY2tzbGFzaDogcmV0dXJuICdcXFxcJ1xuXHRcdFx0ZGVmYXVsdDogY3guZmFpbChwb3MsIGBObyBuZWVkIHRvIGVzY2FwZSAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdH1cblx0fVxuXG5cdHVuZ3JvdXBlZChmYWxzZSlcblx0cmV0dXJuIHJlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=