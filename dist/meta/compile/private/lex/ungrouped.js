if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../language', '../Token', '../util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _language, _Token, _util, _GroupPre, _char) {
	'use strict';

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	const cc = function (ch) {
		return ch.charCodeAt(0);
	};
	const N0 = cc('0'),
	      N1 = cc('1'),
	      N2 = cc('2'),
	      N3 = cc('3'),
	      N4 = cc('4'),
	      N5 = cc('5'),
	      N6 = cc('6'),
	      N7 = cc('7'),
	      N8 = cc('8'),
	      N9 = cc('9'),
	      OpParen = cc('('),
	      OpBracket = cc('['),
	      OpBrace = cc('{'),
	      ClParen = cc(')'),
	      ClBracket = cc(']'),
	      ClBrace = cc('}'),
	      Ampersand = cc('&'),
	      Backslash = cc('\\'),
	      Backtick = cc('`'),
	      Bar = cc('|'),
	      Caret = cc('^'),
	      Colon = cc(':'),
	      Comma = cc(','),
	      Dot = cc('.'),
	      Hash = cc('#'),
	      Hyphen = cc('-'),
	      LetterN = cc('n'),
	      LetterT = cc('t'),
	      Newline = cc('\n'),
	      Percent = cc('%'),
	      Quote = cc('"'),
	      Semicolon = cc(';'),
	      Space = cc(' '),
	      Tab = cc('\t'),
	      Tilde = cc('~'),
	      Underscore = cc('_'),
	      Zero = cc('\u0000');

	module.exports = function (cx, str) {
		// Lexing algorithm requires trailing newline.
		// Use a null-terminated string because it's faster than checking whether index === length.
		str = str + '\n\u0000';

		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		// Use these for debugging pos.
		/*
  const
  	checkPos = () => {
  		const p = getCorrectPos()
  		if (p.line !== line || p.column !== column)
  			throw new Error(`index: ${index}, wrong: ${Pos(line, column)}, right: ${p}`)
  	},
  	indexToPos = new Map(),
  	getCorrectPos = () => {
  		if (index === 0)
  			return Pos(StartLine, StartColumn)
  			let oldPos, oldIndex
  		for (oldIndex = index - 1; oldIndex > 0; oldIndex = oldIndex - 1) {
  			oldPos = indexToPos.get(oldIndex)
  			if (oldPos)
  				break
  		}
  		if (oldPos === undefined) {
  			assert(oldIndex === 0)
  			oldPos = Pos(StartLine, StartColumn)
  		}
  		let newLine = oldPos.line, newColumn = oldPos.column
  		for (; oldIndex < index; oldIndex = oldIndex + 1)
  			if (str.charCodeAt(oldIndex) === Newline) {
  				newLine = newLine + 1
  				newColumn = StartColumn
  			} else
  				newColumn = newColumn + 1
  			const p = Pos(newLine, newColumn)
  		indexToPos.set(index, p)
  		return p
  	}
  */

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return (0, _esastDistLoc.Pos)(line, column);
		},
		      loc = function () {
			return (0, _esastDistLoc.singleCharLoc)(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			return _skipWhile(function (_) {
				return _ !== Newline;
			});
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startColumn;
			const loc = function () {
				return (0, _Loc)((0, _esastDistLoc.Pos)(line, startColumn), pos());
			},
			      keyword = function (k) {
				return (0, _Token.Keyword)(loc(), k);
			},
			      gp = function (k) {
				return o((0, _GroupPre2)(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + (0, _CompileError.code)(lit);
				});
				return (0, _Token.TokenNumberLiteral)(loc(), num);
			};

			while (true) {
				startColumn = column;
				ch = eat();
				switch (ch) {
					case Zero:
						return;
					case N0:case N1:case N2:case N3:case N4:
					case N5:case N6:case N7:case N8:case N9:
						o(eatNumber());
						break;
					case OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + (0, _char.showChar)(ch);
						});
						return;
					case Space:
						cx.warnIf(peek() === Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case Dot:
						{
							const p = peek();
							if (p === Space || p === Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword(_Token.KW_ObjAssign));
								gp(_GroupPre.GP_Space);
							} else o((0, _Token.DotName)(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case Colon:
						o(keyword(_Token.KW_Type));
						break;
					case Tilde:
						if (tryEat(Bar)) {
							o(keyword(_Token.KW_GenFun));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword(_Token.KW_Lazy));
							break;
						}
						break;
					case Bar:
						o(keyword(_Token.KW_Fun));
						// First arg in its own spaced group
						gp(_GroupPre.GP_Space);
						break;
					case Underscore:
						o(keyword(_Token.KW_Focus));
						break;
					case Hash:
						if (!(tryEat(Space) || tryEat(Tab))) cx.fail(loc, function () {
							return '' + (0, _CompileError.code)('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(Tab);
							cx.check(peek() !== Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case Quote:
						lexQuote(indent);
						break;
					case Ampersand:case Backslash:case Backtick:case Caret:
					case Comma:case Percent:case Semicolon:
						cx.fail(loc, 'Reserved character ' + (0, _char.showChar)(ch));
					case Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
					case Hyphen:
						if ((0, _char.isDigit)(peek())) {
							o(eatNumber());
							break;
						}
					// else fallthrough
					default:
						{
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);
							const k = (0, _Token.keywordKFromName)(name);
							if (k !== undefined) {
								if (k === _Token.KW_Region) skipRestOfLine();
								o(keyword(k));
							} else if (tryEat(Underscore)) o((0, _Token.CallOnFocus)(loc(), name));else {
								cx.check(!(0, _language.isReservedName)(name), pos, function () {
									return 'Reserved name ' + (0, _CompileError.code)(name);
								});
								o((0, _Token.Name)(loc(), name));
							}
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o((0, _GroupPre2)(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o((0, _GroupPre2)((0, _esastDistLoc.singleCharLoc)(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case Newline:
						{
							cx.check(prev !== Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							// Allow extra blank lines.
							const numNewlines = skipNewlines() + 1;
							const newIndent = skipWhileEquals(Tab);
							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, numNewlines + newIndent);
								(0, _util.assert)(peek() === Newline);
								break eatChars;
							} else read = read + '\n'.repeat(numNewlines) + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case OpBrace:
					return '{';
				case LetterN:
					return '\n';
				case LetterT:
					return '\t';
				case Quote:
					return '"';
				case Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + (0, _char.showChar)(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBV0EsT0FBTSxFQUFFLEdBQUcsVUFBQSxFQUFFO1NBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFBQSxDQUFBO0FBQ2pDLE9BQ0MsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNwRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ3BFLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUN6RCxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDekQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbkIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7T0FDcEIsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbEIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDYixLQUFLLEdBQUcs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QTs7QUFFRCxRQUFNLFdBQVcsR0FBRyxVQUFBLEVBQUUsRUFBSTtBQUN6QixXQUFRLEVBQUU7QUFDVCxTQUFLLE9BQU87QUFBRSxZQUFPLEdBQUcsQ0FBQTtBQUFBLEFBQ3hCLFNBQUssT0FBTztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDekIsU0FBSyxPQUFPO0FBQUUsWUFBTyxJQUFJLENBQUE7QUFBQSxBQUN6QixTQUFLLEtBQUs7QUFBRSxZQUFPLEdBQUcsQ0FBQTtBQUFBLEFBQ3RCLFNBQUssU0FBUztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDM0I7QUFBUyxPQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcseUJBQXVCLFVBOVdyQyxRQUFRLEVBOFdzQyxFQUFFLENBQUMsQ0FBRyxDQUFBO0FBQUEsSUFDMUQ7R0FDRCxDQUFBOztBQUVELFdBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNoQixTQUFPLEdBQUcsQ0FBQTtFQUNWIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9jLCB7IFBvcywgU3RhcnRMaW5lLCBTdGFydENvbHVtbiwgc2luZ2xlQ2hhckxvYyB9IGZyb20gJ2VzYXN0L2Rpc3QvTG9jJ1xuaW1wb3J0IHsgY29kZSB9IGZyb20gJy4uLy4uL0NvbXBpbGVFcnJvcidcbmltcG9ydCB7IGlzUmVzZXJ2ZWROYW1lIH0gZnJvbSAnLi4vbGFuZ3VhZ2UnXG5pbXBvcnQgeyBDYWxsT25Gb2N1cywgRG90TmFtZSwgS2V5d29yZCwgVG9rZW5OdW1iZXJMaXRlcmFsLCBOYW1lLFxuXHRrZXl3b3JkS0Zyb21OYW1lLFxuXHRLV19Gb2N1cywgS1dfRnVuLCBLV19HZW5GdW4sIEtXX0xhenksIEtXX09iakFzc2lnbiwgS1dfUmVnaW9uLCBLV19UeXBlIH0gZnJvbSAnLi4vVG9rZW4nXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IEdyb3VwUHJlLCB7IEdQX09wZW5QYXJlbiwgR1BfT3BlbkJyYWNrZXQsIEdQX09wZW5CbG9jaywgR1BfT3BlblF1b3RlLCBHUF9MaW5lLFxuXHRHUF9TcGFjZSwgR1BfQ2xvc2VQYXJlbiwgR1BfQ2xvc2VCcmFja2V0LCBHUF9DbG9zZUJsb2NrLCBHUF9DbG9zZVF1b3RlfSBmcm9tICcuL0dyb3VwUHJlJ1xuaW1wb3J0IHsgc2hvd0NoYXIsIGlzRGlnaXQsIGlzTmFtZUNoYXJhY3RlciwgaXNOdW1iZXJDaGFyYWN0ZXIgfSBmcm9tICcuL2NoYXInXG5cbmNvbnN0IGNjID0gY2ggPT4gY2guY2hhckNvZGVBdCgwKVxuY29uc3Rcblx0TjAgPSBjYygnMCcpLCBOMSA9IGNjKCcxJyksIE4yID0gY2MoJzInKSwgTjMgPSBjYygnMycpLCBONCA9IGNjKCc0JyksXG5cdE41ID0gY2MoJzUnKSwgTjYgPSBjYygnNicpLCBONyA9IGNjKCc3JyksIE44ID0gY2MoJzgnKSwgTjkgPSBjYygnOScpLFxuXHRPcFBhcmVuID0gY2MoJygnKSwgT3BCcmFja2V0ID0gY2MoJ1snKSwgT3BCcmFjZSA9IGNjKCd7JyksXG5cdENsUGFyZW4gPSBjYygnKScpLCBDbEJyYWNrZXQgPSBjYygnXScpLCBDbEJyYWNlID0gY2MoJ30nKSxcblx0QW1wZXJzYW5kID0gY2MoJyYnKSxcblx0QmFja3NsYXNoID0gY2MoJ1xcXFwnKSxcblx0QmFja3RpY2sgPSBjYygnYCcpLFxuXHRCYXIgPSBjYygnfCcpLFxuXHRDYXJldCA9IGNjKCdeJyksXG5cdENvbG9uID0gY2MoJzonKSxcblx0Q29tbWEgPSBjYygnLCcpLFxuXHREb3QgPSBjYygnLicpLFxuXHRIYXNoID0gY2MoJyMnKSxcblx0SHlwaGVuID0gY2MoJy0nKSxcblx0TGV0dGVyTiA9IGNjKCduJyksXG5cdExldHRlclQgPSBjYygndCcpLFxuXHROZXdsaW5lID0gY2MoJ1xcbicpLFxuXHRQZXJjZW50ID0gY2MoJyUnKSxcblx0UXVvdGUgPSBjYygnXCInKSxcblx0U2VtaWNvbG9uID0gY2MoJzsnKSxcblx0U3BhY2UgPSBjYygnICcpLFxuXHRUYWIgPSBjYygnXFx0JyksXG5cdFRpbGRlID0gY2MoJ34nKSxcblx0VW5kZXJzY29yZSA9IGNjKCdfJyksXG5cdFplcm8gPSBjYygnXFwwJylcblxuZXhwb3J0IGRlZmF1bHQgKGN4LCBzdHIpID0+IHtcblx0Ly8gTGV4aW5nIGFsZ29yaXRobSByZXF1aXJlcyB0cmFpbGluZyBuZXdsaW5lLlxuXHQvLyBVc2UgYSBudWxsLXRlcm1pbmF0ZWQgc3RyaW5nIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBjaGVja2luZyB3aGV0aGVyIGluZGV4ID09PSBsZW5ndGguXG5cdHN0ciA9IHN0ciArICdcXG5cXDAnXG5cblx0Y29uc3QgcmVzID0gWyBdXG5cdGxldCBsaW5lID0gU3RhcnRMaW5lXG5cdGxldCBjb2x1bW4gPSBTdGFydENvbHVtblxuXHRsZXQgaW5kZXggPSAwXG5cblx0Ly8gVXNlIHRoZXNlIGZvciBkZWJ1Z2dpbmcgcG9zLlxuXHQvKlxuXHRjb25zdFxuXHRcdGNoZWNrUG9zID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgcCA9IGdldENvcnJlY3RQb3MoKVxuXHRcdFx0aWYgKHAubGluZSAhPT0gbGluZSB8fCBwLmNvbHVtbiAhPT0gY29sdW1uKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGluZGV4OiAke2luZGV4fSwgd3Jvbmc6ICR7UG9zKGxpbmUsIGNvbHVtbil9LCByaWdodDogJHtwfWApXG5cdFx0fSxcblx0XHRpbmRleFRvUG9zID0gbmV3IE1hcCgpLFxuXHRcdGdldENvcnJlY3RQb3MgPSAoKSA9PiB7XG5cdFx0XHRpZiAoaW5kZXggPT09IDApXG5cdFx0XHRcdHJldHVybiBQb3MoU3RhcnRMaW5lLCBTdGFydENvbHVtbilcblxuXHRcdFx0bGV0IG9sZFBvcywgb2xkSW5kZXhcblx0XHRcdGZvciAob2xkSW5kZXggPSBpbmRleCAtIDE7IG9sZEluZGV4ID4gMDsgb2xkSW5kZXggPSBvbGRJbmRleCAtIDEpIHtcblx0XHRcdFx0b2xkUG9zID0gaW5kZXhUb1Bvcy5nZXQob2xkSW5kZXgpXG5cdFx0XHRcdGlmIChvbGRQb3MpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGlmIChvbGRQb3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhc3NlcnQob2xkSW5kZXggPT09IDApXG5cdFx0XHRcdG9sZFBvcyA9IFBvcyhTdGFydExpbmUsIFN0YXJ0Q29sdW1uKVxuXHRcdFx0fVxuXHRcdFx0bGV0IG5ld0xpbmUgPSBvbGRQb3MubGluZSwgbmV3Q29sdW1uID0gb2xkUG9zLmNvbHVtblxuXHRcdFx0Zm9yICg7IG9sZEluZGV4IDwgaW5kZXg7IG9sZEluZGV4ID0gb2xkSW5kZXggKyAxKVxuXHRcdFx0XHRpZiAoc3RyLmNoYXJDb2RlQXQob2xkSW5kZXgpID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdFx0bmV3TGluZSA9IG5ld0xpbmUgKyAxXG5cdFx0XHRcdFx0bmV3Q29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0bmV3Q29sdW1uID0gbmV3Q29sdW1uICsgMVxuXG5cdFx0XHRjb25zdCBwID0gUG9zKG5ld0xpbmUsIG5ld0NvbHVtbilcblx0XHRcdGluZGV4VG9Qb3Muc2V0KGluZGV4LCBwKVxuXHRcdFx0cmV0dXJuIHBcblx0XHR9XG5cdCovXG5cblx0Y29uc3Rcblx0XHRvID0gdCA9PiB7IHJlcy5wdXNoKHQpIH0sXG5cblx0XHRwb3MgPSAoKSA9PiBQb3MobGluZSwgY29sdW1uKSxcblx0XHRsb2MgPSAoKSA9PiBzaW5nbGVDaGFyTG9jKHBvcygpKSxcblxuXHRcdHByZXYgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCAtIDEpLFxuXHRcdHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCksXG5cblx0XHRlYXQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBjaCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KVxuXHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIDFcblx0XHRcdHJldHVybiBjaFxuXHRcdH0sXG5cdFx0dHJ5RWF0ID0gY2ggPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBjaFxuXHRcdFx0aWYgKGNhbkVhdCkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyAxXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FuRWF0XG5cdFx0fSxcblx0XHR0cnlFYXROZXdsaW5lID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBOZXdsaW5lXG5cdFx0XHRpZiAoY2FuRWF0KSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbkVhdFxuXHRcdH0sXG5cblx0XHQvLyBDYWxsZXIgbXVzdCBlbnN1cmUgdGhhdCBiYWNraW5nIHVwIG5DaGFyc1RvQmFja1VwIGNoYXJhY3RlcnMgYnJpbmdzIHVzIHRvIG9sZFBvcy5cblx0XHRzdGVwQmFja01hbnkgPSAob2xkUG9zLCBuQ2hhcnNUb0JhY2tVcCkgPT4ge1xuXHRcdFx0aW5kZXggPSBpbmRleCAtIG5DaGFyc1RvQmFja1VwXG5cdFx0XHRsaW5lID0gb2xkUG9zLmxpbmVcblx0XHRcdGNvbHVtbiA9IG9sZFBvcy5jb2x1bW5cblx0XHR9LFxuXG5cdFx0X3NraXBXaGlsZSA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHR3aGlsZSAocHJlZChwZWVrKCkpKVxuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0Y29uc3QgZGlmZiA9IGluZGV4IC0gc3RhcnRJbmRleFxuXHRcdFx0Y29sdW1uID0gY29sdW1uICsgZGlmZlxuXHRcdFx0cmV0dXJuIGRpZmZcblx0XHR9LFxuXHRcdHRha2VXaGlsZVdpdGhQcmV2ID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCAtIDEsIGluZGV4KVxuXHRcdH0sXG5cdFx0dGFrZVdoaWxlID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCwgaW5kZXgpXG5cdFx0fSxcblx0XHRza2lwV2hpbGVFcXVhbHMgPSBjaCA9PiBfc2tpcFdoaWxlKF8gPT4gXyA9PT0gY2gpLFxuXG5cdFx0Ly8gQ2FsbGVkIGFmdGVyIHNlZWluZyB0aGUgZmlyc3QgbmV3bGluZS5cblx0XHRza2lwTmV3bGluZXMgPSAoKSA9PiB7XG5cdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdGNvbnN0IHN0YXJ0TGluZSA9IGxpbmVcblx0XHRcdHdoaWxlIChwZWVrKCkgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHR9XG5cdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0cmV0dXJuIGxpbmUgLSBzdGFydExpbmVcblx0XHR9LFxuXG5cdFx0c2tpcFJlc3RPZkxpbmUgPSAoKSA9PlxuXHRcdFx0X3NraXBXaGlsZShfID0+IF8gIT09IE5ld2xpbmUpXG5cblx0Y29uc3QgdW5ncm91cGVkID0gaXNJblF1b3RlID0+IHtcblx0XHRsZXQgaW5kZW50ID0gMFxuXG5cdFx0bGV0IGNoLCBzdGFydENvbHVtblxuXHRcdGNvbnN0XG5cdFx0XHRsb2MgPSAoKSA9PiBMb2MoUG9zKGxpbmUsIHN0YXJ0Q29sdW1uKSwgcG9zKCkpLFxuXHRcdFx0a2V5d29yZCA9IGsgPT4gS2V5d29yZChsb2MoKSwgayksXG5cdFx0XHRncCA9IGsgPT4gbyhHcm91cFByZShsb2MoKSwgaykpLFxuXHRcdFx0ZWF0TnVtYmVyID0gKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXQgPSB0YWtlV2hpbGVXaXRoUHJldihpc051bWJlckNoYXJhY3Rlcilcblx0XHRcdFx0Y29uc3QgbnVtID0gTnVtYmVyKGxpdClcblx0XHRcdFx0Y3guY2hlY2soIU51bWJlci5pc05hTihudW0pLCBwb3MsICgpID0+XG5cdFx0XHRcdFx0YEludmFsaWQgbnVtYmVyIGxpdGVyYWwgJHtjb2RlKGxpdCl9YClcblx0XHRcdFx0cmV0dXJuIFRva2VuTnVtYmVyTGl0ZXJhbChsb2MoKSwgbnVtKVxuXHRcdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHN0YXJ0Q29sdW1uID0gY29sdW1uXG5cdFx0XHRjaCA9IGVhdCgpXG5cdFx0XHRzd2l0Y2ggKGNoKSB7XG5cdFx0XHRcdGNhc2UgWmVybzpcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0Y2FzZSBOMDogY2FzZSBOMTogY2FzZSBOMjogY2FzZSBOMzogY2FzZSBONDpcblx0XHRcdFx0Y2FzZSBONTogY2FzZSBONjogY2FzZSBONzogY2FzZSBOODogY2FzZSBOOTpcblx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgT3BQYXJlbjpcblx0XHRcdFx0XHRncChHUF9PcGVuUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBPcEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfT3BlbkJyYWNrZXQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbFBhcmVuOlxuXHRcdFx0XHRcdGdwKEdQX0Nsb3NlUGFyZW4pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBDbEJyYWNrZXQ6XG5cdFx0XHRcdFx0Z3AoR1BfQ2xvc2VCcmFja2V0KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xCcmFjZTpcblx0XHRcdFx0XHRjeC5jaGVjayhpc0luUXVvdGUsIGxvYywgKCkgPT4gYFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRjYXNlIFNwYWNlOlxuXHRcdFx0XHRcdGN4Lndhcm5JZihwZWVrKCkgPT09IFNwYWNlLCBsb2MsICdNdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cnKVxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgRG90OiB7XG5cdFx0XHRcdFx0Y29uc3QgcCA9IHBlZWsoKVxuXHRcdFx0XHRcdGlmIChwID09PSBTcGFjZSB8fCBwID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdFx0XHQvLyBPYmpMaXQgYXNzaWduIGluIGl0cyBvd24gc3BhY2VkIGdyb3VwLlxuXHRcdFx0XHRcdFx0Ly8gV2UgY2FuJ3QganVzdCBjcmVhdGUgYSBuZXcgR3JvdXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG9cblx0XHRcdFx0XHRcdC8vIGVuc3VyZSBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBwcmVjZWRpbmcgb3IgZm9sbG93aW5nIHNwYWNlZCBncm91cC5cblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX09iakFzc2lnbikpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdG8oRG90TmFtZShcblx0XHRcdFx0XHRcdFx0bG9jKCksXG5cdFx0XHRcdFx0XHRcdC8vICsxIGZvciB0aGUgZG90IHdlIGp1c3Qgc2tpcHBlZC5cblx0XHRcdFx0XHRcdFx0c2tpcFdoaWxlRXF1YWxzKERvdCkgKyAxLFxuXHRcdFx0XHRcdFx0XHR0YWtlV2hpbGUoaXNOYW1lQ2hhcmFjdGVyKSkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIENvbG9uOlxuXHRcdFx0XHRcdG8oa2V5d29yZChLV19UeXBlKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFRpbGRlOlxuXHRcdFx0XHRcdGlmICh0cnlFYXQoQmFyKSkge1xuXHRcdFx0XHRcdFx0byhrZXl3b3JkKEtXX0dlbkZ1bikpXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19MYXp5KSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQmFyOlxuXHRcdFx0XHRcdG8oa2V5d29yZChLV19GdW4pKVxuXHRcdFx0XHRcdC8vIEZpcnN0IGFyZyBpbiBpdHMgb3duIHNwYWNlZCBncm91cFxuXHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgVW5kZXJzY29yZTpcblx0XHRcdFx0XHRvKGtleXdvcmQoS1dfRm9jdXMpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgSGFzaDpcblx0XHRcdFx0XHRpZiAoISh0cnlFYXQoU3BhY2UpIHx8IHRyeUVhdChUYWIpKSlcblx0XHRcdFx0XHRcdGN4LmZhaWwobG9jLCAoKSA9PiBgJHtjb2RlKCcjJyl9IG11c3QgYmUgZm9sbG93ZWQgYnkgc3BhY2Ugb3IgdGFiLn1gKVxuXHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayghaXNJblF1b3RlLCBsb2MsICdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYoKSAhPT0gU3BhY2UsIGxvYywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblxuXHRcdFx0XHRcdC8vIFNraXAgYW55IGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdHNraXBOZXdsaW5lcygpXG5cdFx0XHRcdFx0Y29uc3Qgb2xkSW5kZW50ID0gaW5kZW50XG5cdFx0XHRcdFx0aW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRjeC5jaGVjayhwZWVrKCkgIT09IFNwYWNlLCBwb3MsICdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRpZiAoaW5kZW50IDw9IG9sZEluZGVudCkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGluZGVudDsgaSA8IG9sZEluZGVudDsgaSA9IGkgKyAxKVxuXHRcdFx0XHRcdFx0XHRncChHUF9DbG9zZUJsb2NrKVxuXHRcdFx0XHRcdFx0Z3AoR1BfTGluZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soaW5kZW50ID09PSBvbGRJbmRlbnQgKyAxLCBsb2MsICdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlJylcblx0XHRcdFx0XHRcdGdwKEdQX09wZW5CbG9jaylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGxleFF1b3RlKGluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEFtcGVyc2FuZDogY2FzZSBCYWNrc2xhc2g6IGNhc2UgQmFja3RpY2s6IGNhc2UgQ2FyZXQ6XG5cdFx0XHRcdGNhc2UgQ29tbWE6IGNhc2UgUGVyY2VudDogY2FzZSBTZW1pY29sb246XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MsIGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0Y2FzZSBUYWI6XG5cdFx0XHRcdFx0Y3guZmFpbChsb2MoKSwgJ1RhYiBtYXkgb25seSBiZSB1c2VkIHRvIGluZGVudCcpXG5cdFx0XHRcdGNhc2UgSHlwaGVuOlxuXHRcdFx0XHRcdGlmIChpc0RpZ2l0KHBlZWsoKSkpIHtcblx0XHRcdFx0XHRcdG8oZWF0TnVtYmVyKCkpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbHNlIGZhbGx0aHJvdWdoXG5cdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHQvLyBBbGwgb3RoZXIgY2hhcmFjdGVycyBzaG91bGQgYmUgaGFuZGxlZCBpbiBhIGNhc2UgYWJvdmUuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRha2VXaGlsZVdpdGhQcmV2KGlzTmFtZUNoYXJhY3Rlcilcblx0XHRcdFx0XHRjb25zdCBrID0ga2V5d29yZEtGcm9tTmFtZShuYW1lKVxuXHRcdFx0XHRcdGlmIChrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSBLV19SZWdpb24pXG5cdFx0XHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRcdG8oa2V5d29yZChrKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRyeUVhdChVbmRlcnNjb3JlKSlcblx0XHRcdFx0XHRcdG8oQ2FsbE9uRm9jdXMobG9jKCksIG5hbWUpKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soIWlzUmVzZXJ2ZWROYW1lKG5hbWUpLCBwb3MsICgpID0+IGBSZXNlcnZlZCBuYW1lICR7Y29kZShuYW1lKX1gKVxuXHRcdFx0XHRcdFx0byhOYW1lKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBsZXhRdW90ZSA9IGluZGVudCA9PiB7XG5cdFx0Y29uc3QgcXVvdGVJbmRlbnQgPSBpbmRlbnQgKyAxXG5cblx0XHRjb25zdCBpc0luZGVudGVkID0gdHJ5RWF0TmV3bGluZSgpXG5cdFx0aWYgKGlzSW5kZW50ZWQpIHtcblx0XHRcdGNvbnN0IGFjdHVhbEluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRjeC5jaGVjayhhY3R1YWxJbmRlbnQgPT09IHF1b3RlSW5kZW50LCBwb3MsXG5cdFx0XHRcdCdJbmRlbnRlZCBxdW90ZSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbW9yZSBpbmRlbnQgdGhhbiBwcmV2aW91cyBsaW5lLicpXG5cdFx0fVxuXG5cdFx0bGV0IHJlYWQgPSAnJ1xuXG5cdFx0Y29uc3QgeWllbGRSZWFkID0gKCkgPT4ge1xuXHRcdFx0aWYgKHJlYWQgIT09ICcnKSB7XG5cdFx0XHRcdG8ocmVhZClcblx0XHRcdFx0cmVhZCA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfT3BlblF1b3RlKSlcblxuXHRcdGVhdENoYXJzOiB3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hQb3MgPSBwb3MoKVxuXHRcdFx0Y29uc3QgY2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIEJhY2tzbGFzaDoge1xuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgcXVvdGVFc2NhcGUoZWF0KCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE9wQnJhY2U6IHtcblx0XHRcdFx0XHR5aWVsZFJlYWQoKVxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IGNyZWF0ZSBhIEdyb3VwIG5vdyBiZWNhdXNlIHRoZXJlIG1heSBiZSBvdGhlciBHcm91cFByZV9zIGluc2lkZS5cblx0XHRcdFx0XHRvKEdyb3VwUHJlKHNpbmdsZUNoYXJMb2MoY2hQb3MpLCBHUF9PcGVuUGFyZW4pKVxuXHRcdFx0XHRcdHVuZ3JvdXBlZCh0cnVlKVxuXHRcdFx0XHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUGFyZW4pKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2socHJldiAhPT0gU3BhY2UsIGNoUG9zLCAnTGluZSBlbmRzIGluIGEgc3BhY2UnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5kZW50ZWQsIGNoUG9zLCAnVW5jbG9zZWQgcXVvdGUuJylcblx0XHRcdFx0XHQvLyBBbGxvdyBleHRyYSBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRjb25zdCBudW1OZXdsaW5lcyA9IHNraXBOZXdsaW5lcygpICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0luZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRcdFx0aWYgKG5ld0luZGVudCA8IHF1b3RlSW5kZW50KSB7XG5cdFx0XHRcdFx0XHQvLyBJbmRlbnRlZCBxdW90ZSBzZWN0aW9uIGlzIG92ZXIuXG5cdFx0XHRcdFx0XHQvLyBVbmRvIHJlYWRpbmcgdGhlIHRhYnMgYW5kIG5ld2xpbmUuXG5cdFx0XHRcdFx0XHRzdGVwQmFja01hbnkoY2hQb3MsIG51bU5ld2xpbmVzICsgbmV3SW5kZW50KVxuXHRcdFx0XHRcdFx0YXNzZXJ0KHBlZWsoKSA9PT0gTmV3bGluZSlcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRyZWFkID0gcmVhZCArXG5cdFx0XHRcdFx0XHRcdCdcXG4nLnJlcGVhdChudW1OZXdsaW5lcykgKyAnXFx0Jy5yZXBlYXQobmV3SW5kZW50IC0gcXVvdGVJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGlmICghaXNJbmRlbnRlZClcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR5aWVsZFJlYWQoKVxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUXVvdGUpKVxuXHR9XG5cblx0Y29uc3QgcXVvdGVFc2NhcGUgPSBjaCA9PiB7XG5cdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0Y2FzZSBPcEJyYWNlOiByZXR1cm4gJ3snXG5cdFx0XHRjYXNlIExldHRlck46IHJldHVybiAnXFxuJ1xuXHRcdFx0Y2FzZSBMZXR0ZXJUOiByZXR1cm4gJ1xcdCdcblx0XHRcdGNhc2UgUXVvdGU6IHJldHVybiAnXCInXG5cdFx0XHRjYXNlIEJhY2tzbGFzaDogcmV0dXJuICdcXFxcJ1xuXHRcdFx0ZGVmYXVsdDogY3guZmFpbChwb3MsIGBObyBuZWVkIHRvIGVzY2FwZSAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdH1cblx0fVxuXG5cdHVuZ3JvdXBlZChmYWxzZSlcblx0cmV0dXJuIHJlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=