if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../Lang', '../Token', '../U/util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _Lang, _Token, _UUtil, _GroupPre, _char) {
	'use strict';

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	const cc = function (ch) {
		return ch.charCodeAt(0);
	};
	const N0 = cc('0'),
	      N1 = cc('1'),
	      N2 = cc('2'),
	      N3 = cc('3'),
	      N4 = cc('4'),
	      N5 = cc('5'),
	      N6 = cc('6'),
	      N7 = cc('7'),
	      N8 = cc('8'),
	      N9 = cc('9'),
	      OpParen = cc('('),
	      OpBracket = cc('['),
	      OpBrace = cc('{'),
	      ClParen = cc(')'),
	      ClBracket = cc(']'),
	      ClBrace = cc('}'),
	      Ampersand = cc('&'),
	      Backslash = cc('\\'),
	      Backtick = cc('`'),
	      Bar = cc('|'),
	      Caret = cc('^'),
	      Colon = cc(':'),
	      Comma = cc(','),
	      Dot = cc('.'),
	      Hash = cc('#'),
	      Hyphen = cc('-'),
	      LetterN = cc('n'),
	      LetterT = cc('t'),
	      Newline = cc('\n'),
	      Percent = cc('%'),
	      Quote = cc('"'),
	      Semicolon = cc(';'),
	      Space = cc(' '),
	      Tab = cc('\t'),
	      Tilde = cc('~'),
	      Underscore = cc('_'),
	      Zero = cc('\u0000');

	module.exports = function (cx, str) {
		// Lexing algorithm requires trailing newline.
		// Use a null-terminated string because it's faster than checking whether index === length.
		str = str + '\n\u0000';

		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		// Use these for debugging pos.
		/*
  const
  	checkPos = () => {
  		const p = getCorrectPos()
  		if (p.line !== line || p.column !== column)
  			throw new Error(`index: ${index}, wrong: ${Pos(line, column)}, right: ${p}`)
  	},
  	indexToPos = new Map(),
  	getCorrectPos = () => {
  		if (index === 0)
  			return Pos(StartLine, StartColumn)
  			let oldPos, oldIndex
  		for (oldIndex = index - 1; oldIndex > 0; oldIndex = oldIndex - 1) {
  			oldPos = indexToPos.get(oldIndex)
  			if (oldPos)
  				break
  		}
  		if (oldPos === undefined) {
  			assert(oldIndex === 0)
  			oldPos = Pos(StartLine, StartColumn)
  		}
  		let newLine = oldPos.line, newColumn = oldPos.column
  		for (; oldIndex < index; oldIndex = oldIndex + 1)
  			if (str.charCodeAt(oldIndex) === Newline) {
  				newLine = newLine + 1
  				newColumn = StartColumn
  			} else
  				newColumn = newColumn + 1
  			const p = Pos(newLine, newColumn)
  		indexToPos.set(index, p)
  		return p
  	}
  */

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return (0, _esastDistLoc.Pos)(line, column);
		},
		      loc = function () {
			return (0, _esastDistLoc.singleCharLoc)(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			return _skipWhile(function (_) {
				return _ !== Newline;
			});
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startColumn;
			const loc = function () {
				return (0, _Loc)((0, _esastDistLoc.Pos)(line, startColumn), pos());
			},
			      keyword = function (k) {
				return (0, _Token.Keyword)(loc(), k);
			},
			      gp = function (k) {
				return o((0, _GroupPre2)(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + (0, _CompileError.code)(lit);
				});
				return (0, _Token.TokenNumberLiteral)(loc(), num);
			};

			while (true) {
				startColumn = column;
				ch = eat();
				switch (ch) {
					case Zero:
						return;
					case N0:case N1:case N2:case N3:case N4:
					case N5:case N6:case N7:case N8:case N9:
						o(eatNumber());
						break;
					case OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + (0, _char.showChar)(ch);
						});
						return;
					case Space:
						cx.warnIf(peek() === Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case Dot:
						{
							const p = peek();
							if (p === Space || p === Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword(_Token.KW_ObjAssign));
								gp(_GroupPre.GP_Space);
							} else o((0, _Token.DotName)(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case Colon:
						o(keyword(_Token.KW_Type));
						break;
					case Tilde:
						if (tryEat(Bar)) {
							o(keyword(_Token.KW_GenFun));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword(_Token.KW_Lazy));
							break;
						}
						break;
					case Bar:
						o(keyword(_Token.KW_Fun));
						// First arg in its own spaced group
						gp(_GroupPre.GP_Space);
						break;
					case Underscore:
						o(keyword(_Token.KW_Focus));
						break;
					case Hash:
						if (!(tryEat(Space) || tryEat(Tab))) cx.fail(loc, function () {
							return '' + (0, _CompileError.code)('#') + ' must be followed by space or tab.}';
						});
						skipRestOfLine();
						break;
					case Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(Tab);
							cx.check(peek() !== Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case Quote:
						lexQuote(indent);
						break;
					case Ampersand:case Backslash:case Backtick:case Caret:
					case Comma:case Percent:case Semicolon:
						cx.fail(loc, 'Reserved character ' + (0, _char.showChar)(ch));
					case Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
					case Hyphen:
						if ((0, _char.isDigit)(peek())) {
							o(eatNumber());
							break;
						}
					// else fallthrough
					default:
						{
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);
							const k = (0, _Token.keywordKFromName)(name);
							if (k !== undefined) {
								if (k === _Token.KW_Region) skipRestOfLine();
								o(keyword(k));
							} else if (tryEat(Underscore)) o((0, _Token.CallOnFocus)(loc(), name));else {
								cx.check(!(0, _Lang.isReservedName)(name), pos, function () {
									return 'Reserved name ' + (0, _CompileError.code)(name);
								});
								o((0, _Token.Name)(loc(), name));
							}
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o((0, _GroupPre2)(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o((0, _GroupPre2)((0, _esastDistLoc.singleCharLoc)(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case Newline:
						{
							cx.check(prev !== Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							// Allow extra blank lines.
							const numNewlines = skipNewlines() + 1;
							const newIndent = skipWhileEquals(Tab);
							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, numNewlines + newIndent);
								(0, _UUtil.assert)(peek() === Newline);
								break eatChars;
							} else read = read + '\n'.repeat(numNewlines) + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o((0, _GroupPre2)(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case OpBrace:
					return '{';
				case LetterN:
					return '\n';
				case LetterT:
					return '\t';
				case Quote:
					return '"';
				case Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + (0, _char.showChar)(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBV0EsT0FBTSxFQUFFLEdBQUcsVUFBQSxFQUFFO1NBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFBQSxDQUFBO0FBQ2pDLE9BQ0MsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUNwRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQ3BFLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FBRSxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUN6RCxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztPQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO09BQUUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDekQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbkIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7T0FDcEIsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDbEIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7T0FDYixLQUFLLEdBQUcs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QTs7QUFFRCxRQUFNLFdBQVcsR0FBRyxVQUFBLEVBQUUsRUFBSTtBQUN6QixXQUFRLEVBQUU7QUFDVCxTQUFLLE9BQU87QUFBRSxZQUFPLEdBQUcsQ0FBQTtBQUFBLEFBQ3hCLFNBQUssT0FBTztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDekIsU0FBSyxPQUFPO0FBQUUsWUFBTyxJQUFJLENBQUE7QUFBQSxBQUN6QixTQUFLLEtBQUs7QUFBRSxZQUFPLEdBQUcsQ0FBQTtBQUFBLEFBQ3RCLFNBQUssU0FBUztBQUFFLFlBQU8sSUFBSSxDQUFBO0FBQUEsQUFDM0I7QUFBUyxPQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcseUJBQXVCLFVBOVdyQyxRQUFRLEVBOFdzQyxFQUFFLENBQUMsQ0FBRyxDQUFBO0FBQUEsSUFDMUQ7R0FDRCxDQUFBOztBQUVELFdBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNoQixTQUFPLEdBQUcsQ0FBQTtFQUNWIiwiZmlsZSI6Im1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9jLCB7IFBvcywgU3RhcnRMaW5lLCBTdGFydENvbHVtbiwgc2luZ2xlQ2hhckxvYyB9IGZyb20gJ2VzYXN0L2Rpc3QvTG9jJ1xuaW1wb3J0IHsgY29kZSB9IGZyb20gJy4uLy4uL0NvbXBpbGVFcnJvcidcbmltcG9ydCB7IGlzUmVzZXJ2ZWROYW1lIH0gZnJvbSAnLi4vTGFuZydcbmltcG9ydCB7IENhbGxPbkZvY3VzLCBEb3ROYW1lLCBLZXl3b3JkLCBUb2tlbk51bWJlckxpdGVyYWwsIE5hbWUsXG5cdGtleXdvcmRLRnJvbU5hbWUsXG5cdEtXX0ZvY3VzLCBLV19GdW4sIEtXX0dlbkZ1biwgS1dfTGF6eSwgS1dfT2JqQXNzaWduLCBLV19SZWdpb24sIEtXX1R5cGUgfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCBHcm91cFByZSwgeyBHUF9PcGVuUGFyZW4sIEdQX09wZW5CcmFja2V0LCBHUF9PcGVuQmxvY2ssIEdQX09wZW5RdW90ZSwgR1BfTGluZSxcblx0R1BfU3BhY2UsIEdQX0Nsb3NlUGFyZW4sIEdQX0Nsb3NlQnJhY2tldCwgR1BfQ2xvc2VCbG9jaywgR1BfQ2xvc2VRdW90ZX0gZnJvbSAnLi9Hcm91cFByZSdcbmltcG9ydCB7IHNob3dDaGFyLCBpc0RpZ2l0LCBpc05hbWVDaGFyYWN0ZXIsIGlzTnVtYmVyQ2hhcmFjdGVyIH0gZnJvbSAnLi9jaGFyJ1xuXG5jb25zdCBjYyA9IGNoID0+IGNoLmNoYXJDb2RlQXQoMClcbmNvbnN0XG5cdE4wID0gY2MoJzAnKSwgTjEgPSBjYygnMScpLCBOMiA9IGNjKCcyJyksIE4zID0gY2MoJzMnKSwgTjQgPSBjYygnNCcpLFxuXHRONSA9IGNjKCc1JyksIE42ID0gY2MoJzYnKSwgTjcgPSBjYygnNycpLCBOOCA9IGNjKCc4JyksIE45ID0gY2MoJzknKSxcblx0T3BQYXJlbiA9IGNjKCcoJyksIE9wQnJhY2tldCA9IGNjKCdbJyksIE9wQnJhY2UgPSBjYygneycpLFxuXHRDbFBhcmVuID0gY2MoJyknKSwgQ2xCcmFja2V0ID0gY2MoJ10nKSwgQ2xCcmFjZSA9IGNjKCd9JyksXG5cdEFtcGVyc2FuZCA9IGNjKCcmJyksXG5cdEJhY2tzbGFzaCA9IGNjKCdcXFxcJyksXG5cdEJhY2t0aWNrID0gY2MoJ2AnKSxcblx0QmFyID0gY2MoJ3wnKSxcblx0Q2FyZXQgPSBjYygnXicpLFxuXHRDb2xvbiA9IGNjKCc6JyksXG5cdENvbW1hID0gY2MoJywnKSxcblx0RG90ID0gY2MoJy4nKSxcblx0SGFzaCA9IGNjKCcjJyksXG5cdEh5cGhlbiA9IGNjKCctJyksXG5cdExldHRlck4gPSBjYygnbicpLFxuXHRMZXR0ZXJUID0gY2MoJ3QnKSxcblx0TmV3bGluZSA9IGNjKCdcXG4nKSxcblx0UGVyY2VudCA9IGNjKCclJyksXG5cdFF1b3RlID0gY2MoJ1wiJyksXG5cdFNlbWljb2xvbiA9IGNjKCc7JyksXG5cdFNwYWNlID0gY2MoJyAnKSxcblx0VGFiID0gY2MoJ1xcdCcpLFxuXHRUaWxkZSA9IGNjKCd+JyksXG5cdFVuZGVyc2NvcmUgPSBjYygnXycpLFxuXHRaZXJvID0gY2MoJ1xcMCcpXG5cbmV4cG9ydCBkZWZhdWx0IChjeCwgc3RyKSA9PiB7XG5cdC8vIExleGluZyBhbGdvcml0aG0gcmVxdWlyZXMgdHJhaWxpbmcgbmV3bGluZS5cblx0Ly8gVXNlIGEgbnVsbC10ZXJtaW5hdGVkIHN0cmluZyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gY2hlY2tpbmcgd2hldGhlciBpbmRleCA9PT0gbGVuZ3RoLlxuXHRzdHIgPSBzdHIgKyAnXFxuXFwwJ1xuXG5cdGNvbnN0IHJlcyA9IFsgXVxuXHRsZXQgbGluZSA9IFN0YXJ0TGluZVxuXHRsZXQgY29sdW1uID0gU3RhcnRDb2x1bW5cblx0bGV0IGluZGV4ID0gMFxuXG5cdC8vIFVzZSB0aGVzZSBmb3IgZGVidWdnaW5nIHBvcy5cblx0Lypcblx0Y29uc3Rcblx0XHRjaGVja1BvcyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHAgPSBnZXRDb3JyZWN0UG9zKClcblx0XHRcdGlmIChwLmxpbmUgIT09IGxpbmUgfHwgcC5jb2x1bW4gIT09IGNvbHVtbilcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBpbmRleDogJHtpbmRleH0sIHdyb25nOiAke1BvcyhsaW5lLCBjb2x1bW4pfSwgcmlnaHQ6ICR7cH1gKVxuXHRcdH0sXG5cdFx0aW5kZXhUb1BvcyA9IG5ldyBNYXAoKSxcblx0XHRnZXRDb3JyZWN0UG9zID0gKCkgPT4ge1xuXHRcdFx0aWYgKGluZGV4ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gUG9zKFN0YXJ0TGluZSwgU3RhcnRDb2x1bW4pXG5cblx0XHRcdGxldCBvbGRQb3MsIG9sZEluZGV4XG5cdFx0XHRmb3IgKG9sZEluZGV4ID0gaW5kZXggLSAxOyBvbGRJbmRleCA+IDA7IG9sZEluZGV4ID0gb2xkSW5kZXggLSAxKSB7XG5cdFx0XHRcdG9sZFBvcyA9IGluZGV4VG9Qb3MuZ2V0KG9sZEluZGV4KVxuXHRcdFx0XHRpZiAob2xkUG9zKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkUG9zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YXNzZXJ0KG9sZEluZGV4ID09PSAwKVxuXHRcdFx0XHRvbGRQb3MgPSBQb3MoU3RhcnRMaW5lLCBTdGFydENvbHVtbilcblx0XHRcdH1cblx0XHRcdGxldCBuZXdMaW5lID0gb2xkUG9zLmxpbmUsIG5ld0NvbHVtbiA9IG9sZFBvcy5jb2x1bW5cblx0XHRcdGZvciAoOyBvbGRJbmRleCA8IGluZGV4OyBvbGRJbmRleCA9IG9sZEluZGV4ICsgMSlcblx0XHRcdFx0aWYgKHN0ci5jaGFyQ29kZUF0KG9sZEluZGV4KSA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRcdG5ld0xpbmUgPSBuZXdMaW5lICsgMVxuXHRcdFx0XHRcdG5ld0NvbHVtbiA9IFN0YXJ0Q29sdW1uXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdG5ld0NvbHVtbiA9IG5ld0NvbHVtbiArIDFcblxuXHRcdFx0Y29uc3QgcCA9IFBvcyhuZXdMaW5lLCBuZXdDb2x1bW4pXG5cdFx0XHRpbmRleFRvUG9zLnNldChpbmRleCwgcClcblx0XHRcdHJldHVybiBwXG5cdFx0fVxuXHQqL1xuXG5cdGNvbnN0XG5cdFx0byA9IHQgPT4geyByZXMucHVzaCh0KSB9LFxuXG5cdFx0cG9zID0gKCkgPT4gUG9zKGxpbmUsIGNvbHVtbiksXG5cdFx0bG9jID0gKCkgPT4gc2luZ2xlQ2hhckxvYyhwb3MoKSksXG5cblx0XHRwcmV2ID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXggLSAxKSxcblx0XHRwZWVrID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXgpLFxuXG5cdFx0ZWF0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2ggPSBzdHIuY2hhckNvZGVBdChpbmRleClcblx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyAxXG5cdFx0XHRyZXR1cm4gY2hcblx0XHR9LFxuXHRcdHRyeUVhdCA9IGNoID0+IHtcblx0XHRcdGNvbnN0IGNhbkVhdCA9IHBlZWsoKSA9PT0gY2hcblx0XHRcdGlmIChjYW5FYXQpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0Y29sdW1uID0gY29sdW1uICsgMVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbkVhdFxuXHRcdH0sXG5cdFx0dHJ5RWF0TmV3bGluZSA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGNhbkVhdCA9IHBlZWsoKSA9PT0gTmV3bGluZVxuXHRcdFx0aWYgKGNhbkVhdCkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdFx0Y29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdH1cblx0XHRcdHJldHVybiBjYW5FYXRcblx0XHR9LFxuXG5cdFx0Ly8gQ2FsbGVyIG11c3QgZW5zdXJlIHRoYXQgYmFja2luZyB1cCBuQ2hhcnNUb0JhY2tVcCBjaGFyYWN0ZXJzIGJyaW5ncyB1cyB0byBvbGRQb3MuXG5cdFx0c3RlcEJhY2tNYW55ID0gKG9sZFBvcywgbkNoYXJzVG9CYWNrVXApID0+IHtcblx0XHRcdGluZGV4ID0gaW5kZXggLSBuQ2hhcnNUb0JhY2tVcFxuXHRcdFx0bGluZSA9IG9sZFBvcy5saW5lXG5cdFx0XHRjb2x1bW4gPSBvbGRQb3MuY29sdW1uXG5cdFx0fSxcblxuXHRcdF9za2lwV2hpbGUgPSBwcmVkID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuXHRcdFx0d2hpbGUgKHByZWQocGVlaygpKSlcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdGNvbnN0IGRpZmYgPSBpbmRleCAtIHN0YXJ0SW5kZXhcblx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIGRpZmZcblx0XHRcdHJldHVybiBkaWZmXG5cdFx0fSxcblx0XHR0YWtlV2hpbGVXaXRoUHJldiA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHRfc2tpcFdoaWxlKHByZWQpXG5cdFx0XHRyZXR1cm4gc3RyLnNsaWNlKHN0YXJ0SW5kZXggLSAxLCBpbmRleClcblx0XHR9LFxuXHRcdHRha2VXaGlsZSA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHRfc2tpcFdoaWxlKHByZWQpXG5cdFx0XHRyZXR1cm4gc3RyLnNsaWNlKHN0YXJ0SW5kZXgsIGluZGV4KVxuXHRcdH0sXG5cdFx0c2tpcFdoaWxlRXF1YWxzID0gY2ggPT4gX3NraXBXaGlsZShfID0+IF8gPT09IGNoKSxcblxuXHRcdC8vIENhbGxlZCBhZnRlciBzZWVpbmcgdGhlIGZpcnN0IG5ld2xpbmUuXG5cdFx0c2tpcE5ld2xpbmVzID0gKCkgPT4ge1xuXHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHRjb25zdCBzdGFydExpbmUgPSBsaW5lXG5cdFx0XHR3aGlsZSAocGVlaygpID09PSBOZXdsaW5lKSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0fVxuXHRcdFx0Y29sdW1uID0gU3RhcnRDb2x1bW5cblx0XHRcdHJldHVybiBsaW5lIC0gc3RhcnRMaW5lXG5cdFx0fSxcblxuXHRcdHNraXBSZXN0T2ZMaW5lID0gKCkgPT5cblx0XHRcdF9za2lwV2hpbGUoXyA9PiBfICE9PSBOZXdsaW5lKVxuXG5cdGNvbnN0IHVuZ3JvdXBlZCA9IGlzSW5RdW90ZSA9PiB7XG5cdFx0bGV0IGluZGVudCA9IDBcblxuXHRcdGxldCBjaCwgc3RhcnRDb2x1bW5cblx0XHRjb25zdFxuXHRcdFx0bG9jID0gKCkgPT4gTG9jKFBvcyhsaW5lLCBzdGFydENvbHVtbiksIHBvcygpKSxcblx0XHRcdGtleXdvcmQgPSBrID0+IEtleXdvcmQobG9jKCksIGspLFxuXHRcdFx0Z3AgPSBrID0+IG8oR3JvdXBQcmUobG9jKCksIGspKSxcblx0XHRcdGVhdE51bWJlciA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgbGl0ID0gdGFrZVdoaWxlV2l0aFByZXYoaXNOdW1iZXJDaGFyYWN0ZXIpXG5cdFx0XHRcdGNvbnN0IG51bSA9IE51bWJlcihsaXQpXG5cdFx0XHRcdGN4LmNoZWNrKCFOdW1iZXIuaXNOYU4obnVtKSwgcG9zLCAoKSA9PlxuXHRcdFx0XHRcdGBJbnZhbGlkIG51bWJlciBsaXRlcmFsICR7Y29kZShsaXQpfWApXG5cdFx0XHRcdHJldHVybiBUb2tlbk51bWJlckxpdGVyYWwobG9jKCksIG51bSlcblx0XHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRzdGFydENvbHVtbiA9IGNvbHVtblxuXHRcdFx0Y2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIFplcm86XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGNhc2UgTjA6IGNhc2UgTjE6IGNhc2UgTjI6IGNhc2UgTjM6IGNhc2UgTjQ6XG5cdFx0XHRcdGNhc2UgTjU6IGNhc2UgTjY6IGNhc2UgTjc6IGNhc2UgTjg6IGNhc2UgTjk6XG5cdFx0XHRcdFx0byhlYXROdW1iZXIoKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE9wUGFyZW46XG5cdFx0XHRcdFx0Z3AoR1BfT3BlblBhcmVuKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgT3BCcmFja2V0OlxuXHRcdFx0XHRcdGdwKEdQX09wZW5CcmFja2V0KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xQYXJlbjpcblx0XHRcdFx0XHRncChHUF9DbG9zZVBhcmVuKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xCcmFja2V0OlxuXHRcdFx0XHRcdGdwKEdQX0Nsb3NlQnJhY2tldClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsQnJhY2U6XG5cdFx0XHRcdFx0Y3guY2hlY2soaXNJblF1b3RlLCBsb2MsICgpID0+IGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0Y2FzZSBTcGFjZTpcblx0XHRcdFx0XHRjeC53YXJuSWYocGVlaygpID09PSBTcGFjZSwgbG9jLCAnTXVsdGlwbGUgc3BhY2VzIGluIGEgcm93Jylcblx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIERvdDoge1xuXHRcdFx0XHRcdGNvbnN0IHAgPSBwZWVrKClcblx0XHRcdFx0XHRpZiAocCA9PT0gU3BhY2UgfHwgcCA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRcdFx0Ly8gT2JqTGl0IGFzc2lnbiBpbiBpdHMgb3duIHNwYWNlZCBncm91cC5cblx0XHRcdFx0XHRcdC8vIFdlIGNhbid0IGp1c3QgY3JlYXRlIGEgbmV3IEdyb3VwIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvXG5cdFx0XHRcdFx0XHQvLyBlbnN1cmUgaXQncyBub3QgcGFydCBvZiB0aGUgcHJlY2VkaW5nIG9yIGZvbGxvd2luZyBzcGFjZWQgZ3JvdXAuXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19PYmpBc3NpZ24pKVxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRvKERvdE5hbWUoXG5cdFx0XHRcdFx0XHRcdGxvYygpLFxuXHRcdFx0XHRcdFx0XHQvLyArMSBmb3IgdGhlIGRvdCB3ZSBqdXN0IHNraXBwZWQuXG5cdFx0XHRcdFx0XHRcdHNraXBXaGlsZUVxdWFscyhEb3QpICsgMSxcblx0XHRcdFx0XHRcdFx0dGFrZVdoaWxlKGlzTmFtZUNoYXJhY3RlcikpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBDb2xvbjpcblx0XHRcdFx0XHRvKGtleXdvcmQoS1dfVHlwZSkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBUaWxkZTpcblx0XHRcdFx0XHRpZiAodHJ5RWF0KEJhcikpIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZChLV19HZW5GdW4pKVxuXHRcdFx0XHRcdFx0Z3AoR1BfU3BhY2UpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoS1dfTGF6eSkpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEJhcjpcblx0XHRcdFx0XHRvKGtleXdvcmQoS1dfRnVuKSlcblx0XHRcdFx0XHQvLyBGaXJzdCBhcmcgaW4gaXRzIG93biBzcGFjZWQgZ3JvdXBcblx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFVuZGVyc2NvcmU6XG5cdFx0XHRcdFx0byhrZXl3b3JkKEtXX0ZvY3VzKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEhhc2g6XG5cdFx0XHRcdFx0aWYgKCEodHJ5RWF0KFNwYWNlKSB8fCB0cnlFYXQoVGFiKSkpXG5cdFx0XHRcdFx0XHRjeC5mYWlsKGxvYywgKCkgPT4gYCR7Y29kZSgnIycpfSBtdXN0IGJlIGZvbGxvd2VkIGJ5IHNwYWNlIG9yIHRhYi59YClcblx0XHRcdFx0XHRza2lwUmVzdE9mTGluZSgpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2soIWlzSW5RdW90ZSwgbG9jLCAnUXVvdGUgaW50ZXJwb2xhdGlvbiBjYW5ub3QgY29udGFpbiBuZXdsaW5lJylcblx0XHRcdFx0XHRjeC5jaGVjayhwcmV2KCkgIT09IFNwYWNlLCBsb2MsICdMaW5lIGVuZHMgaW4gYSBzcGFjZScpXG5cblx0XHRcdFx0XHQvLyBTa2lwIGFueSBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRza2lwTmV3bGluZXMoKVxuXHRcdFx0XHRcdGNvbnN0IG9sZEluZGVudCA9IGluZGVudFxuXHRcdFx0XHRcdGluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRcdFx0Y3guY2hlY2socGVlaygpICE9PSBTcGFjZSwgcG9zLCAnTGluZSBiZWdpbnMgaW4gYSBzcGFjZScpXG5cdFx0XHRcdFx0aWYgKGluZGVudCA8PSBvbGRJbmRlbnQpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBpbmRlbnQ7IGkgPCBvbGRJbmRlbnQ7IGkgPSBpICsgMSlcblx0XHRcdFx0XHRcdFx0Z3AoR1BfQ2xvc2VCbG9jaylcblx0XHRcdFx0XHRcdGdwKEdQX0xpbmUpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN4LmNoZWNrKGluZGVudCA9PT0gb2xkSW5kZW50ICsgMSwgbG9jLCAnTGluZSBpcyBpbmRlbnRlZCBtb3JlIHRoYW4gb25jZScpXG5cdFx0XHRcdFx0XHRncChHUF9PcGVuQmxvY2spXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBRdW90ZTpcblx0XHRcdFx0XHRsZXhRdW90ZShpbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBBbXBlcnNhbmQ6IGNhc2UgQmFja3NsYXNoOiBjYXNlIEJhY2t0aWNrOiBjYXNlIENhcmV0OlxuXHRcdFx0XHRjYXNlIENvbW1hOiBjYXNlIFBlcmNlbnQ6IGNhc2UgU2VtaWNvbG9uOlxuXHRcdFx0XHRcdGN4LmZhaWwobG9jLCBgUmVzZXJ2ZWQgY2hhcmFjdGVyICR7c2hvd0NoYXIoY2gpfWApXG5cdFx0XHRcdGNhc2UgVGFiOlxuXHRcdFx0XHRcdGN4LmZhaWwobG9jKCksICdUYWIgbWF5IG9ubHkgYmUgdXNlZCB0byBpbmRlbnQnKVxuXHRcdFx0XHRjYXNlIEh5cGhlbjpcblx0XHRcdFx0XHRpZiAoaXNEaWdpdChwZWVrKCkpKSB7XG5cdFx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0Ly8gQWxsIG90aGVyIGNoYXJhY3RlcnMgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYSBjYXNlIGFib3ZlLlxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0YWtlV2hpbGVXaXRoUHJldihpc05hbWVDaGFyYWN0ZXIpXG5cdFx0XHRcdFx0Y29uc3QgayA9IGtleXdvcmRLRnJvbU5hbWUobmFtZSlcblx0XHRcdFx0XHRpZiAoayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PT0gS1dfUmVnaW9uKVxuXHRcdFx0XHRcdFx0XHRza2lwUmVzdE9mTGluZSgpXG5cdFx0XHRcdFx0XHRvKGtleXdvcmQoaykpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0cnlFYXQoVW5kZXJzY29yZSkpXG5cdFx0XHRcdFx0XHRvKENhbGxPbkZvY3VzKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGN4LmNoZWNrKCFpc1Jlc2VydmVkTmFtZShuYW1lKSwgcG9zLCAoKSA9PiBgUmVzZXJ2ZWQgbmFtZSAke2NvZGUobmFtZSl9YClcblx0XHRcdFx0XHRcdG8oTmFtZShsb2MoKSwgbmFtZSkpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgbGV4UXVvdGUgPSBpbmRlbnQgPT4ge1xuXHRcdGNvbnN0IHF1b3RlSW5kZW50ID0gaW5kZW50ICsgMVxuXG5cdFx0Y29uc3QgaXNJbmRlbnRlZCA9IHRyeUVhdE5ld2xpbmUoKVxuXHRcdGlmIChpc0luZGVudGVkKSB7XG5cdFx0XHRjb25zdCBhY3R1YWxJbmRlbnQgPSBza2lwV2hpbGVFcXVhbHMoVGFiKVxuXHRcdFx0Y3guY2hlY2soYWN0dWFsSW5kZW50ID09PSBxdW90ZUluZGVudCwgcG9zLFxuXHRcdFx0XHQnSW5kZW50ZWQgcXVvdGUgbXVzdCBoYXZlIGV4YWN0bHkgb25lIG1vcmUgaW5kZW50IHRoYW4gcHJldmlvdXMgbGluZS4nKVxuXHRcdH1cblxuXHRcdGxldCByZWFkID0gJydcblxuXHRcdGNvbnN0IHlpZWxkUmVhZCA9ICgpID0+IHtcblx0XHRcdGlmIChyZWFkICE9PSAnJykge1xuXHRcdFx0XHRvKHJlYWQpXG5cdFx0XHRcdHJlYWQgPSAnJ1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX09wZW5RdW90ZSkpXG5cblx0XHRlYXRDaGFyczogd2hpbGUgKHRydWUpIHtcblx0XHRcdGNvbnN0IGNoUG9zID0gcG9zKClcblx0XHRcdGNvbnN0IGNoID0gZWF0KClcblx0XHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdFx0Y2FzZSBCYWNrc2xhc2g6IHtcblx0XHRcdFx0XHRyZWFkID0gcmVhZCArIHF1b3RlRXNjYXBlKGVhdCgpKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBPcEJyYWNlOiB7XG5cdFx0XHRcdFx0eWllbGRSZWFkKClcblx0XHRcdFx0XHQvLyBXZSBjYW4ndCBjcmVhdGUgYSBHcm91cCBub3cgYmVjYXVzZSB0aGVyZSBtYXkgYmUgb3RoZXIgR3JvdXBQcmVfcyBpbnNpZGUuXG5cdFx0XHRcdFx0byhHcm91cFByZShzaW5nbGVDaGFyTG9jKGNoUG9zKSwgR1BfT3BlblBhcmVuKSlcblx0XHRcdFx0XHR1bmdyb3VwZWQodHJ1ZSlcblx0XHRcdFx0XHRvKEdyb3VwUHJlKGxvYygpLCBHUF9DbG9zZVBhcmVuKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgTmV3bGluZToge1xuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYgIT09IFNwYWNlLCBjaFBvcywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRjeC5jaGVjayhpc0luZGVudGVkLCBjaFBvcywgJ1VuY2xvc2VkIHF1b3RlLicpXG5cdFx0XHRcdFx0Ly8gQWxsb3cgZXh0cmEgYmxhbmsgbGluZXMuXG5cdFx0XHRcdFx0Y29uc3QgbnVtTmV3bGluZXMgPSBza2lwTmV3bGluZXMoKSArIDFcblx0XHRcdFx0XHRjb25zdCBuZXdJbmRlbnQgPSBza2lwV2hpbGVFcXVhbHMoVGFiKVxuXHRcdFx0XHRcdGlmIChuZXdJbmRlbnQgPCBxdW90ZUluZGVudCkge1xuXHRcdFx0XHRcdFx0Ly8gSW5kZW50ZWQgcXVvdGUgc2VjdGlvbiBpcyBvdmVyLlxuXHRcdFx0XHRcdFx0Ly8gVW5kbyByZWFkaW5nIHRoZSB0YWJzIGFuZCBuZXdsaW5lLlxuXHRcdFx0XHRcdFx0c3RlcEJhY2tNYW55KGNoUG9zLCBudW1OZXdsaW5lcyArIG5ld0luZGVudClcblx0XHRcdFx0XHRcdGFzc2VydChwZWVrKCkgPT09IE5ld2xpbmUpXG5cdFx0XHRcdFx0XHRicmVhayBlYXRDaGFyc1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0cmVhZCA9IHJlYWQgK1xuXHRcdFx0XHRcdFx0XHQnXFxuJy5yZXBlYXQobnVtTmV3bGluZXMpICsgJ1xcdCcucmVwZWF0KG5ld0luZGVudCAtIHF1b3RlSW5kZW50KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBRdW90ZTpcblx0XHRcdFx0XHRpZiAoIWlzSW5kZW50ZWQpXG5cdFx0XHRcdFx0XHRicmVhayBlYXRDaGFyc1xuXHRcdFx0XHRcdC8vIEVsc2UgZmFsbHRocm91Z2hcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZWFkID0gcmVhZCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eWllbGRSZWFkKClcblx0XHRvKEdyb3VwUHJlKGxvYygpLCBHUF9DbG9zZVF1b3RlKSlcblx0fVxuXG5cdGNvbnN0IHF1b3RlRXNjYXBlID0gY2ggPT4ge1xuXHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdGNhc2UgT3BCcmFjZTogcmV0dXJuICd7J1xuXHRcdFx0Y2FzZSBMZXR0ZXJOOiByZXR1cm4gJ1xcbidcblx0XHRcdGNhc2UgTGV0dGVyVDogcmV0dXJuICdcXHQnXG5cdFx0XHRjYXNlIFF1b3RlOiByZXR1cm4gJ1wiJ1xuXHRcdFx0Y2FzZSBCYWNrc2xhc2g6IHJldHVybiAnXFxcXCdcblx0XHRcdGRlZmF1bHQ6IGN4LmZhaWwocG9zLCBgTm8gbmVlZCB0byBlc2NhcGUgJHtzaG93Q2hhcihjaCl9YClcblx0XHR9XG5cdH1cblxuXHR1bmdyb3VwZWQoZmFsc2UpXG5cdHJldHVybiByZXNcbn1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9