if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', 'esast/dist/Loc', '../../CompileError', '../Lang', '../Token', '../U/util', './GroupPre', './char'], function (exports, module, _esastDistLoc, _CompileError, _Lang, _Token, _UUtil, _GroupPre, _char) {
	'use strict';

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };

	var _Loc = _interopRequire(_esastDistLoc);

	var _GroupPre2 = _interopRequire(_GroupPre);

	module.exports = function (cx, str) {
		const res = [];
		let line = _esastDistLoc.StartLine;
		let column = _esastDistLoc.StartColumn;
		let index = 0;

		const o = function (t) {
			res.push(t);
		},
		      pos = function () {
			return _esastDistLoc.Pos(line, column);
		},
		      loc = function () {
			return _esastDistLoc.singleCharLoc(pos());
		},
		      prev = function () {
			return str.charCodeAt(index - 1);
		},
		      peek = function () {
			return str.charCodeAt(index);
		},
		      eat = function () {
			const ch = str.charCodeAt(index);
			index = index + 1;
			column = column + 1;
			return ch;
		},
		      tryEat = function (ch) {
			const canEat = peek() === ch;
			if (canEat) {
				index = index + 1;
				column = column + 1;
			}
			return canEat;
		},
		      tryEatNewline = function () {
			const canEat = peek() === _char.Newline;
			if (canEat) {
				index = index + 1;
				line = line + 1;
				column = _esastDistLoc.StartColumn;
			}
			return canEat;
		},
		     

		// Caller must ensure that backing up nCharsToBackUp characters brings us to oldPos.
		stepBackMany = function (oldPos, nCharsToBackUp) {
			index = index - nCharsToBackUp;
			line = oldPos.line;
			column = oldPos.column;
		},
		      _skipWhile = function (pred) {
			const startIndex = index;
			while (pred(peek())) index = index + 1;
			const diff = index - startIndex;
			column = column + diff;
			return diff;
		},
		      takeWhileWithPrev = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex - 1, index);
		},
		      takeWhile = function (pred) {
			const startIndex = index;
			_skipWhile(pred);
			return str.slice(startIndex, index);
		},
		      skipWhileEquals = function (ch) {
			return _skipWhile(function (_) {
				return _ === ch;
			});
		},
		     

		// Called after seeing the first newline.
		skipNewlines = function () {
			line = line + 1;
			const startLine = line;
			while (peek() === _char.Newline) {
				index = index + 1;
				line = line + 1;
			}
			column = _esastDistLoc.StartColumn;
			return line - startLine;
		},
		      skipRestOfLine = function () {
			while (peek() !== _char.Newline) index = index + 1;
		};

		const ungrouped = function (isInQuote) {
			let indent = 0;

			let ch, startLine, startColumn;
			const loc = function () {
				return _Loc(_esastDistLoc.Pos(startLine, startColumn), pos());
			},
			      keyword = function (k) {
				return _Token.Keyword(loc(), k);
			},
			      gp = function (k) {
				return o(_GroupPre2(loc(), k));
			},
			      eatNumber = function () {
				const lit = takeWhileWithPrev(_char.isNumberCharacter);
				const num = Number(lit);
				cx.check(!Number.isNaN(num), pos, function () {
					return 'Invalid number literal ' + _CompileError.code(lit);
				});
				return _Token.TokenNumberLiteral(loc(), num);
			};

			while (index !== str.length) {
				startLine = line;
				startColumn = column;

				ch = eat();
				switch (ch) {
					case _char.N0:case _char.N1:case _char.N2:case _char.N3:case _char.N4:
					case _char.N5:case _char.N6:case _char.N7:case _char.N8:case _char.N9:
						o(eatNumber());
						break;
					case _char.OpParen:
						gp(_GroupPre.GP_OpenParen);
						break;
					case _char.OpBracket:
						gp(_GroupPre.GP_OpenBracket);
						break;
					case _char.ClParen:
						gp(_GroupPre.GP_CloseParen);
						break;
					case _char.ClBracket:
						gp(_GroupPre.GP_CloseBracket);
						break;
					case _char.ClBrace:
						cx.check(isInQuote, loc, function () {
							return 'Reserved character ' + _char.showChar(ch);
						});
						return;
					case _char.Space:
						cx.warnIf(peek() === _char.Space, loc, 'Multiple spaces in a row');
						gp(_GroupPre.GP_Space);
						break;
					case _char.Dot:
						{
							const p = peek();
							if (p === _char.Space || p === _char.Newline) {
								// ObjLit assign in its own spaced group.
								// We can't just create a new Group here because we want to
								// ensure it's not part of the preceding or following spaced group.
								gp(_GroupPre.GP_Space);
								o(keyword('. '));
								gp(_GroupPre.GP_Space);
							} else o(_Token.DotName(loc(),
							// +1 for the dot we just skipped.
							skipWhileEquals(_char.Dot) + 1, takeWhile(_char.isNameCharacter)));
							break;
						}
					case _char.Colon:
						o(keyword(':'));
						break;
					case _char.Tilde:
						if (tryEat(_char.Bar)) {
							o(keyword('~|'));
							gp(_GroupPre.GP_Space);
							break;
						} else {
							o(keyword('~'));
							break;
						}
						break;
					case _char.Bar:
						// First arg in its own spaced group
						o(keyword('|'));
						gp(_GroupPre.GP_Space);
						break;
					case _char.Underscore:
						o(keyword('_'));
						break;
					case _char.Hash:
						skipRestOfLine();
						break;
					case _char.Newline:
						{
							cx.check(!isInQuote, loc, 'Quote interpolation cannot contain newline');
							cx.check(prev() !== _char.Space, loc, 'Line ends in a space');

							// Skip any blank lines.
							skipNewlines();
							const oldIndent = indent;
							indent = skipWhileEquals(_char.Tab);
							cx.check(peek() !== _char.Space, pos, 'Line begins in a space');
							if (indent <= oldIndent) {
								for (let i = indent; i < oldIndent; i = i + 1) gp(_GroupPre.GP_CloseBlock);
								gp(_GroupPre.GP_Line);
							} else {
								cx.check(indent === oldIndent + 1, loc, 'Line is indented more than once');
								gp(_GroupPre.GP_OpenBlock);
							}
							break;
						}
					case _char.Tab:
						cx.fail(loc(), 'Tab may only be used to indent');
						break;
					case _char.Quote:
						lexQuote(indent);
						break;
					case _char.Hyphen:
						if (_char.isDigit(peek())) {
							o(eatNumber());
							break;
						}
					// Else fallthrough
					default:
						{
							cx.check(!_char.isReservedCharacter(ch), loc, function () {
								return 'Reserved character ' + _char.showChar(ch);
							});
							// All other characters should be handled in a case above.
							const name = takeWhileWithPrev(_char.isNameCharacter);
							switch (name) {
								case 'region':
									// Rest of line is a comment.
									skipRestOfLine();
									o(keyword('region'));
									break;
								default:
									if (tryEat(_char.Underscore)) o(_Token.CallOnFocus(loc(), name));else if (_Lang.AllKeywords.has(name)) o(keyword(name));else if (_Lang.ReservedWords.has(name)) cx.fail(loc, 'Reserved word ' + _CompileError.code(name));else o(_Token.Name(loc(), name));
							}
						}
				}
			}
		};

		const lexQuote = function (indent) {
			const quoteIndent = indent + 1;

			const isIndented = tryEatNewline();
			if (isIndented) {
				const actualIndent = skipWhileEquals(_char.Tab);
				cx.check(actualIndent === quoteIndent, pos, 'Indented quote must have exactly one more indent than previous line.');
			}

			let read = '';

			const yieldRead = function () {
				if (read !== '') {
					o(read);
					read = '';
				}
			};

			o(_GroupPre2(loc(), _GroupPre.GP_OpenQuote));

			eatChars: while (true) {
				const chPos = pos();
				const ch = eat();
				switch (ch) {
					case _char.Backslash:
						{
							read = read + quoteEscape(eat());
							break;
						}
					case _char.OpBrace:
						{
							yieldRead();
							// We can't create a Group now because there may be other GroupPre_s inside.
							o(_GroupPre2(_esastDistLoc.singleCharLoc(chPos), _GroupPre.GP_OpenParen));
							ungrouped(true);
							o(_GroupPre2(loc(), _GroupPre.GP_CloseParen));
							break;
						}
					case _char.Newline:
						{
							cx.check(prev !== _char.Space, chPos, 'Line ends in a space');
							cx.check(isIndented, chPos, 'Unclosed quote.');
							let newIndent = skipWhileEquals(_char.Tab);

							let extraNewlines = '';
							// Allow blank lines.
							if (newIndent === 0) {
								extraNewlines = '\n'.repeat(skipNewlines());
								newIndent = skipWhileEquals(_char.Tab);
							}

							if (newIndent < quoteIndent) {
								// Indented quote section is over.
								// Undo reading the tabs and newline.
								stepBackMany(chPos, newIndent + 1);
								_UUtil.assert(peek() === _char.Newline);
								break eatChars;
							} else read = read + extraNewlines + '\n' + '\t'.repeat(newIndent - quoteIndent);
							break;
						}
					case _char.Quote:
						if (!isIndented) break eatChars;
					// Else fallthrough
					default:
						read = read + String.fromCharCode(ch);
				}
			}

			yieldRead();
			o(_GroupPre2(loc(), _GroupPre.GP_CloseQuote));
		};

		const quoteEscape = function (ch) {
			switch (ch) {
				case _char.OpBrace:
					return '{';
				case _char.LetterN:
					return '\n';
				case _char.LetterT:
					return '\t';
				case _char.Quote:
					return '"';
				case _char.Backslash:
					return '\\';
				default:
					cx.fail(pos, 'No need to escape ' + _char.showChar(ch));
			}
		};

		ungrouped(false);
		return res;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O2tCQVllLFVBQUMsRUFBRSxFQUFFLEdBQUcsRUFBSztBQUMzQixRQUFNLEdBQUcsR0FBRyxFQUFHLENBQUE7QUFDZixNQUFJLElBQUksaUJBZFUsU0FBUyxBQWNQLENBQUE7QUFDcEIsTUFBSSxNQUFNLGlCQWZtQixXQUFXLEFBZWhCLENBQUE7QUFDeEIsTUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBOztBQUViLFFBQ0MsQ0FBQyxHQUFHLFVBQUEsQ0FBQyxFQUFJO0FBQUUsTUFBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUFFO1FBRXhCLEdBQUcsR0FBRztVQUFNLGNBckJBLEdBQUcsQ0FxQkMsSUFBSSxFQUFFLE1BQU0sQ0FBQztHQUFBO1FBQzdCLEdBQUcsR0FBRztVQUFNLGNBdEI2QixhQUFhLENBc0I1QixHQUFHLEVBQUUsQ0FBQztHQUFBO1FBRWhDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztHQUFBO1FBQ3RDLElBQUksR0FBRztVQUFNLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO0dBQUE7UUFFbEMsR0FBRyxHQUFHLFlBQU07QUFDWCxTQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ2hDLFFBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0FBQ2pCLFNBQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ25CLFVBQU8sRUFBRSxDQUFBO0dBQ1Q7UUFDRCxNQUFNLEdBQUcsVUFBQSxFQUFFLEVBQUk7QUFDZCxTQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDNUIsT0FBSSxNQUFNLEVBQUU7QUFDWCxTQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtBQUNq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cGlsZS9wcml2YXRlL2xleC91bmdyb3VwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9jLCB7IFBvcywgU3RhcnRMaW5lLCBTdGFydENvbHVtbiwgc2luZ2xlQ2hhckxvYyB9IGZyb20gJ2VzYXN0L2Rpc3QvTG9jJ1xuaW1wb3J0IHsgY29kZSB9IGZyb20gJy4uLy4uL0NvbXBpbGVFcnJvcidcbmltcG9ydCB7IEFsbEtleXdvcmRzLCBSZXNlcnZlZFdvcmRzIH0gZnJvbSAnLi4vTGFuZydcbmltcG9ydCB7IENhbGxPbkZvY3VzLCBEb3ROYW1lLCBLZXl3b3JkLCBUb2tlbk51bWJlckxpdGVyYWwsIE5hbWUgfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL1UvdXRpbCdcbmltcG9ydCBHcm91cFByZSwgeyBHUF9PcGVuUGFyZW4sIEdQX09wZW5CcmFja2V0LCBHUF9PcGVuQmxvY2ssIEdQX09wZW5RdW90ZSwgR1BfTGluZSxcblx0R1BfU3BhY2UsIEdQX0Nsb3NlUGFyZW4sIEdQX0Nsb3NlQnJhY2tldCwgR1BfQ2xvc2VCbG9jaywgR1BfQ2xvc2VRdW90ZX0gZnJvbSAnLi9Hcm91cFByZSdcbmltcG9ydCB7IHNob3dDaGFyLCBOMCwgTjEsIE4yLCBOMywgTjQsIE41LCBONiwgTjcsIE44LCBOOSxcblx0T3BQYXJlbiwgT3BCcmFja2V0LCBPcEJyYWNlLCBDbFBhcmVuLCBDbEJyYWNrZXQsIENsQnJhY2UsIFNwYWNlLCBEb3QsIENvbG9uLCBUaWxkZSwgQmFyLFxuXHRVbmRlcnNjb3JlLCBCYWNrc2xhc2gsIEhhc2gsIE5ld2xpbmUsIFF1b3RlLCBUYWIsIEh5cGhlbiwgTGV0dGVyTiwgTGV0dGVyVCxcblx0aXNEaWdpdCwgaXNOYW1lQ2hhcmFjdGVyLCBpc051bWJlckNoYXJhY3RlciwgaXNSZXNlcnZlZENoYXJhY3RlciB9IGZyb20gJy4vY2hhcidcblxuZXhwb3J0IGRlZmF1bHQgKGN4LCBzdHIpID0+IHtcblx0Y29uc3QgcmVzID0gWyBdXG5cdGxldCBsaW5lID0gU3RhcnRMaW5lXG5cdGxldCBjb2x1bW4gPSBTdGFydENvbHVtblxuXHRsZXQgaW5kZXggPSAwXG5cblx0Y29uc3Rcblx0XHRvID0gdCA9PiB7IHJlcy5wdXNoKHQpIH0sXG5cblx0XHRwb3MgPSAoKSA9PiBQb3MobGluZSwgY29sdW1uKSxcblx0XHRsb2MgPSAoKSA9PiBzaW5nbGVDaGFyTG9jKHBvcygpKSxcblxuXHRcdHByZXYgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCAtIDEpLFxuXHRcdHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCksXG5cblx0XHRlYXQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBjaCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KVxuXHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdGNvbHVtbiA9IGNvbHVtbiArIDFcblx0XHRcdHJldHVybiBjaFxuXHRcdH0sXG5cdFx0dHJ5RWF0ID0gY2ggPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBjaFxuXHRcdFx0aWYgKGNhbkVhdCkge1xuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW4gKyAxXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FuRWF0XG5cdFx0fSxcblx0XHR0cnlFYXROZXdsaW5lID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2FuRWF0ID0gcGVlaygpID09PSBOZXdsaW5lXG5cdFx0XHRpZiAoY2FuRWF0KSB7XG5cdFx0XHRcdGluZGV4ID0gaW5kZXggKyAxXG5cdFx0XHRcdGxpbmUgPSBsaW5lICsgMVxuXHRcdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbkVhdFxuXHRcdH0sXG5cblx0XHQvLyBDYWxsZXIgbXVzdCBlbnN1cmUgdGhhdCBiYWNraW5nIHVwIG5DaGFyc1RvQmFja1VwIGNoYXJhY3RlcnMgYnJpbmdzIHVzIHRvIG9sZFBvcy5cblx0XHRzdGVwQmFja01hbnkgPSAob2xkUG9zLCBuQ2hhcnNUb0JhY2tVcCkgPT4ge1xuXHRcdFx0aW5kZXggPSBpbmRleCAtIG5DaGFyc1RvQmFja1VwXG5cdFx0XHRsaW5lID0gb2xkUG9zLmxpbmVcblx0XHRcdGNvbHVtbiA9IG9sZFBvcy5jb2x1bW5cblx0XHR9LFxuXG5cdFx0X3NraXBXaGlsZSA9IHByZWQgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG5cdFx0XHR3aGlsZSAocHJlZChwZWVrKCkpKVxuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdFx0Y29uc3QgZGlmZiA9IGluZGV4IC0gc3RhcnRJbmRleFxuXHRcdFx0Y29sdW1uID0gY29sdW1uICsgZGlmZlxuXHRcdFx0cmV0dXJuIGRpZmZcblx0XHR9LFxuXHRcdHRha2VXaGlsZVdpdGhQcmV2ID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCAtIDEsIGluZGV4KVxuXHRcdH0sXG5cdFx0dGFrZVdoaWxlID0gcHJlZCA9PiB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcblx0XHRcdF9za2lwV2hpbGUocHJlZClcblx0XHRcdHJldHVybiBzdHIuc2xpY2Uoc3RhcnRJbmRleCwgaW5kZXgpXG5cdFx0fSxcblx0XHRza2lwV2hpbGVFcXVhbHMgPSBjaCA9PiBfc2tpcFdoaWxlKF8gPT4gXyA9PT0gY2gpLFxuXG5cdFx0Ly8gQ2FsbGVkIGFmdGVyIHNlZWluZyB0aGUgZmlyc3QgbmV3bGluZS5cblx0XHRza2lwTmV3bGluZXMgPSAoKSA9PiB7XG5cdFx0XHRsaW5lID0gbGluZSArIDFcblx0XHRcdGNvbnN0IHN0YXJ0TGluZSA9IGxpbmVcblx0XHRcdHdoaWxlIChwZWVrKCkgPT09IE5ld2xpbmUpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleCArIDFcblx0XHRcdFx0bGluZSA9IGxpbmUgKyAxXG5cdFx0XHR9XG5cdFx0XHRjb2x1bW4gPSBTdGFydENvbHVtblxuXHRcdFx0cmV0dXJuIGxpbmUgLSBzdGFydExpbmVcblx0XHR9LFxuXG5cdFx0c2tpcFJlc3RPZkxpbmUgPSAoKSA9PiB7XG5cdFx0XHR3aGlsZSAocGVlaygpICE9PSBOZXdsaW5lKVxuXHRcdFx0XHRpbmRleCA9IGluZGV4ICsgMVxuXHRcdH1cblxuXHRjb25zdCB1bmdyb3VwZWQgPSBpc0luUXVvdGUgPT4ge1xuXHRcdGxldCBpbmRlbnQgPSAwXG5cblx0XHRsZXQgY2gsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW5cblx0XHRjb25zdFxuXHRcdFx0bG9jID0gKCkgPT4gTG9jKFBvcyhzdGFydExpbmUsIHN0YXJ0Q29sdW1uKSwgcG9zKCkpLFxuXHRcdFx0a2V5d29yZCA9IGsgPT4gS2V5d29yZChsb2MoKSwgayksXG5cdFx0XHRncCA9IGsgPT4gbyhHcm91cFByZShsb2MoKSwgaykpLFxuXHRcdFx0ZWF0TnVtYmVyID0gKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXQgPSB0YWtlV2hpbGVXaXRoUHJldihpc051bWJlckNoYXJhY3Rlcilcblx0XHRcdFx0Y29uc3QgbnVtID0gTnVtYmVyKGxpdClcblx0XHRcdFx0Y3guY2hlY2soIU51bWJlci5pc05hTihudW0pLCBwb3MsICgpID0+XG5cdFx0XHRcdFx0YEludmFsaWQgbnVtYmVyIGxpdGVyYWwgJHtjb2RlKGxpdCl9YClcblx0XHRcdFx0cmV0dXJuIFRva2VuTnVtYmVyTGl0ZXJhbChsb2MoKSwgbnVtKVxuXHRcdFx0fVxuXG5cdFx0d2hpbGUgKGluZGV4ICE9PSBzdHIubGVuZ3RoKSB7XG5cdFx0XHRzdGFydExpbmUgPSBsaW5lXG5cdFx0XHRzdGFydENvbHVtbiA9IGNvbHVtblxuXG5cdFx0XHRjaCA9IGVhdCgpXG5cdFx0XHRzd2l0Y2ggKGNoKSB7XG5cdFx0XHRcdGNhc2UgTjA6IGNhc2UgTjE6IGNhc2UgTjI6IGNhc2UgTjM6IGNhc2UgTjQ6XG5cdFx0XHRcdGNhc2UgTjU6IGNhc2UgTjY6IGNhc2UgTjc6IGNhc2UgTjg6IGNhc2UgTjk6XG5cdFx0XHRcdFx0byhlYXROdW1iZXIoKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE9wUGFyZW46XG5cdFx0XHRcdFx0Z3AoR1BfT3BlblBhcmVuKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgT3BCcmFja2V0OlxuXHRcdFx0XHRcdGdwKEdQX09wZW5CcmFja2V0KVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xQYXJlbjpcblx0XHRcdFx0XHRncChHUF9DbG9zZVBhcmVuKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgQ2xCcmFja2V0OlxuXHRcdFx0XHRcdGdwKEdQX0Nsb3NlQnJhY2tldClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIENsQnJhY2U6XG5cdFx0XHRcdFx0Y3guY2hlY2soaXNJblF1b3RlLCBsb2MsICgpID0+IGBSZXNlcnZlZCBjaGFyYWN0ZXIgJHtzaG93Q2hhcihjaCl9YClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0Y2FzZSBTcGFjZTpcblx0XHRcdFx0XHRjeC53YXJuSWYocGVlaygpID09PSBTcGFjZSwgbG9jLCAnTXVsdGlwbGUgc3BhY2VzIGluIGEgcm93Jylcblx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIERvdDoge1xuXHRcdFx0XHRcdGNvbnN0IHAgPSBwZWVrKClcblx0XHRcdFx0XHRpZiAocCA9PT0gU3BhY2UgfHwgcCA9PT0gTmV3bGluZSkge1xuXHRcdFx0XHRcdFx0Ly8gT2JqTGl0IGFzc2lnbiBpbiBpdHMgb3duIHNwYWNlZCBncm91cC5cblx0XHRcdFx0XHRcdC8vIFdlIGNhbid0IGp1c3QgY3JlYXRlIGEgbmV3IEdyb3VwIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvXG5cdFx0XHRcdFx0XHQvLyBlbnN1cmUgaXQncyBub3QgcGFydCBvZiB0aGUgcHJlY2VkaW5nIG9yIGZvbGxvd2luZyBzcGFjZWQgZ3JvdXAuXG5cdFx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRcdG8oa2V5d29yZCgnLiAnKSlcblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0byhEb3ROYW1lKFxuXHRcdFx0XHRcdFx0XHRsb2MoKSxcblx0XHRcdFx0XHRcdFx0Ly8gKzEgZm9yIHRoZSBkb3Qgd2UganVzdCBza2lwcGVkLlxuXHRcdFx0XHRcdFx0XHRza2lwV2hpbGVFcXVhbHMoRG90KSArIDEsXG5cdFx0XHRcdFx0XHRcdHRha2VXaGlsZShpc05hbWVDaGFyYWN0ZXIpKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgQ29sb246XG5cdFx0XHRcdFx0byhrZXl3b3JkKCc6JykpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBUaWxkZTpcblx0XHRcdFx0XHRpZiAodHJ5RWF0KEJhcikpIHtcblx0XHRcdFx0XHRcdG8oa2V5d29yZCgnfnwnKSlcblx0XHRcdFx0XHRcdGdwKEdQX1NwYWNlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0byhrZXl3b3JkKCd+JykpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEJhcjpcblx0XHRcdFx0XHQvLyBGaXJzdCBhcmcgaW4gaXRzIG93biBzcGFjZWQgZ3JvdXBcblx0XHRcdFx0XHRvKGtleXdvcmQoJ3wnKSlcblx0XHRcdFx0XHRncChHUF9TcGFjZSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFVuZGVyc2NvcmU6XG5cdFx0XHRcdFx0byhrZXl3b3JkKCdfJykpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBIYXNoOlxuXHRcdFx0XHRcdHNraXBSZXN0T2ZMaW5lKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIE5ld2xpbmU6IHtcblx0XHRcdFx0XHRjeC5jaGVjayghaXNJblF1b3RlLCBsb2MsICdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKHByZXYoKSAhPT0gU3BhY2UsIGxvYywgJ0xpbmUgZW5kcyBpbiBhIHNwYWNlJylcblxuXHRcdFx0XHRcdC8vIFNraXAgYW55IGJsYW5rIGxpbmVzLlxuXHRcdFx0XHRcdHNraXBOZXdsaW5lcygpXG5cdFx0XHRcdFx0Y29uc3Qgb2xkSW5kZW50ID0gaW5kZW50XG5cdFx0XHRcdFx0aW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHRjeC5jaGVjayhwZWVrKCkgIT09IFNwYWNlLCBwb3MsICdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJylcblx0XHRcdFx0XHRpZiAoaW5kZW50IDw9IG9sZEluZGVudCkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGluZGVudDsgaSA8IG9sZEluZGVudDsgaSA9IGkgKyAxKVxuXHRcdFx0XHRcdFx0XHRncChHUF9DbG9zZUJsb2NrKVxuXHRcdFx0XHRcdFx0Z3AoR1BfTGluZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3guY2hlY2soaW5kZW50ID09PSBvbGRJbmRlbnQgKyAxLCBsb2MsICdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlJylcblx0XHRcdFx0XHRcdGdwKEdQX09wZW5CbG9jaylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFRhYjpcblx0XHRcdFx0XHRjeC5mYWlsKGxvYygpLCAnVGFiIG1heSBvbmx5IGJlIHVzZWQgdG8gaW5kZW50Jylcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGxleFF1b3RlKGluZGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEh5cGhlbjpcblx0XHRcdFx0XHRpZiAoaXNEaWdpdChwZWVrKCkpKSB7XG5cdFx0XHRcdFx0XHRvKGVhdE51bWJlcigpKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0Y3guY2hlY2soXG5cdFx0XHRcdFx0XHQhaXNSZXNlcnZlZENoYXJhY3RlcihjaCksIGxvYywgKCkgPT4gYFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdFx0XHRcdC8vIEFsbCBvdGhlciBjaGFyYWN0ZXJzIHNob3VsZCBiZSBoYW5kbGVkIGluIGEgY2FzZSBhYm92ZS5cblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGFrZVdoaWxlV2l0aFByZXYoaXNOYW1lQ2hhcmFjdGVyKVxuXHRcdFx0XHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAncmVnaW9uJzpcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdCBvZiBsaW5lIGlzIGEgY29tbWVudC5cblx0XHRcdFx0XHRcdFx0c2tpcFJlc3RPZkxpbmUoKVxuXHRcdFx0XHRcdFx0XHRvKGtleXdvcmQoJ3JlZ2lvbicpKVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0aWYgKHRyeUVhdChVbmRlcnNjb3JlKSlcblx0XHRcdFx0XHRcdFx0XHRvKENhbGxPbkZvY3VzKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoQWxsS2V5d29yZHMuaGFzKG5hbWUpKVxuXHRcdFx0XHRcdFx0XHRcdG8oa2V5d29yZChuYW1lKSlcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoUmVzZXJ2ZWRXb3Jkcy5oYXMobmFtZSkpXG5cdFx0XHRcdFx0XHRcdFx0Y3guZmFpbChsb2MsIGBSZXNlcnZlZCB3b3JkICR7Y29kZShuYW1lKX1gKVxuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0byhOYW1lKGxvYygpLCBuYW1lKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBsZXhRdW90ZSA9IGluZGVudCA9PiB7XG5cdFx0Y29uc3QgcXVvdGVJbmRlbnQgPSBpbmRlbnQgKyAxXG5cblx0XHRjb25zdCBpc0luZGVudGVkID0gdHJ5RWF0TmV3bGluZSgpXG5cdFx0aWYgKGlzSW5kZW50ZWQpIHtcblx0XHRcdGNvbnN0IGFjdHVhbEluZGVudCA9IHNraXBXaGlsZUVxdWFscyhUYWIpXG5cdFx0XHRjeC5jaGVjayhhY3R1YWxJbmRlbnQgPT09IHF1b3RlSW5kZW50LCBwb3MsXG5cdFx0XHRcdCdJbmRlbnRlZCBxdW90ZSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgbW9yZSBpbmRlbnQgdGhhbiBwcmV2aW91cyBsaW5lLicpXG5cdFx0fVxuXG5cdFx0bGV0IHJlYWQgPSAnJ1xuXG5cdFx0Y29uc3QgeWllbGRSZWFkID0gKCkgPT4ge1xuXHRcdFx0aWYgKHJlYWQgIT09ICcnKSB7XG5cdFx0XHRcdG8ocmVhZClcblx0XHRcdFx0cmVhZCA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0byhHcm91cFByZShsb2MoKSwgR1BfT3BlblF1b3RlKSlcblxuXHRcdGVhdENoYXJzOiB3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgY2hQb3MgPSBwb3MoKVxuXHRcdFx0Y29uc3QgY2ggPSBlYXQoKVxuXHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRjYXNlIEJhY2tzbGFzaDoge1xuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgcXVvdGVFc2NhcGUoZWF0KCkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIE9wQnJhY2U6IHtcblx0XHRcdFx0XHR5aWVsZFJlYWQoKVxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IGNyZWF0ZSBhIEdyb3VwIG5vdyBiZWNhdXNlIHRoZXJlIG1heSBiZSBvdGhlciBHcm91cFByZV9zIGluc2lkZS5cblx0XHRcdFx0XHRvKEdyb3VwUHJlKHNpbmdsZUNoYXJMb2MoY2hQb3MpLCBHUF9PcGVuUGFyZW4pKVxuXHRcdFx0XHRcdHVuZ3JvdXBlZCh0cnVlKVxuXHRcdFx0XHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUGFyZW4pKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBOZXdsaW5lOiB7XG5cdFx0XHRcdFx0Y3guY2hlY2socHJldiAhPT0gU3BhY2UsIGNoUG9zLCAnTGluZSBlbmRzIGluIGEgc3BhY2UnKVxuXHRcdFx0XHRcdGN4LmNoZWNrKGlzSW5kZW50ZWQsIGNoUG9zLCAnVW5jbG9zZWQgcXVvdGUuJylcblx0XHRcdFx0XHRsZXQgbmV3SW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblxuXHRcdFx0XHRcdGxldCBleHRyYU5ld2xpbmVzID0gJydcblx0XHRcdFx0XHQvLyBBbGxvdyBibGFuayBsaW5lcy5cblx0XHRcdFx0XHRpZiAobmV3SW5kZW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRleHRyYU5ld2xpbmVzID0gJ1xcbicucmVwZWF0KHNraXBOZXdsaW5lcygpKVxuXHRcdFx0XHRcdFx0bmV3SW5kZW50ID0gc2tpcFdoaWxlRXF1YWxzKFRhYilcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobmV3SW5kZW50IDwgcXVvdGVJbmRlbnQpIHtcblx0XHRcdFx0XHRcdC8vIEluZGVudGVkIHF1b3RlIHNlY3Rpb24gaXMgb3Zlci5cblx0XHRcdFx0XHRcdC8vIFVuZG8gcmVhZGluZyB0aGUgdGFicyBhbmQgbmV3bGluZS5cblx0XHRcdFx0XHRcdHN0ZXBCYWNrTWFueShjaFBvcywgbmV3SW5kZW50ICsgMSlcblx0XHRcdFx0XHRcdGFzc2VydChwZWVrKCkgPT09IE5ld2xpbmUpXG5cdFx0XHRcdFx0XHRicmVhayBlYXRDaGFyc1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0cmVhZCA9IHJlYWQgKyBleHRyYU5ld2xpbmVzICsgJ1xcbicgKyAnXFx0Jy5yZXBlYXQobmV3SW5kZW50IC0gcXVvdGVJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFF1b3RlOlxuXHRcdFx0XHRcdGlmICghaXNJbmRlbnRlZClcblx0XHRcdFx0XHRcdGJyZWFrIGVhdENoYXJzXG5cdFx0XHRcdFx0Ly8gRWxzZSBmYWxsdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlYWQgPSByZWFkICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaClcblx0XHRcdH1cblx0XHR9XG5cblx0XHR5aWVsZFJlYWQoKVxuXHRcdG8oR3JvdXBQcmUobG9jKCksIEdQX0Nsb3NlUXVvdGUpKVxuXHR9XG5cblx0Y29uc3QgcXVvdGVFc2NhcGUgPSBjaCA9PiB7XG5cdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0Y2FzZSBPcEJyYWNlOiByZXR1cm4gJ3snXG5cdFx0XHRjYXNlIExldHRlck46IHJldHVybiAnXFxuJ1xuXHRcdFx0Y2FzZSBMZXR0ZXJUOiByZXR1cm4gJ1xcdCdcblx0XHRcdGNhc2UgUXVvdGU6IHJldHVybiAnXCInXG5cdFx0XHRjYXNlIEJhY2tzbGFzaDogcmV0dXJuICdcXFxcJ1xuXHRcdFx0ZGVmYXVsdDogY3guZmFpbChwb3MsIGBObyBuZWVkIHRvIGVzY2FwZSAke3Nob3dDaGFyKGNoKX1gKVxuXHRcdH1cblx0fVxuXG5cdHVuZ3JvdXBlZChmYWxzZSlcblx0cmV0dXJuIHJlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=