if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', './Op', './util'], function (exports, module, _Op, _util) {
	'use strict';

	module.exports = type;

	function _interopRequire(obj) { return obj && obj.__esModule ? obj['default'] : obj; }

	var _Op2 = _interopRequire(_Op);

	function type() {
		if (!global.DEBUG) return;
		for (let i = 0; i < arguments.length; i = i + 2) typePair(arguments[i], arguments[i + 1]);
	}

	function typePair(instance, itsType) {
		if (itsType instanceof Array) {
			_util.assert(itsType.length === 1);
			const emType = itsType[0];
			type(instance, Array);
			instance.forEach(function (em) {
				// console.log(type) // TODO: turning on this line causes a crash in node v0.11.15.
				type(em, emType);
			});
		}
		if (!isa(instance, itsType)) {
			if (instance === null) throw new Error('Value null');
			if (instance === undefined) throw new Error('Value undefined');
			const toArray = require('./Bag').toArray;
			const strType = itsType instanceof Array ? '[' + itsType[0].name + ']' : itsType instanceof Set ? '{' + toArray(itsType.values()) : itsType.displayName || itsType.name;
			throw new Error('' + instance + ' is not a ' + strType);
		}
	}

	function isa(instance, itsType) {
		switch (true) {
			case itsType.prototype !== undefined:
				return instance != null && itsType.prototype.isPrototypeOf(Object(instance));
			case itsType instanceof Array:
				{
					_util.assert(itsType.length === 1);
					const emType = itsType[0];
					return instance instanceof Array && instance.every(function (em) {
						return isa(em, emType);
					});
				}
			case _Op2.prototype.isPrototypeOf(itsType):
				return instance instanceof Array && instance.length < 2 && (instance.length === 0 || isa(instance[0], itsType.type));
			case itsType instanceof Set:
				return itsType.has(instance);
			default:
				throw new Error('Not a type: ' + itsType);
		}
	}
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL1UvdHlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7a0JBR3dCLElBQUk7Ozs7OztBQUFiLFVBQVMsSUFBSSxHQUFHO0FBQzlCLE1BQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUNoQixPQUFNO0FBQ1AsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQzlDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0VBQ3pDOztBQUVELFVBQVMsUUFBUSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUU7QUFDcEMsTUFBSSxPQUFPLFlBQVksS0FBSyxFQUFFO0FBQzdCLFNBWE8sTUFBTSxDQVdOLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUE7QUFDNUIsU0FBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3pCLE9BQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDckIsV0FBUSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEVBQUUsRUFBSTs7QUFFdEIsUUFBSSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUNoQixDQUFDLENBQUE7R0FDRjtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxFQUFFO0FBQzVCLE9BQUksUUFBUSxLQUFLLElBQUksRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBQ3BELE9BQUksUUFBUSxLQUFLLFNBQVMsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7QUFDOUQsU0FBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQTtBQUN4QyxTQUFNLE9BQU8sR0FDWixPQUFPLFlBQVksS0FBSyxTQUNwQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUNuQixPQUFPLFlBQVksR0FBRyxTQUNsQixPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQzVCLE9BQU8sQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLElBQUksQUFBQyxDQUFBO0FBQ3RDLFNBQU0sSUFBSSxLQUFLLE1BQUksUUFBUSxrQkFBYSxPQUFPLENBQUcsQ0FBQTtHQUNsRDtFQUNEOztBQUVELFVBQVMsR0FBRyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUU7QUFDL0IsVUFBUSxJQUFJO0FBQ1gsUUFBSyxPQUFPLENBQUMsU0FBUyxLQUFLLFNBQVM7QUFDbkMsV0FBTyxRQUFRLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFBO0FBQUEsQUFDN0UsUUFBSyxPQUFPLFlBQVksS0FBSztBQUFFO0FBQzlCLFdBdENNLE1BQU0sQ0FzQ0wsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQTtBQUM1QixXQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDekIsWUFBTyxRQUFRLFlBQVksS0FBSyxJQUMvQixRQUFRLENBQUMsS0FBSyxDQUFDLFVBQUEsRUFBRTthQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDO01BQUEsQ0FBQyxDQUFBO0tBQ3RDO0FBQUEsQUFDRCxRQUFLLEtBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7QUFDdkMsV0FBTyxRQUFRLFlBQVksS0FBSyxJQUMvQixRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsS0FDbEIsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUEsQUFBQyxDQUFBO0FBQUEsQUFDM0QsUUFBSyxPQUFPLFlBQVksR0FBRztBQUMxQixXQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUE7QUFBQSxBQUM3QjtBQUNDLFVBQU0sSUFBSSxLQUFLLGtCQUFnQixPQUFPLENBQUcsQ0FBQTtBQUFBLEdBQzFDO0VBQ0QiLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvVS90eXBlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9wIGZyb20gJy4vT3AnXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHR5cGUoKSB7XG5cdGlmICghZ2xvYmFsLkRFQlVHKVxuXHRcdHJldHVyblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgPSBpICsgMilcblx0XHR0eXBlUGFpcihhcmd1bWVudHNbaV0sIGFyZ3VtZW50c1tpICsgMV0pXG59XG5cbmZ1bmN0aW9uIHR5cGVQYWlyKGluc3RhbmNlLCBpdHNUeXBlKSB7XG5cdGlmIChpdHNUeXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRhc3NlcnQoaXRzVHlwZS5sZW5ndGggPT09IDEpXG5cdFx0Y29uc3QgZW1UeXBlID0gaXRzVHlwZVswXVxuXHRcdHR5cGUoaW5zdGFuY2UsIEFycmF5KVxuXHRcdGluc3RhbmNlLmZvckVhY2goZW0gPT4ge1xuXHRcdFx0Ly8gY29uc29sZS5sb2codHlwZSkgLy8gVE9ETzogdHVybmluZyBvbiB0aGlzIGxpbmUgY2F1c2VzIGEgY3Jhc2ggaW4gbm9kZSB2MC4xMS4xNS5cblx0XHRcdHR5cGUoZW0sIGVtVHlwZSlcblx0XHR9KVxuXHR9XG5cdGlmICghaXNhKGluc3RhbmNlLCBpdHNUeXBlKSkge1xuXHRcdGlmIChpbnN0YW5jZSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBudWxsJylcblx0XHRpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB1bmRlZmluZWQnKVxuXHRcdGNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCcuL0JhZycpLnRvQXJyYXlcblx0XHRjb25zdCBzdHJUeXBlID1cblx0XHRcdGl0c1R5cGUgaW5zdGFuY2VvZiBBcnJheSA/XG5cdFx0XHRgWyR7aXRzVHlwZVswXS5uYW1lfV1gIDpcblx0XHRcdGl0c1R5cGUgaW5zdGFuY2VvZiBTZXQgP1xuXHRcdFx0YHske3RvQXJyYXkoaXRzVHlwZS52YWx1ZXMoKSl9YCA6XG5cdFx0XHQoaXRzVHlwZS5kaXNwbGF5TmFtZSB8fCBpdHNUeXBlLm5hbWUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKGAke2luc3RhbmNlfSBpcyBub3QgYSAke3N0clR5cGV9YClcblx0fVxufVxuXG5mdW5jdGlvbiBpc2EoaW5zdGFuY2UsIGl0c1R5cGUpIHtcblx0c3dpdGNoICh0cnVlKSB7XG5cdFx0Y2FzZSBpdHNUeXBlLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkOlxuXHRcdFx0cmV0dXJuIGluc3RhbmNlICE9IG51bGwgJiYgaXRzVHlwZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihPYmplY3QoaW5zdGFuY2UpKVxuXHRcdGNhc2UgaXRzVHlwZSBpbnN0YW5jZW9mIEFycmF5OiB7XG5cdFx0XHRhc3NlcnQoaXRzVHlwZS5sZW5ndGggPT09IDEpXG5cdFx0XHRjb25zdCBlbVR5cGUgPSBpdHNUeXBlWzBdXG5cdFx0XHRyZXR1cm4gaW5zdGFuY2UgaW5zdGFuY2VvZiBBcnJheSAmJlxuXHRcdFx0XHRpbnN0YW5jZS5ldmVyeShlbSA9PiBpc2EoZW0sIGVtVHlwZSkpXG5cdFx0fVxuXHRcdGNhc2UgT3AucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaXRzVHlwZSk6XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2UgaW5zdGFuY2VvZiBBcnJheSAmJlxuXHRcdFx0XHRpbnN0YW5jZS5sZW5ndGggPCAyICYmXG5cdFx0XHRcdChpbnN0YW5jZS5sZW5ndGggPT09IDAgfHwgaXNhKGluc3RhbmNlWzBdLCBpdHNUeXBlLnR5cGUpKVxuXHRcdGNhc2UgaXRzVHlwZSBpbnN0YW5jZW9mIFNldDpcblx0XHRcdHJldHVybiBpdHNUeXBlLmhhcyhpbnN0YW5jZSlcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBOb3QgYSB0eXBlOiAke2l0c1R5cGV9YClcblx0fVxufVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=