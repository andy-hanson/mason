if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	const assert = function (cond) {
		if (!cond) throw new Error('Assertion failed.');
	},
	      cat = function () {
		for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
			parts[_key] = arguments[_key];
		}

		const out = [];
		parts.forEach(function (_) {
			if (_ instanceof Array) out.push.apply(out, _toConsumableArray(_));else if (_ !== null) out.push(_);
		});
		return out;
	},
	      flatMap = function (mapped, mapper) {
		const out = [];
		mapped.forEach(function (_, i) {
			return out.push.apply(out, _toConsumableArray(mapper(_, i)));
		});
		return out;
	},
	     

	// flatMap where opMapper returns optionals instead of arrays.
	flatOpMap = function (arr, opMapper) {
		const out = [];
		arr.forEach(function (em) {
			return opEach(opMapper(em), function (_) {
				return out.push(_);
			});
		});
		return out;
	},
	      head = function (arr) {
		assert(!isEmpty(arr));
		return arr[0];
	},
	      ifElse = function (op, ifSome, ifNone) {
		return op === null ? ifNone() : ifSome(op);
	},
	      implementMany = function (holder, methodName, nameToImpl) {
		return Object.keys(nameToImpl).forEach(function (name) {
			return holder[name].prototype[methodName] = nameToImpl[name];
		});
	},
	      isEmpty = function (arr) {
		return arr.length === 0;
	},
	     

	// -0 is negative
	isPositive = function (n) {
		return n >= 0 && 1 / n !== -Infinity;
	},
	      iteratorToArray = function (iter) {
		const out = [];
		for (let em of iter) out.push(em);
		return out;
	},
	      last = function (arr) {
		assert(!isEmpty(arr));
		return arr[arr.length - 1];
	},
	     

	// TODO:ES6 map.keys()
	mapKeys = function (map) {
		const res = [];
		map.forEach(function (value, key) {
			return res.push(key);
		});
		return res;
	},
	     

	// TODO:ES6 Just use `new Set`
	newSet = function () {
		const set = new Set();
		for (let i = 0; i < arguments.length; i = i + 1) arguments[i].forEach(function (_) {
			return set.add(_);
		});
		return set;
	},
	      opEach = function (op, mapper) {
		return op === null ? null : mapper(op);
	},
	      opIf = function (cond, makeOp) {
		return cond ? makeOp() : null;
	},
	      opMap = opEach,
	      push = function (mutArr, em) {
		mutArr.push(em);
		return mutArr;
	},
	      range = function (max) {
		const out = [];
		for (let i = 0; i < max; i = i + 1) out.push(i);
		return out;
	},
	      repeat = function (em, n) {
		assert(n >= 0);
		const out = [];
		for (let i = n; i > 0; i = i - 1) out.push(em);
		return out;
	},
	      rtail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(0, arr.length - 1);
	},
	      tail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(1);
	},
	      type = function (instance, itsType) {
		if (!(Object(instance) instanceof itsType)) throw new Error('' + instance + ' is not a ' + itsType.name);
	},
	      unshift = function (em, mutArr) {
		mutArr.unshift(em);
		return mutArr;
	};
	exports.assert = assert;
	exports.cat = cat;
	exports.flatMap = flatMap;
	exports.flatOpMap = flatOpMap;
	exports.head = head;
	exports.ifElse = ifElse;
	exports.implementMany = implementMany;
	exports.isEmpty = isEmpty;
	exports.isPositive = isPositive;
	exports.iteratorToArray = iteratorToArray;
	exports.last = last;
	exports.mapKeys = mapKeys;
	exports.newSet = newSet;
	exports.opEach = opEach;
	exports.opIf = opIf;
	exports.opMap = opMap;
	exports.push = push;
	exports.range = range;
	exports.repeat = repeat;
	exports.rtail = rtail;
	exports.tail = tail;
	exports.type = type;
	exports.unshift = unshift;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sT0FDTixNQUFNLEdBQUcsVUFBQSxJQUFJLEVBQUk7QUFDaEIsTUFBSSxDQUFDLElBQUksRUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7RUFDckM7T0FFRCxHQUFHLEdBQUcsWUFBYztvQ0FBVixLQUFLO0FBQUwsUUFBSzs7O0FBQ2QsUUFBTSxHQUFHLEdBQUcsRUFBRyxDQUFBO0FBQ2YsT0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsRUFBSTtBQUNsQixPQUFJLENBQUMsWUFBWSxLQUFLLEVBQ3JCLEdBQUcsQ0FBQyxJQUFJLE1BQUEsQ0FBUixHQUFHLHFCQUFTLENBQUMsRUFBQyxDQUFBLEtBQ1YsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUNsQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ1osQ0FBQyxDQUFBO0FBQ0YsU0FBTyxHQUFHLENBQUE7RUFDVjtPQUVELE9BQU8sR0FBRyxVQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUs7QUFDN0IsUUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFBO0FBQ2QsUUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDO1VBQUssR0FBRyxDQUFDLElBQUksTUFBQSxDQUFSLEdBQUcscUJBQVMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQztHQUFBLENBQUMsQ0FBQTtBQUNuRCxTQUFPLEdBQUcsQ0FBQTtFQUNWOzs7O0FBR0QsVUFBUyxHQUFHLFVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBSztBQUM5QixRQUFNLEdBQUcsR0FBRyxFQUFHLENBQUE7QUFDZixLQUFHLENBQUMsT0FBTyxDQUFDLFVBQUEsRUFBRTtVQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBQSxDQUFDO1dBQUksR0FBRyxDQUFD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LENBQUMsRUFBRSxDQUFDLENBQUE7QUFDbEIsU0FBTyxNQUFNLENBQUE7RUFDYixDQUFBO1NBdkhELE1BQU0sR0FBTixNQUFNO1NBS04sR0FBRyxHQUFILEdBQUc7U0FXSCxPQUFPLEdBQVAsT0FBTztTQU9QLFNBQVMsR0FBVCxTQUFTO1NBTVQsSUFBSSxHQUFKLElBQUk7U0FLSixNQUFNLEdBQU4sTUFBTTtTQUdOLGFBQWEsR0FBYixhQUFhO1NBSWIsT0FBTyxHQUFQLE9BQU87U0FHUCxVQUFVLEdBQVYsVUFBVTtTQUVWLGVBQWUsR0FBZixlQUFlO1NBT2YsSUFBSSxHQUFKLElBQUk7U0FNSixPQUFPLEdBQVAsT0FBTztTQU9QLE1BQU0sR0FBTixNQUFNO1NBT04sTUFBTSxHQUFOLE1BQU07U0FHTixJQUFJLEdBQUosSUFBSTtTQUdKLEtBQUssR0FBTCxLQUFLO1NBRUwsSUFBSSxHQUFKLElBQUk7U0FLSixLQUFLLEdBQUwsS0FBSztTQU9MLE1BQU0sR0FBTixNQUFNO1NBUU4sS0FBSyxHQUFMLEtBQUs7U0FLTCxJQUFJLEdBQUosSUFBSTtTQUtKLElBQUksR0FBSixJQUFJO1NBS0osT0FBTyxHQUFQLE9BQU8iLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvdXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdFxuXHRhc3NlcnQgPSBjb25kID0+IHtcblx0XHRpZiAoIWNvbmQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQuJylcblx0fSxcblxuXHRjYXQgPSAoLi4ucGFydHMpID0+IHtcblx0XHRjb25zdCBvdXQgPSBbIF1cblx0XHRwYXJ0cy5mb3JFYWNoKF8gPT4ge1xuXHRcdFx0aWYgKF8gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0b3V0LnB1c2goLi4uXylcblx0XHRcdGVsc2UgaWYgKF8gIT09IG51bGwpXG5cdFx0XHRcdG91dC5wdXNoKF8pXG5cdFx0fSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0ZmxhdE1hcCA9IChtYXBwZWQsIG1hcHBlcikgPT4ge1xuXHRcdGNvbnN0IG91dCA9IFtdXG5cdFx0bWFwcGVkLmZvckVhY2goKF8sIGkpID0+IG91dC5wdXNoKC4uLm1hcHBlcihfLCBpKSkpXG5cdFx0cmV0dXJuIG91dFxuXHR9LFxuXG5cdC8vIGZsYXRNYXAgd2hlcmUgb3BNYXBwZXIgcmV0dXJucyBvcHRpb25hbHMgaW5zdGVhZCBvZiBhcnJheXMuXG5cdGZsYXRPcE1hcCA9IChhcnIsIG9wTWFwcGVyKSA9PiB7XG5cdFx0Y29uc3Qgb3V0ID0gWyBdXG5cdFx0YXJyLmZvckVhY2goZW0gPT4gb3BFYWNoKG9wTWFwcGVyKGVtKSwgXyA9PiBvdXQucHVzaChfKSkpXG5cdFx0cmV0dXJuIG91dFxuXHR9LFxuXG5cdGhlYWQgPSBhcnIgPT4ge1xuXHRcdGFzc2VydCghaXNFbXB0eShhcnIpKVxuXHRcdHJldHVybiBhcnJbMF1cblx0fSxcblxuXHRpZkVsc2UgPSAob3AsIGlmU29tZSwgaWZOb25lKSA9PlxuXHRcdG9wID09PSBudWxsID8gaWZOb25lKCkgOiBpZlNvbWUob3ApLFxuXG5cdGltcGxlbWVudE1hbnkgPSAoaG9sZGVyLCBtZXRob2ROYW1lLCBuYW1lVG9JbXBsKSA9PlxuXHRcdE9iamVjdC5rZXlzKG5hbWVUb0ltcGwpLmZvckVhY2gobmFtZSA9PlxuXHRcdFx0aG9sZGVyW25hbWVdLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG5hbWVUb0ltcGxbbmFtZV0pLFxuXG5cdGlzRW1wdHkgPSBhcnIgPT4gYXJyLmxlbmd0aCA9PT0gMCxcblxuXHQvLyAtMCBpcyBuZWdhdGl2ZVxuXHRpc1Bvc2l0aXZlID0gbiA9PiBuID49IDAgJiYgMSAvIG4gIT09IC1JbmZpbml0eSxcblxuXHRpdGVyYXRvclRvQXJyYXkgPSBpdGVyID0+IHtcblx0XHRjb25zdCBvdXQgPSBbXVxuXHRcdGZvciAobGV0IGVtIG9mIGl0ZXIpXG5cdFx0XHRvdXQucHVzaChlbSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0bGFzdCA9IGFyciA9PiB7XG5cdFx0YXNzZXJ0KCFpc0VtcHR5KGFycikpXG5cdFx0cmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV1cblx0fSxcblxuXHQvLyBUT0RPOkVTNiBtYXAua2V5cygpXG5cdG1hcEtleXMgPSBtYXAgPT4ge1xuXHRcdGNvbnN0IHJlcyA9IFsgXVxuXHRcdG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiByZXMucHVzaChrZXkpKVxuXHRcdHJldHVybiByZXNcblx0fSxcblxuXHQvLyBUT0RPOkVTNiBKdXN0IHVzZSBgbmV3IFNldGBcblx0bmV3U2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3Qgc2V0ID0gbmV3IFNldCgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpID0gaSArIDEpXG5cdFx0XHRhcmd1bWVudHNbaV0uZm9yRWFjaChfID0+IHNldC5hZGQoXykpXG5cdFx0cmV0dXJuIHNldFxuXHR9LFxuXG5cdG9wRWFjaCA9IChvcCwgbWFwcGVyKSA9PlxuXHRcdG9wID09PSBudWxsID8gbnVsbCA6IG1hcHBlcihvcCksXG5cblx0b3BJZiA9IChjb25kLCBtYWtlT3ApID0+XG5cdFx0Y29uZCA/IG1ha2VPcCgpIDogbnVsbCxcblxuXHRvcE1hcCA9IG9wRWFjaCxcblxuXHRwdXNoID0gKG11dEFyciwgZW0pID0+IHtcblx0XHRtdXRBcnIucHVzaChlbSlcblx0XHRyZXR1cm4gbXV0QXJyXG5cdH0sXG5cblx0cmFuZ2UgPSBtYXggPT4ge1xuXHRcdGNvbnN0IG91dCA9IFtdXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkgPSBpICsgMSlcblx0XHRcdG91dC5wdXNoKGkpXG5cdFx0cmV0dXJuIG91dFxuXHR9LFxuXG5cdHJlcGVhdCA9IChlbSwgbikgPT4ge1xuXHRcdGFzc2VydChuID49IDApXG5cdFx0Y29uc3Qgb3V0ID0gW11cblx0XHRmb3IgKGxldCBpID0gbjsgaSA+IDA7IGkgPSBpIC0gMSlcblx0XHRcdG91dC5wdXNoKGVtKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRydGFpbCA9IGFyciA9PiB7XG5cdFx0YXNzZXJ0KCFpc0VtcHR5KGFycikpXG5cdFx0cmV0dXJuIGFyci5zbGljZSgwLCBhcnIubGVuZ3RoIC0gMSlcblx0fSxcblxuXHR0YWlsID0gYXJyID0+IHtcblx0XHRhc3NlcnQoIWlzRW1wdHkoYXJyKSlcblx0XHRyZXR1cm4gYXJyLnNsaWNlKDEpXG5cdH0sXG5cblx0dHlwZSA9IChpbnN0YW5jZSwgaXRzVHlwZSkgPT4ge1xuXHRcdGlmICghKE9iamVjdChpbnN0YW5jZSkgaW5zdGFuY2VvZiBpdHNUeXBlKSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihgJHtpbnN0YW5jZX0gaXMgbm90IGEgJHtpdHNUeXBlLm5hbWV9YClcblx0fSxcblxuXHR1bnNoaWZ0ID0gKGVtLCBtdXRBcnIpID0+IHtcblx0XHRtdXRBcnIudW5zaGlmdChlbSlcblx0XHRyZXR1cm4gbXV0QXJyXG5cdH1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9