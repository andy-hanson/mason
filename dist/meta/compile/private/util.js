if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	const assert = function (cond) {
		if (!cond) throw new Error('Assertion failed.');
	},
	      cat = function () {
		for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
			parts[_key] = arguments[_key];
		}

		const out = [];
		parts.forEach(function (_) {
			if (_ instanceof Array) out.push.apply(out, _toConsumableArray(_));else if (_ !== null) out.push(_);
		});
		return out;
	},
	      eachReverse = function (array, action) {
		for (let i = array.length - 1; i >= 0; i = i - 1) action(array[i]);
	},
	      flatMap = function (mapped, mapper) {
		const out = [];
		mapped.forEach(function (_, i) {
			return out.push.apply(out, _toConsumableArray(mapper(_, i)));
		});
		return out;
	},
	     

	// flatMap where opMapper returns optionals instead of arrays.
	flatOpMap = function (arr, opMapper) {
		const out = [];
		arr.forEach(function (em) {
			return opEach(opMapper(em), function (_) {
				return out.push(_);
			});
		});
		return out;
	},
	      head = function (arr) {
		assert(!isEmpty(arr));
		return arr[0];
	},
	      ifElse = function (op, ifSome, ifNone) {
		return op === null ? ifNone() : ifSome(op);
	},
	      implementMany = function (holder, methodName, nameToImpl) {
		return Object.keys(nameToImpl).forEach(function (name) {
			return holder[name].prototype[methodName] = nameToImpl[name];
		});
	},
	      isEmpty = function (arr) {
		return arr.length === 0;
	},
	     

	// -0 is negative
	isPositive = function (n) {
		return n >= 0 && 1 / n !== -Infinity;
	},
	      iteratorToArray = function (iter) {
		const out = [];
		for (let em of iter) out.push(em);
		return out;
	},
	      last = function (arr) {
		assert(!isEmpty(arr));
		return arr[arr.length - 1];
	},
	     

	// TODO:ES6 map.keys()
	mapKeys = function (map) {
		const res = [];
		map.forEach(function (value, key) {
			return res.push(key);
		});
		return res;
	},
	     

	// TODO:ES6 Just use `new Set`
	newSet = function () {
		const set = new Set();
		for (let i = 0; i < arguments.length; i = i + 1) arguments[i].forEach(function (_) {
			return set.add(_);
		});
		return set;
	},
	      opEach = function (op, mapper) {
		return op === null ? null : mapper(op);
	},
	      opIf = function (cond, makeOp) {
		return cond ? makeOp() : null;
	},
	      opMap = opEach,
	      push = function (mutArr, em) {
		mutArr.push(em);
		return mutArr;
	},
	      repeat = function (em, n) {
		assert(n >= 0);
		const out = [];
		for (let i = n; i > 0; i = i - 1) out.push(em);
		return out;
	},
	      rtail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(0, arr.length - 1);
	},
	      tail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(1);
	},
	      type = function (instance, itsType) {
		if (!(Object(instance) instanceof itsType)) throw new Error('' + instance + ' is not a ' + itsType.name);
	},
	      unshift = function (em, mutArr) {
		mutArr.unshift(em);
		return mutArr;
	};
	exports.assert = assert;
	exports.cat = cat;
	exports.eachReverse = eachReverse;
	exports.flatMap = flatMap;
	exports.flatOpMap = flatOpMap;
	exports.head = head;
	exports.ifElse = ifElse;
	exports.implementMany = implementMany;
	exports.isEmpty = isEmpty;
	exports.isPositive = isPositive;
	exports.iteratorToArray = iteratorToArray;
	exports.last = last;
	exports.mapKeys = mapKeys;
	exports.newSet = newSet;
	exports.opEach = opEach;
	exports.opIf = opIf;
	exports.opMap = opMap;
	exports.push = push;
	exports.repeat = repeat;
	exports.rtail = rtail;
	exports.tail = tail;
	exports.type = type;
	exports.unshift = unshift;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sT0FDTixNQUFNLEdBQUcsVUFBQSxJQUFJLEVBQUk7QUFDaEIsTUFBSSxDQUFDLElBQUksRUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7RUFDckM7T0FFRCxHQUFHLEdBQUcsWUFBYztvQ0FBVixLQUFLO0FBQUwsUUFBSzs7O0FBQ2QsUUFBTSxHQUFHLEdBQUcsRUFBRyxDQUFBO0FBQ2YsT0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsRUFBSTtBQUNsQixPQUFJLENBQUMsWUFBWSxLQUFLLEVBQ3JCLEdBQUcsQ0FBQyxJQUFJLE1BQUEsQ0FBUixHQUFHLHFCQUFTLENBQUMsRUFBQyxDQUFBLEtBQ1YsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUNsQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ1osQ0FBQyxDQUFBO0FBQ0YsU0FBTyxHQUFHLENBQUE7RUFDVjtPQUVELFdBQVcsR0FBRyxVQUFDLEtBQUssRUFBRSxNQUFNLEVBQUs7QUFDaEMsT0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUMvQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7RUFDakI7T0FFRCxPQUFPLEdBQUcsVUFBQyxNQUFNLEVBQUUsTUFBTSxFQUFLO0FBQzdCLFFBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQTtBQUNkLFFBQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQztVQUFLLEdBQUcsQ0FBQyxJQUFJLE1BQUEsQ0FBUixHQUFHLHFCQUFTLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUM7R0FBQSxDQUFDLENBQUE7QUFDbkQs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QUMsQ0FBQTtBQUNsQixTQUFPLE1BQU0sQ0FBQTtFQUNiLENBQUE7U0FySEQsTUFBTSxHQUFOLE1BQU07U0FLTixHQUFHLEdBQUgsR0FBRztTQVdILFdBQVcsR0FBWCxXQUFXO1NBS1gsT0FBTyxHQUFQLE9BQU87U0FPUCxTQUFTLEdBQVQsU0FBUztTQU1ULElBQUksR0FBSixJQUFJO1NBS0osTUFBTSxHQUFOLE1BQU07U0FHTixhQUFhLEdBQWIsYUFBYTtTQUliLE9BQU8sR0FBUCxPQUFPO1NBR1AsVUFBVSxHQUFWLFVBQVU7U0FFVixlQUFlLEdBQWYsZUFBZTtTQU9mLElBQUksR0FBSixJQUFJO1NBTUosT0FBTyxHQUFQLE9BQU87U0FPUCxNQUFNLEdBQU4sTUFBTTtTQU9OLE1BQU0sR0FBTixNQUFNO1NBR04sSUFBSSxHQUFKLElBQUk7U0FHSixLQUFLLEdBQUwsS0FBSztTQUVMLElBQUksR0FBSixJQUFJO1NBS0osTUFBTSxHQUFOLE1BQU07U0FRTixLQUFLLEdBQUwsS0FBSztTQUtMLElBQUksR0FBSixJQUFJO1NBS0osSUFBSSxHQUFKLElBQUk7U0FLSixPQUFPLEdBQVAsT0FBTyIsImZpbGUiOiJtZXRhL2NvbXBpbGUvcHJpdmF0ZS91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0XG5cdGFzc2VydCA9IGNvbmQgPT4ge1xuXHRcdGlmICghY29uZClcblx0XHRcdHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZC4nKVxuXHR9LFxuXG5cdGNhdCA9ICguLi5wYXJ0cykgPT4ge1xuXHRcdGNvbnN0IG91dCA9IFsgXVxuXHRcdHBhcnRzLmZvckVhY2goXyA9PiB7XG5cdFx0XHRpZiAoXyBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0XHRvdXQucHVzaCguLi5fKVxuXHRcdFx0ZWxzZSBpZiAoXyAhPT0gbnVsbClcblx0XHRcdFx0b3V0LnB1c2goXylcblx0XHR9KVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRlYWNoUmV2ZXJzZSA9IChhcnJheSwgYWN0aW9uKSA9PiB7XG5cdFx0Zm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSA9IGkgLSAxKVxuXHRcdFx0YWN0aW9uKGFycmF5W2ldKVxuXHR9LFxuXG5cdGZsYXRNYXAgPSAobWFwcGVkLCBtYXBwZXIpID0+IHtcblx0XHRjb25zdCBvdXQgPSBbXVxuXHRcdG1hcHBlZC5mb3JFYWNoKChfLCBpKSA9PiBvdXQucHVzaCguLi5tYXBwZXIoXywgaSkpKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHQvLyBmbGF0TWFwIHdoZXJlIG9wTWFwcGVyIHJldHVybnMgb3B0aW9uYWxzIGluc3RlYWQgb2YgYXJyYXlzLlxuXHRmbGF0T3BNYXAgPSAoYXJyLCBvcE1hcHBlcikgPT4ge1xuXHRcdGNvbnN0IG91dCA9IFsgXVxuXHRcdGFyci5mb3JFYWNoKGVtID0+IG9wRWFjaChvcE1hcHBlcihlbSksIF8gPT4gb3V0LnB1c2goXykpKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRoZWFkID0gYXJyID0+IHtcblx0XHRhc3NlcnQoIWlzRW1wdHkoYXJyKSlcblx0XHRyZXR1cm4gYXJyWzBdXG5cdH0sXG5cblx0aWZFbHNlID0gKG9wLCBpZlNvbWUsIGlmTm9uZSkgPT5cblx0XHRvcCA9PT0gbnVsbCA/IGlmTm9uZSgpIDogaWZTb21lKG9wKSxcblxuXHRpbXBsZW1lbnRNYW55ID0gKGhvbGRlciwgbWV0aG9kTmFtZSwgbmFtZVRvSW1wbCkgPT5cblx0XHRPYmplY3Qua2V5cyhuYW1lVG9JbXBsKS5mb3JFYWNoKG5hbWUgPT5cblx0XHRcdGhvbGRlcltuYW1lXS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBuYW1lVG9JbXBsW25hbWVdKSxcblxuXHRpc0VtcHR5ID0gYXJyID0+IGFyci5sZW5ndGggPT09IDAsXG5cblx0Ly8gLTAgaXMgbmVnYXRpdmVcblx0aXNQb3NpdGl2ZSA9IG4gPT4gbiA+PSAwICYmIDEgLyBuICE9PSAtSW5maW5pdHksXG5cblx0aXRlcmF0b3JUb0FycmF5ID0gaXRlciA9PiB7XG5cdFx0Y29uc3Qgb3V0ID0gW11cblx0XHRmb3IgKGxldCBlbSBvZiBpdGVyKVxuXHRcdFx0b3V0LnB1c2goZW0pXG5cdFx0cmV0dXJuIG91dFxuXHR9LFxuXG5cdGxhc3QgPSBhcnIgPT4ge1xuXHRcdGFzc2VydCghaXNFbXB0eShhcnIpKVxuXHRcdHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdXG5cdH0sXG5cblx0Ly8gVE9ETzpFUzYgbWFwLmtleXMoKVxuXHRtYXBLZXlzID0gbWFwID0+IHtcblx0XHRjb25zdCByZXMgPSBbIF1cblx0XHRtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gcmVzLnB1c2goa2V5KSlcblx0XHRyZXR1cm4gcmVzXG5cdH0sXG5cblx0Ly8gVE9ETzpFUzYgSnVzdCB1c2UgYG5ldyBTZXRgXG5cdG5ld1NldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IHNldCA9IG5ldyBTZXQoKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSA9IGkgKyAxKVxuXHRcdFx0YXJndW1lbnRzW2ldLmZvckVhY2goXyA9PiBzZXQuYWRkKF8pKVxuXHRcdHJldHVybiBzZXRcblx0fSxcblxuXHRvcEVhY2ggPSAob3AsIG1hcHBlcikgPT5cblx0XHRvcCA9PT0gbnVsbCA/IG51bGwgOiBtYXBwZXIob3ApLFxuXG5cdG9wSWYgPSAoY29uZCwgbWFrZU9wKSA9PlxuXHRcdGNvbmQgPyBtYWtlT3AoKSA6IG51bGwsXG5cblx0b3BNYXAgPSBvcEVhY2gsXG5cblx0cHVzaCA9IChtdXRBcnIsIGVtKSA9PiB7XG5cdFx0bXV0QXJyLnB1c2goZW0pXG5cdFx0cmV0dXJuIG11dEFyclxuXHR9LFxuXG5cdHJlcGVhdCA9IChlbSwgbikgPT4ge1xuXHRcdGFzc2VydChuID49IDApXG5cdFx0Y29uc3Qgb3V0ID0gW11cblx0XHRmb3IgKGxldCBpID0gbjsgaSA+IDA7IGkgPSBpIC0gMSlcblx0XHRcdG91dC5wdXNoKGVtKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRydGFpbCA9IGFyciA9PiB7XG5cdFx0YXNzZXJ0KCFpc0VtcHR5KGFycikpXG5cdFx0cmV0dXJuIGFyci5zbGljZSgwLCBhcnIubGVuZ3RoIC0gMSlcblx0fSxcblxuXHR0YWlsID0gYXJyID0+IHtcblx0XHRhc3NlcnQoIWlzRW1wdHkoYXJyKSlcblx0XHRyZXR1cm4gYXJyLnNsaWNlKDEpXG5cdH0sXG5cblx0dHlwZSA9IChpbnN0YW5jZSwgaXRzVHlwZSkgPT4ge1xuXHRcdGlmICghKE9iamVjdChpbnN0YW5jZSkgaW5zdGFuY2VvZiBpdHNUeXBlKSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihgJHtpbnN0YW5jZX0gaXMgbm90IGEgJHtpdHNUeXBlLm5hbWV9YClcblx0fSxcblxuXHR1bnNoaWZ0ID0gKGVtLCBtdXRBcnIpID0+IHtcblx0XHRtdXRBcnIudW5zaGlmdChlbSlcblx0XHRyZXR1cm4gbXV0QXJyXG5cdH1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9