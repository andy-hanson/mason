if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports'], function (exports) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	const assert = function (cond) {
		if (!cond) throw new Error('Assertion failed.');
	},
	      cat = function () {
		for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
			parts[_key] = arguments[_key];
		}

		const out = [];
		parts.forEach(function (_) {
			if (_ instanceof Array) out.push.apply(out, _toConsumableArray(_));else if (_ !== null) out.push(_);
		});
		return out;
	},
	      eachReverse = function (array, action) {
		for (let i = array.length - 1; i >= 0; i = i - 1) action(array[i]);
	},
	      flatMap = function (mapped, mapper) {
		const out = [];
		mapped.forEach(function (_, i) {
			return out.push.apply(out, _toConsumableArray(mapper(_, i)));
		});
		return out;
	},
	     

	// flatMap where opMapper returns optionals instead of arrays.
	flatOpMap = function (arr, opMapper) {
		const out = [];
		arr.forEach(function (em) {
			return opEach(opMapper(em), function (_) {
				return out.push(_);
			});
		});
		return out;
	},
	      head = function (arr) {
		assert(!isEmpty(arr));
		return arr[0];
	},
	      ifElse = function (op, ifSome, ifNone) {
		return op === null ? ifNone() : ifSome(op);
	},
	      implementMany = function (holder, methodName, nameToImpl) {
		return Object.keys(nameToImpl).forEach(function (name) {
			return holder[name].prototype[methodName] = nameToImpl[name];
		});
	},
	      isEmpty = function (arr) {
		return arr.length === 0;
	},
	     

	// -0 is negative
	isPositive = function (n) {
		return n >= 0 && 1 / n !== -Infinity;
	},
	      iteratorToArray = function (iter) {
		const out = [];
		for (let em of iter) out.push(em);
		return out;
	},
	      last = function (arr) {
		assert(!isEmpty(arr));
		return arr[arr.length - 1];
	},
	     

	// TODO:ES6 map.keys()
	mapKeys = function (map) {
		const res = [];
		map.forEach(function (value, key) {
			return res.push(key);
		});
		return res;
	},
	     

	// TODO:ES6 Just use `new Set`
	newSet = function () {
		const set = new Set();
		for (let i = 0; i < arguments.length; i = i + 1) arguments[i].forEach(function (_) {
			return set.add(_);
		});
		return set;
	},
	      opEach = function (op, mapper) {
		return op === null ? null : mapper(op);
	},
	      opIf = function (cond, makeOp) {
		return cond ? makeOp() : null;
	},
	      opMap = opEach,
	      push = function (mutArr, em) {
		mutArr.push(em);
		return mutArr;
	},
	      range = function (max) {
		const out = [];
		for (let i = 0; i < max; i = i + 1) out.push(i);
		return out;
	},
	      repeat = function (em, n) {
		assert(n >= 0);
		const out = [];
		for (let i = n; i > 0; i = i - 1) out.push(em);
		return out;
	},
	      rtail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(0, arr.length - 1);
	},
	      tail = function (arr) {
		assert(!isEmpty(arr));
		return arr.slice(1);
	},
	      type = function (instance, itsType) {
		if (!(Object(instance) instanceof itsType)) throw new Error('' + instance + ' is not a ' + itsType.name);
	},
	      unshift = function (em, mutArr) {
		mutArr.unshift(em);
		return mutArr;
	};
	exports.assert = assert;
	exports.cat = cat;
	exports.eachReverse = eachReverse;
	exports.flatMap = flatMap;
	exports.flatOpMap = flatOpMap;
	exports.head = head;
	exports.ifElse = ifElse;
	exports.implementMany = implementMany;
	exports.isEmpty = isEmpty;
	exports.isPositive = isPositive;
	exports.iteratorToArray = iteratorToArray;
	exports.last = last;
	exports.mapKeys = mapKeys;
	exports.newSet = newSet;
	exports.opEach = opEach;
	exports.opIf = opIf;
	exports.opMap = opMap;
	exports.push = push;
	exports.range = range;
	exports.repeat = repeat;
	exports.rtail = rtail;
	exports.tail = tail;
	exports.type = type;
	exports.unshift = unshift;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ldGEvY29tcGlsZS9wcml2YXRlL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sT0FDTixNQUFNLEdBQUcsVUFBQSxJQUFJLEVBQUk7QUFDaEIsTUFBSSxDQUFDLElBQUksRUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7RUFDckM7T0FFRCxHQUFHLEdBQUcsWUFBYztvQ0FBVixLQUFLO0FBQUwsUUFBSzs7O0FBQ2QsUUFBTSxHQUFHLEdBQUcsRUFBRyxDQUFBO0FBQ2YsT0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsRUFBSTtBQUNsQixPQUFJLENBQUMsWUFBWSxLQUFLLEVBQ3JCLEdBQUcsQ0FBQyxJQUFJLE1BQUEsQ0FBUixHQUFHLHFCQUFTLENBQUMsRUFBQyxDQUFBLEtBQ1YsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUNsQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ1osQ0FBQyxDQUFBO0FBQ0YsU0FBTyxHQUFHLENBQUE7RUFDVjtPQUVELFdBQVcsR0FBRyxVQUFDLEtBQUssRUFBRSxNQUFNLEVBQUs7QUFDaEMsT0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUMvQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7RUFDakI7T0FFRCxPQUFPLEdBQUcsVUFBQyxNQUFNLEVBQUUsTUFBTSxFQUFLO0FBQzdCLFFBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQTtBQUNkLFFBQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQztVQUFLLEdBQUcsQ0FBQyxJQUFJLE1BQUEsQ0FBUixHQUFHLHFCQUFTLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUM7R0FBQSxDQUFDLENBQUE7QUFDbkQs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QUFPLEVBQUs7QUFDN0IsTUFBSSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxPQUFPLENBQUEsQUFBQyxFQUN6QyxNQUFNLElBQUksS0FBSyxNQUFJLFFBQVEsa0JBQWEsT0FBTyxDQUFDLElBQUksQ0FBRyxDQUFBO0VBQ3hEO09BRUQsT0FBTyxHQUFHLFVBQUMsRUFBRSxFQUFFLE1BQU0sRUFBSztBQUN6QixRQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQ2xCLFNBQU8sTUFBTSxDQUFBO0VBQ2IsQ0FBQTtTQTVIRCxNQUFNLEdBQU4sTUFBTTtTQUtOLEdBQUcsR0FBSCxHQUFHO1NBV0gsV0FBVyxHQUFYLFdBQVc7U0FLWCxPQUFPLEdBQVAsT0FBTztTQU9QLFNBQVMsR0FBVCxTQUFTO1NBTVQsSUFBSSxHQUFKLElBQUk7U0FLSixNQUFNLEdBQU4sTUFBTTtTQUdOLGFBQWEsR0FBYixhQUFhO1NBSWIsT0FBTyxHQUFQLE9BQU87U0FHUCxVQUFVLEdBQVYsVUFBVTtTQUVWLGVBQWUsR0FBZixlQUFlO1NBT2YsSUFBSSxHQUFKLElBQUk7U0FNSixPQUFPLEdBQVAsT0FBTztTQU9QLE1BQU0sR0FBTixNQUFNO1NBT04sTUFBTSxHQUFOLE1BQU07U0FHTixJQUFJLEdBQUosSUFBSTtTQUdKLEtBQUssR0FBTCxLQUFLO1NBRUwsSUFBSSxHQUFKLElBQUk7U0FLSixLQUFLLEdBQUwsS0FBSztTQU9MLE1BQU0sR0FBTixNQUFNO1NBUU4sS0FBSyxHQUFMLEtBQUs7U0FLTCxJQUFJLEdBQUosSUFBSTtTQUtKLElBQUksR0FBSixJQUFJO1NBS0osT0FBTyxHQUFQLE9BQU8iLCJmaWxlIjoibWV0YS9jb21waWxlL3ByaXZhdGUvdXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdFxuXHRhc3NlcnQgPSBjb25kID0+IHtcblx0XHRpZiAoIWNvbmQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQuJylcblx0fSxcblxuXHRjYXQgPSAoLi4ucGFydHMpID0+IHtcblx0XHRjb25zdCBvdXQgPSBbIF1cblx0XHRwYXJ0cy5mb3JFYWNoKF8gPT4ge1xuXHRcdFx0aWYgKF8gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0b3V0LnB1c2goLi4uXylcblx0XHRcdGVsc2UgaWYgKF8gIT09IG51bGwpXG5cdFx0XHRcdG91dC5wdXNoKF8pXG5cdFx0fSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0ZWFjaFJldmVyc2UgPSAoYXJyYXksIGFjdGlvbikgPT4ge1xuXHRcdGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGkgPSBpIC0gMSlcblx0XHRcdGFjdGlvbihhcnJheVtpXSlcblx0fSxcblxuXHRmbGF0TWFwID0gKG1hcHBlZCwgbWFwcGVyKSA9PiB7XG5cdFx0Y29uc3Qgb3V0ID0gW11cblx0XHRtYXBwZWQuZm9yRWFjaCgoXywgaSkgPT4gb3V0LnB1c2goLi4ubWFwcGVyKF8sIGkpKSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0Ly8gZmxhdE1hcCB3aGVyZSBvcE1hcHBlciByZXR1cm5zIG9wdGlvbmFscyBpbnN0ZWFkIG9mIGFycmF5cy5cblx0ZmxhdE9wTWFwID0gKGFyciwgb3BNYXBwZXIpID0+IHtcblx0XHRjb25zdCBvdXQgPSBbIF1cblx0XHRhcnIuZm9yRWFjaChlbSA9PiBvcEVhY2gob3BNYXBwZXIoZW0pLCBfID0+IG91dC5wdXNoKF8pKSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0aGVhZCA9IGFyciA9PiB7XG5cdFx0YXNzZXJ0KCFpc0VtcHR5KGFycikpXG5cdFx0cmV0dXJuIGFyclswXVxuXHR9LFxuXG5cdGlmRWxzZSA9IChvcCwgaWZTb21lLCBpZk5vbmUpID0+XG5cdFx0b3AgPT09IG51bGwgPyBpZk5vbmUoKSA6IGlmU29tZShvcCksXG5cblx0aW1wbGVtZW50TWFueSA9IChob2xkZXIsIG1ldGhvZE5hbWUsIG5hbWVUb0ltcGwpID0+XG5cdFx0T2JqZWN0LmtleXMobmFtZVRvSW1wbCkuZm9yRWFjaChuYW1lID0+XG5cdFx0XHRob2xkZXJbbmFtZV0ucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbmFtZVRvSW1wbFtuYW1lXSksXG5cblx0aXNFbXB0eSA9IGFyciA9PiBhcnIubGVuZ3RoID09PSAwLFxuXG5cdC8vIC0wIGlzIG5lZ2F0aXZlXG5cdGlzUG9zaXRpdmUgPSBuID0+IG4gPj0gMCAmJiAxIC8gbiAhPT0gLUluZmluaXR5LFxuXG5cdGl0ZXJhdG9yVG9BcnJheSA9IGl0ZXIgPT4ge1xuXHRcdGNvbnN0IG91dCA9IFtdXG5cdFx0Zm9yIChsZXQgZW0gb2YgaXRlcilcblx0XHRcdG91dC5wdXNoKGVtKVxuXHRcdHJldHVybiBvdXRcblx0fSxcblxuXHRsYXN0ID0gYXJyID0+IHtcblx0XHRhc3NlcnQoIWlzRW1wdHkoYXJyKSlcblx0XHRyZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXVxuXHR9LFxuXG5cdC8vIFRPRE86RVM2IG1hcC5rZXlzKClcblx0bWFwS2V5cyA9IG1hcCA9PiB7XG5cdFx0Y29uc3QgcmVzID0gWyBdXG5cdFx0bWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHJlcy5wdXNoKGtleSkpXG5cdFx0cmV0dXJuIHJlc1xuXHR9LFxuXG5cdC8vIFRPRE86RVM2IEp1c3QgdXNlIGBuZXcgU2V0YFxuXHRuZXdTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRjb25zdCBzZXQgPSBuZXcgU2V0KClcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgPSBpICsgMSlcblx0XHRcdGFyZ3VtZW50c1tpXS5mb3JFYWNoKF8gPT4gc2V0LmFkZChfKSlcblx0XHRyZXR1cm4gc2V0XG5cdH0sXG5cblx0b3BFYWNoID0gKG9wLCBtYXBwZXIpID0+XG5cdFx0b3AgPT09IG51bGwgPyBudWxsIDogbWFwcGVyKG9wKSxcblxuXHRvcElmID0gKGNvbmQsIG1ha2VPcCkgPT5cblx0XHRjb25kID8gbWFrZU9wKCkgOiBudWxsLFxuXG5cdG9wTWFwID0gb3BFYWNoLFxuXG5cdHB1c2ggPSAobXV0QXJyLCBlbSkgPT4ge1xuXHRcdG11dEFyci5wdXNoKGVtKVxuXHRcdHJldHVybiBtdXRBcnJcblx0fSxcblxuXHRyYW5nZSA9IG1heCA9PiB7XG5cdFx0Y29uc3Qgb3V0ID0gW11cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSA9IGkgKyAxKVxuXHRcdFx0b3V0LnB1c2goaSlcblx0XHRyZXR1cm4gb3V0XG5cdH0sXG5cblx0cmVwZWF0ID0gKGVtLCBuKSA9PiB7XG5cdFx0YXNzZXJ0KG4gPj0gMClcblx0XHRjb25zdCBvdXQgPSBbXVxuXHRcdGZvciAobGV0IGkgPSBuOyBpID4gMDsgaSA9IGkgLSAxKVxuXHRcdFx0b3V0LnB1c2goZW0pXG5cdFx0cmV0dXJuIG91dFxuXHR9LFxuXG5cdHJ0YWlsID0gYXJyID0+IHtcblx0XHRhc3NlcnQoIWlzRW1wdHkoYXJyKSlcblx0XHRyZXR1cm4gYXJyLnNsaWNlKDAsIGFyci5sZW5ndGggLSAxKVxuXHR9LFxuXG5cdHRhaWwgPSBhcnIgPT4ge1xuXHRcdGFzc2VydCghaXNFbXB0eShhcnIpKVxuXHRcdHJldHVybiBhcnIuc2xpY2UoMSlcblx0fSxcblxuXHR0eXBlID0gKGluc3RhbmNlLCBpdHNUeXBlKSA9PiB7XG5cdFx0aWYgKCEoT2JqZWN0KGluc3RhbmNlKSBpbnN0YW5jZW9mIGl0c1R5cGUpKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke2luc3RhbmNlfSBpcyBub3QgYSAke2l0c1R5cGUubmFtZX1gKVxuXHR9LFxuXG5cdHVuc2hpZnQgPSAoZW0sIG11dEFycikgPT4ge1xuXHRcdG11dEFyci51bnNoaWZ0KGVtKVxuXHRcdHJldHVybiBtdXRBcnJcblx0fVxuIl0sInNvdXJjZVJvb3QiOiIvc3JjIn0=