{"version":3,"sources":["meta/compile/CompileError.js"],"names":[],"mappings":";;;;;mBAIwB,YAAY;;;;;KAJ7B,GAAG;;KACH,IAAI;;KACF,KAAK,kBAAL,KAAK;;AAEC,UAAS,YAAY,CAAC,OAAO,EAAE;AAC7C,MAAI,EAAE,IAAI,YAAY,YAAY,CAAA,AAAC,EAClC,OAAO,IAAI,YAAY,CAAC,OAAO,CAAC,CAAA;AACjC,MAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA;AACtB,MAAI,CAAC,OAAO,GAAG,OAAO,CAAA;;AAEtB,MAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAA;AAC9B,MAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,CAAA;EAC7C;;AACD,aAAY,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;;AAEhD,OAAM,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,MAAM,CAAC,CAAA;;SAAtD,OAAO,GAAP,OAAO;AAEb,OAAM,IAAI,GAAG,UAAA,GAAG;gBAAS,GAAG;EAAI,CAAA;;SAA1B,IAAI,GAAJ,IAAI;AAEV,OAAM,UAAU,GAAG,WAAU,GAAG,EAAE,SAAS,EAAE;AACnD,QAAM,GAAG,GAAG,YAAY,CAAA;AACxB,MAAI,OAAO,GAAG,CAAC,CAAA;AACf,SAAO,IAAI,EAAE;AACZ,SAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AAC3B,OAAI,KAAK,KAAK,IAAI,EAAE;AACnB,UAAM,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,MAAM,CAAC,CAAA;AACpC,UAAK;IACL,MAAM;AACN,UAAM,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,CAAA;AACrC,UAAM,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;AACzB,WAAO,GAAG,GAAG,CAAC,SAAS,CAAA;IACvB;GACD;EACD,CAAA;SAdY,UAAU,GAAV,UAAU","file":"meta/compile/CompileError.js","sourcesContent":["import Loc from 'esast/dist/Loc'\nimport type from './private/U/type'\nimport { tuple } from './private/U/types'\n\nexport default function CompileError(warning) {\n\tif (!(this instanceof CompileError))\n\t\treturn new CompileError(warning)\n\ttype(warning, Warning)\n\tthis.warning = warning\n\t// In case it's not caught and formatted:\n\tthis.message = warning.message\n\tthis.stack = new Error(warning.message).stack\n}\nCompileError.prototype = Object.create(Error.prototype)\n\nexport const Warning = tuple(Object, 'loc', Loc, 'message', String)\n\nexport const code = str => `{{${str}}}`\n\nexport const formatCode = function*(str, formatter) {\n\tconst rgx = /{{(.*?)}}/g\n\tlet prevIdx = 0\n\twhile (true) {\n\t\tconst match = rgx.exec(str)\n\t\tif (match === null) {\n\t\t\tyield str.slice(prevIdx, str.length)\n\t\t\tbreak\n\t\t} else {\n\t\t\tyield str.slice(prevIdx, match.index)\n\t\t\tyield formatter(match[1])\n\t\t\tprevIdx = rgx.lastIndex\n\t\t}\n\t}\n}\n"],"sourceRoot":"/src"}