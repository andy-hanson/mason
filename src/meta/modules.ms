use
	..$ _ $after $map
	..Fun
	..js new
	..private.bootstrap msCall
	..RegExp regexp
	..Str

$require = |require path
	# TODO:ES6 Shouldn't need `new`
	new $ |resolve reject
		require [ path ] resolve reject

dirname = |path
	path.replace (regexp "/[^/]*$") ""

$get-module.
	doc. "
		Retrieves module code and evaluates it.
		First parameter should be the result of using `require` as a global module.
		This allows module-path to be relative to the module calling this function.
		The module is represented as an object whose keys are its exports and whose `default` key is its default export.
		Note that `use~` lazily evaluates the content of a module, but eagerly loads the module code.
	|require:Fun module-path:Str
		$after ($require require module-path) msCall["getModule"]

$@all-modules.
	doc. "
		All listed modules, as generated by Mason's list-modules task.
		module-list-path should point to the modules-list file.
		require and module-list-path are like in $get-module.
	|require:Fun module-list-path:Str
		modules-list-dir = dirname module-list-path
		$after ($get-module require module-list-path) |mp
			module-paths = msCall "getDefaultExport" mp
			$map module-paths |module-path
				# module-path is relative to module-list-path
				$get-module require "{modules-list-dir}/{module-path}"
